<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC12%E7%AB%A0%20pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC12%E7%AB%A0%20pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>前面的章节关注于不同类型的数据规整流程和NumPy、pandas与其它库的特点。随着时间的发展，pandas发展出了更多适合高级用户的功能。本章就要深入学习pandas的高级功能。</p><h1 id="12-1-分类数据"><a href="#12-1-分类数据" class="headerlink" title="12.1 分类数据"></a>12.1 分类数据</h1><p>这一节介绍的是pandas的分类类型。我会向你展示通过使用它，提高性能和内存的使用率。我还会介绍一些在统计和机器学习中使用分类数据的工具。</p><h2 id="背景和目的"><a href="#背景和目的" class="headerlink" title="背景和目的"></a>背景和目的</h2><p>表中的一列通常会有重复的包含不同值的小集合的情况。我们已经学过了unique和value_counts，它们可以从数组提取出不同的值，并分别计算频率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np; <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: values = pd.Series([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">   ....:                     <span class="string">&#x27;apple&#x27;</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: values</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: pd.unique(values)</span><br><span class="line">Out[<span class="number">13</span>]: array([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: pd.value_counts(values)</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">apple     <span class="number">6</span></span><br><span class="line">orange    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>许多数据系统（数据仓库、统计计算或其它应用）都发展出了特定的表征重复值的方法，以进行高效的存储和计算。在数据仓库中，最好的方法是使用所谓的包含不同值的维表(Dimension Table)，将主要的参数存储为引用维表整数键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: values = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: dim = pd.Series([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: values</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">1</span></span><br><span class="line"><span class="number">6</span>    <span class="number">0</span></span><br><span class="line"><span class="number">7</span>    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: dim</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>可以使用take方法存储原始的字符串Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">19</span>]: dim.take(values)</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>这种用整数表示的方法称为分类或字典编码表示法。不同值得数组称为分类、字典或数据级。本书中，我们使用分类的说法。表示分类的整数值称为分类编码或简单地称为编码。</p><p>分类表示可以在进行分析时大大的提高性能。你也可以在保持编码不变的情况下，对分类进行转换。一些相对简单的转变例子包括：</p><ul><li>重命名分类。</li><li>加入一个新的分类，不改变已经存在的分类的顺序或位置。</li></ul><h2 id="pandas的分类类型"><a href="#pandas的分类类型" class="headerlink" title="pandas的分类类型"></a>pandas的分类类型</h2><p>pandas有一个特殊的分类类型，用于保存使用整数分类表示法的数据。看一个之前的Series例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>] * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: N = <span class="built_in">len</span>(fruits)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;fruit&#x27;</span>: fruits,</span><br><span class="line">   ....:                    <span class="string">&#x27;basket_id&#x27;</span>: np.arange(N),</span><br><span class="line">   ....:                    <span class="string">&#x27;count&#x27;</span>: np.random.randint(<span class="number">3</span>, <span class="number">15</span>, size=N),</span><br><span class="line">   ....:                    <span class="string">&#x27;weight&#x27;</span>: np.random.uniform(<span class="number">0</span>, <span class="number">4</span>, size=N)&#125;,</span><br><span class="line">   ....:                   columns=[<span class="string">&#x27;basket_id&#x27;</span>, <span class="string">&#x27;fruit&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: df</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">   basket_id   fruit  count    weight</span><br><span class="line"><span class="number">0</span>          <span class="number">0</span>   apple      <span class="number">5</span>  <span class="number">3.858058</span></span><br><span class="line"><span class="number">1</span>          <span class="number">1</span>  orange      <span class="number">8</span>  <span class="number">2.612708</span></span><br><span class="line"><span class="number">2</span>          <span class="number">2</span>   apple      <span class="number">4</span>  <span class="number">2.995627</span></span><br><span class="line"><span class="number">3</span>          <span class="number">3</span>   apple      <span class="number">7</span>  <span class="number">2.614279</span></span><br><span class="line"><span class="number">4</span>          <span class="number">4</span>   apple     <span class="number">12</span>  <span class="number">2.990859</span></span><br><span class="line"><span class="number">5</span>          <span class="number">5</span>  orange      <span class="number">8</span>  <span class="number">3.845227</span></span><br><span class="line"><span class="number">6</span>          <span class="number">6</span>   apple      <span class="number">5</span>  <span class="number">0.033553</span></span><br><span class="line"><span class="number">7</span>          <span class="number">7</span>   apple      <span class="number">4</span>  <span class="number">0.425778</span></span><br></pre></td></tr></table></figure><p>这里，df[‘fruit’]是一个Python字符串对象的数组。我们可以通过调用它，将它转变为分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: fruit_cat = df[<span class="string">&#x27;fruit&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: fruit_cat</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">Name: fruit, dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [apple, orange]</span><br></pre></td></tr></table></figure><p>fruit_cat的值不是NumPy数组，而是一个pandas.Categorical实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">26</span>]: c = fruit_cat.values</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: <span class="built_in">type</span>(c)</span><br><span class="line">Out[<span class="number">27</span>]: pandas.core.categorical.Categorical</span><br></pre></td></tr></table></figure><p>分类对象有categories和codes属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: c.categories</span><br><span class="line">Out[<span class="number">28</span>]: Index([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: c.codes</span><br><span class="line">Out[<span class="number">29</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], dtype=int8)</span><br></pre></td></tr></table></figure><p>你可将DataFrame的列通过分配转换结果，转换为分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: df[<span class="string">&#x27;fruit&#x27;</span>] = df[<span class="string">&#x27;fruit&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: df.fruit</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">Name: fruit, dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [apple, orange]</span><br></pre></td></tr></table></figure><p>你还可以从其它Python序列直接创建pandas.Categorical：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: my_categories = pd.Categorical([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: my_categories</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">[foo, bar, baz, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [bar, baz, foo]</span><br></pre></td></tr></table></figure><p>如果你已经从其它源获得了分类编码，你还可以使用from_codes构造器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: categories = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: codes = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: my_cats_2 = pd.Categorical.from_codes(codes, categories)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: my_cats_2</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo, bar, baz]</span><br></pre></td></tr></table></figure><p>与显示指定不同，分类变换不认定指定的分类顺序。因此取决于输入数据的顺序，categories数组的顺序会不同。当使用from_codes或其它的构造器时，你可以指定分类一个有意义的顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: ordered_cat = pd.Categorical.from_codes(codes, categories,</span><br><span class="line">   ....:                                         ordered=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: ordered_cat</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo &lt; bar &lt; baz]</span><br></pre></td></tr></table></figure><p>输出[foo &lt; bar &lt; baz]指明‘foo’位于‘bar’的前面，以此类推。无序的分类实例可以通过as_ordered排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: my_cats_2.as_ordered()</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo &lt; bar &lt; baz]</span><br></pre></td></tr></table></figure><p>最后要注意，分类数据不需要字符串，尽管我仅仅展示了字符串的例子。分类数组可以包括任意不可变类型。</p><h2 id="用分类进行计算"><a href="#用分类进行计算" class="headerlink" title="用分类进行计算"></a>用分类进行计算</h2><p>与非编码版本（比如字符串数组）相比，使用pandas的Categorical有些类似。某些pandas组件，比如groupby函数，更适合进行分类。还有一些函数可以使用有序标志位。</p><p>来看一些随机的数值数据，使用pandas.qcut面元函数。它会返回pandas.Categorical，我们之前使用过pandas.cut，但没解释分类是如何工作的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: draws = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: draws[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">43</span>]: array([-<span class="number">0.2047</span>,  <span class="number">0.4789</span>, -<span class="number">0.5194</span>, -<span class="number">0.5557</span>,  <span class="number">1.9658</span>])</span><br></pre></td></tr></table></figure><p>计算这个数据的分位面元，提取一些统计信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: bins = pd.qcut(draws, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: bins</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">[(-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">0.0101</span>, <span class="number">0.63</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (<span class="number">0.63</span>,</span><br><span class="line"> <span class="number">3.928</span>], ..., (-<span class="number">0.0101</span>, <span class="number">0.63</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">2.95</span>, -<span class="number">0.684</span>], (-<span class="number">0.0101</span>, <span class="number">0.63</span></span><br><span class="line">], (<span class="number">0.63</span>, <span class="number">3.928</span>]]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.95</span>, -<span class="number">0.684</span>] &lt; (-<span class="number">0.684</span>, -<span class="number">0.0101</span>] &lt; (-<span class="number">0.010</span></span><br><span class="line"><span class="number">1</span>, <span class="number">0.63</span>] &lt;</span><br><span class="line">                                    (<span class="number">0.63</span>, <span class="number">3.928</span>]]</span><br></pre></td></tr></table></figure><p>虽然有用，确切的样本分位数与分位的名称相比，不利于生成汇总。我们可以使用labels参数qcut，实现目的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: bins = pd.qcut(draws, <span class="number">4</span>, labels=[<span class="string">&#x27;Q1&#x27;</span>, <span class="string">&#x27;Q2&#x27;</span>, <span class="string">&#x27;Q3&#x27;</span>, <span class="string">&#x27;Q4&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: bins</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">[Q2, Q3, Q2, Q2, Q4, ..., Q3, Q2, Q1, Q3, Q4]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: bins.codes[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">48</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>], dtype=int8)</span><br></pre></td></tr></table></figure><p>加上标签的面元分类不包含数据面元边界的信息，因此可以使用groupby提取一些汇总信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">49</span>]: bins = pd.Series(bins, name=<span class="string">&#x27;quartile&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: results = (pd.Series(draws)</span><br><span class="line">   ....:            .groupby(bins)</span><br><span class="line">   ....:            .agg([<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line">   ....:            .reset_index())</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: results</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">  quartile  count       <span class="built_in">min</span>       <span class="built_in">max</span></span><br><span class="line"><span class="number">0</span>       Q1    <span class="number">250</span> -<span class="number">2.949343</span> -<span class="number">0.685484</span></span><br><span class="line"><span class="number">1</span>       Q2    <span class="number">250</span> -<span class="number">0.683066</span> -<span class="number">0.010115</span></span><br><span class="line"><span class="number">2</span>       Q3    <span class="number">250</span> -<span class="number">0.010032</span>  <span class="number">0.628894</span></span><br><span class="line"><span class="number">3</span>       Q4    <span class="number">250</span>  <span class="number">0.634238</span>  <span class="number">3.927528</span></span><br></pre></td></tr></table></figure><p>分位数列保存了原始的面元分类信息，包括排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">52</span>]: results[<span class="string">&#x27;quartile&#x27;</span>]</span><br><span class="line">Out[<span class="number">52</span>]:</span><br><span class="line"><span class="number">0</span>    Q1</span><br><span class="line"><span class="number">1</span>    Q2</span><br><span class="line"><span class="number">2</span>    Q3</span><br><span class="line"><span class="number">3</span>    Q4</span><br><span class="line">Name: quartile, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]</span><br></pre></td></tr></table></figure><h2 id="用分类提高性能"><a href="#用分类提高性能" class="headerlink" title="用分类提高性能"></a>用分类提高性能</h2><p>如果你是在一个特定数据集上做大量分析，将其转换为分类可以极大地提高效率。DataFrame列的分类使用的内存通常少的多。来看一些包含一千万元素的Series，和一些不同的分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">53</span>]: N = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: draws = pd.Series(np.random.randn(N))</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: labels = pd.Series([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>] * (N // <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>现在，将标签转换为分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: categories = labels.astype(<span class="string">&#x27;category&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这时，可以看到标签使用的内存远比分类多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">57</span>]: labels.memory_usage()</span><br><span class="line">Out[<span class="number">57</span>]: <span class="number">80000080</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: categories.memory_usage()</span><br><span class="line">Out[<span class="number">58</span>]: <span class="number">10000272</span></span><br></pre></td></tr></table></figure><p>转换为分类不是没有代价的，但这是一次性的代价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">59</span>]: %time _ = labels.astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">CPU times: user <span class="number">490</span> ms, sys: <span class="number">240</span> ms, total: <span class="number">730</span> ms</span><br><span class="line">Wall time: <span class="number">726</span> ms</span><br></pre></td></tr></table></figure><p>GroupBy使用分类操作明显更快，是因为底层的算法使用整数编码数组，而不是字符串数组。</p><h2 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h2><p>包含分类数据的Series有一些特殊的方法，类似于Series.str字符串方法。它还提供了方便的分类和编码的使用方法。看下面的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">60</span>]: s = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: cat_s = s.astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: cat_s</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>    c</span><br><span class="line"><span class="number">3</span>    d</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    c</span><br><span class="line"><span class="number">7</span>    d</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [a, b, c, d]</span><br></pre></td></tr></table></figure><p>特别的cat属性提供了分类方法的入口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: cat_s.cat.codes</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">1</span></span><br><span class="line"><span class="number">6</span>    <span class="number">2</span></span><br><span class="line"><span class="number">7</span>    <span class="number">3</span></span><br><span class="line">dtype: int8</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: cat_s.cat.categories</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>假设我们知道这个数据的实际分类集，超出了数据中的四个值。我们可以使用set_categories方法改变它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">65</span>]: actual_categories = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: cat_s2 = cat_s.cat.set_categories(actual_categories)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: cat_s2</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>    c</span><br><span class="line"><span class="number">3</span>    d</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    c</span><br><span class="line"><span class="number">7</span>    d</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">5</span>, <span class="built_in">object</span>): [a, b, c, d, e]</span><br></pre></td></tr></table></figure><p>虽然数据看起来没变，新的分类将反映在它们的操作中。例如，如果有的话，value_counts表示分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: cat_s.value_counts()</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">d    <span class="number">2</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: cat_s2.value_counts()</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">d    <span class="number">2</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">e    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>在大数据集中，分类经常作为节省内存和高性能的便捷工具。过滤完大DataFrame或Series之后，许多分类可能不会出现在数据中。我们可以使用remove_unused_categories方法删除没看到的分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">70</span>]: cat_s3 = cat_s[cat_s.isin([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: cat_s3</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [a, b, c, d]</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: cat_s3.cat.remove_unused_categories()</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [a, b]</span><br></pre></td></tr></table></figure><p>表12-1列出了可用的分类方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-6c602152c2bba658.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表12-1 pandas的Series的分类方法"></p><h2 id="为建模创建虚拟变量"><a href="#为建模创建虚拟变量" class="headerlink" title="为建模创建虚拟变量"></a>为建模创建虚拟变量</h2><p>当你使用统计或机器学习工具时，通常会将分类数据转换为虚拟变量，也称为one-hot编码。这包括创建一个不同类别的列的DataFrame；这些列包含给定分类的1s，其它为0。</p><p>看前面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: cat_s = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] * <span class="number">2</span>, dtype=<span class="string">&#x27;category&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面的第7章提到过，pandas.get_dummies函数可以转换这个分类数据为包含虚拟变量的DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: pd.get_dummies(cat_s)</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">   a  b  c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">7</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="12-2-GroupBy高级应用"><a href="#12-2-GroupBy高级应用" class="headerlink" title="12.2 GroupBy高级应用"></a>12.2 GroupBy高级应用</h1><p>尽管我们在第10章已经深度学习了Series和DataFrame的Groupby方法，还有一些方法也是很有用的。</p><h2 id="分组转换和“解封”GroupBy"><a href="#分组转换和“解封”GroupBy" class="headerlink" title="分组转换和“解封”GroupBy"></a>分组转换和“解封”GroupBy</h2><p>在第10章，我们在分组操作中学习了apply方法，进行转换。还有另一个transform方法，它与apply很像，但是对使用的函数有一定限制：</p><ul><li>它可以产生向分组形状广播标量值</li><li>它可以产生一个和输入组形状相同的对象</li><li>它不能修改输入</li></ul><p>来看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">75</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] * <span class="number">4</span>,</span><br><span class="line">   ....:                    <span class="string">&#x27;value&#x27;</span>: np.arange(<span class="number">12.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: df</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">   key  value</span><br><span class="line"><span class="number">0</span>    a    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    b    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    c    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    a    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>    b    <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>    c    <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>    a    <span class="number">6.0</span></span><br><span class="line"><span class="number">7</span>    b    <span class="number">7.0</span></span><br><span class="line"><span class="number">8</span>    c    <span class="number">8.0</span></span><br><span class="line"><span class="number">9</span>    a    <span class="number">9.0</span></span><br><span class="line"><span class="number">10</span>   b   <span class="number">10.0</span></span><br><span class="line"><span class="number">11</span>   c   <span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>按键进行分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">77</span>]: g = df.groupby(<span class="string">&#x27;key&#x27;</span>).value</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: g.mean()</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">key</span><br><span class="line">a    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">5.5</span></span><br><span class="line">c    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure><p>假设我们想产生一个和df[‘value’]形状相同的Series，但值替换为按键分组的平均值。我们可以传递函数lambda x: x.mean()进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">79</span>]: g.transform(<span class="keyword">lambda</span> x: x.mean())</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure><p>对于内置的聚合函数，我们可以传递一个字符串假名作为GroupBy的agg方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">80</span>]: g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure><p>与apply类似，transform的函数会返回Series，但是结果必须与输入大小相同。举个例子，我们可以用lambda函数将每个分组乘以2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">81</span>]: g.transform(<span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">8.0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">10.0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">12.0</span></span><br><span class="line"><span class="number">7</span>     <span class="number">14.0</span></span><br><span class="line"><span class="number">8</span>     <span class="number">16.0</span></span><br><span class="line"><span class="number">9</span>     <span class="number">18.0</span></span><br><span class="line"><span class="number">10</span>    <span class="number">20.0</span></span><br><span class="line"><span class="number">11</span>    <span class="number">22.0</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure><p>再举一个复杂的例子，我们可以计算每个分组的降序排名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">82</span>]: g.transform(<span class="keyword">lambda</span> x: x.rank(ascending=<span class="literal">False</span>))</span><br><span class="line">Out[<span class="number">82</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">7</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">8</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.0</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.0</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure><p>看一个由简单聚合构造的的分组转换函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> (x - x.mean()) / x.std()</span><br></pre></td></tr></table></figure><p>我们用transform或apply可以获得等价的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">84</span>]: g.transform(normalize)</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: g.apply(normalize)</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure><p>内置的聚合函数，比如mean或sum，通常比apply函数快，也比transform快。这允许我们进行一个所谓的解封（unwrapped）分组操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">86</span>]: g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: normalized = (df[<span class="string">&#x27;value&#x27;</span>] - g.transform(<span class="string">&#x27;mean&#x27;</span>)) / g.transform(<span class="string">&#x27;std&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: normalized</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure><p>解封分组操作可能包括多个分组聚合，但是矢量化操作还是会带来收益。</p><h2 id="分组的时间重采样"><a href="#分组的时间重采样" class="headerlink" title="分组的时间重采样"></a>分组的时间重采样</h2><p>对于时间序列数据，resample方法从语义上是一个基于内在时间的分组操作。下面是一个示例表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">89</span>]: N = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: times = pd.date_range(<span class="string">&#x27;2017-05-20 00:00&#x27;</span>, freq=<span class="string">&#x27;1min&#x27;</span>, periods=N)</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;time&#x27;</span>: times,</span><br><span class="line">   ....:                    <span class="string">&#x27;value&#x27;</span>: np.arange(N)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: df</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">                  time  value</span><br><span class="line"><span class="number">0</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:02:<span class="number">00</span>      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:03:<span class="number">00</span>      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:04:<span class="number">00</span>      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">6</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:06:<span class="number">00</span>      <span class="number">6</span></span><br><span class="line"><span class="number">7</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:07:<span class="number">00</span>      <span class="number">7</span></span><br><span class="line"><span class="number">8</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:08:<span class="number">00</span>      <span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:09:<span class="number">00</span>      <span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>     <span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">11</span>:<span class="number">00</span>     <span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">12</span>:<span class="number">00</span>     <span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">13</span>:<span class="number">00</span>     <span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">14</span>:<span class="number">00</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure><p>这里，我们可以用time作为索引，然后重采样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">93</span>]: df.set_index(<span class="string">&#x27;time&#x27;</span>).resample(<span class="string">&#x27;5min&#x27;</span>).count()</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">                     value</span><br><span class="line">time                      </span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure><p>假设DataFrame包含多个时间序列，用一个额外的分组键的列进行标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">94</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;time&#x27;</span>: times.repeat(<span class="number">3</span>),</span><br><span class="line">   ....:                     <span class="string">&#x27;key&#x27;</span>: np.tile([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], N),</span><br><span class="line">   ....:                     <span class="string">&#x27;value&#x27;</span>: np.arange(N * <span class="number">3.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: df2[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">  key                time  value</span><br><span class="line"><span class="number">0</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:02:<span class="number">00</span>    <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>要对每个key值进行相同的重采样，我们引入pandas.TimeGrouper对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">96</span>]: time_key = pd.TimeGrouper(<span class="string">&#x27;5min&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们然后设定时间索引，用key和time_key分组，然后聚合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: resampled = (df2.set_index(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">   ....:              .groupby([<span class="string">&#x27;key&#x27;</span>, time_key])</span><br><span class="line">   ....:              .<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: resampled</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">                         value</span><br><span class="line">key time                      </span><br><span class="line">a   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">30.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">105.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">180.0</span></span><br><span class="line">b   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">35.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">110.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">185.0</span></span><br><span class="line">c   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">40.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">115.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">190.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: resampled.reset_index()</span><br><span class="line">Out[<span class="number">99</span>]:</span><br><span class="line">key                time  value</span><br><span class="line"><span class="number">0</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">30.0</span></span><br><span class="line"><span class="number">1</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">105.0</span></span><br><span class="line"><span class="number">2</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">180.0</span></span><br><span class="line"><span class="number">3</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">35.0</span></span><br><span class="line"><span class="number">4</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">110.0</span></span><br><span class="line"><span class="number">5</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">185.0</span></span><br><span class="line"><span class="number">6</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">40.0</span></span><br><span class="line"><span class="number">7</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">115.0</span></span><br><span class="line"><span class="number">8</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">190.0</span></span><br></pre></td></tr></table></figure><p>使用TimeGrouper的限制是时间必须是Series或DataFrame的索引。</p><h1 id="12-3-链式编程技术"><a href="#12-3-链式编程技术" class="headerlink" title="12.3 链式编程技术"></a>12.3 链式编程技术</h1><p>当对数据集进行一系列变换时，你可能发现创建的多个临时变量其实并没有在分析中用到。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = load_data()</span><br><span class="line">df2 = df[df[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>]</span><br><span class="line">df2[<span class="string">&#x27;col1_demeaned&#x27;</span>] = df2[<span class="string">&#x27;col1&#x27;</span>] - df2[<span class="string">&#x27;col1&#x27;</span>].mean()</span><br><span class="line">result = df2.groupby(<span class="string">&#x27;key&#x27;</span>).col1_demeaned.std()</span><br></pre></td></tr></table></figure><p>虽然这里没有使用真实的数据，这个例子却指出了一些新方法。首先，DataFrame.assign方法是一个df[k] &#x3D; v形式的函数式的列分配方法。它不是就地修改对象，而是返回新的修改过的DataFrame。因此，下面的语句是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usual non-functional way</span></span><br><span class="line">df2 = df.copy()</span><br><span class="line">df2[<span class="string">&#x27;k&#x27;</span>] = v</span><br><span class="line"></span><br><span class="line"><span class="comment"># Functional assign way</span></span><br><span class="line">df2 = df.assign(k=v)</span><br></pre></td></tr></table></figure><p>就地分配可能会比assign快，但是assign可以方便地进行链式编程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = (df2.assign(col1_demeaned=df2.col1 - df2.col2.mean())</span><br><span class="line">          .groupby(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">          .col1_demeaned.std())</span><br></pre></td></tr></table></figure><p>我使用外括号，这样便于添加换行符。</p><p>使用链式编程时要注意，你可能会需要涉及临时对象。在前面的例子中，我们不能使用load_data的结果，直到它被赋值给临时变量df。为了这么做，assign和许多其它pandas函数可以接收类似函数的参数，即可调用对象（callable）。为了展示可调用对象，看一个前面例子的片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = load_data()</span><br><span class="line">df2 = df[df[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>它可以重写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = (load_data()</span><br><span class="line">      [<span class="keyword">lambda</span> x: x[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>这里，load_data的结果没有赋值给某个变量，因此传递到[ ]的函数在这一步被绑定到了对象。</p><p>我们可以把整个过程写为一个单链表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = (load_data()</span><br><span class="line">          [<span class="keyword">lambda</span> x: x.col2 &lt; <span class="number">0</span>]</span><br><span class="line">          .assign(col1_demeaned=<span class="keyword">lambda</span> x: x.col1 - x.col1.mean())</span><br><span class="line">          .groupby(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">          .col1_demeaned.std())</span><br></pre></td></tr></table></figure><p>是否将代码写成这种形式只是习惯而已，将它分开成若干步可以提高可读性。</p><h2 id="管道方法"><a href="#管道方法" class="headerlink" title="管道方法"></a>管道方法</h2><p>你可以用Python内置的pandas函数和方法，用带有可调用对象的链式编程做许多工作。但是，有时你需要使用自己的函数，或是第三方库的函数。这时就要用到管道方法。</p><p>看下面的函数调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = f(df, arg1=v1)</span><br><span class="line">b = g(a, v2, arg3=v3)</span><br><span class="line">c = h(b, arg4=v4)</span><br></pre></td></tr></table></figure><p>当使用接收、返回Series或DataFrame对象的函数式，你可以调用pipe将其重写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = (df.pipe(f, arg1=v1)</span><br><span class="line">          .pipe(g, v2, arg3=v3)</span><br><span class="line">          .pipe(h, arg4=v4))</span><br></pre></td></tr></table></figure><p>f(df)和df.pipe(f)是等价的，但是pipe使得链式声明更容易。</p><p>pipe的另一个有用的地方是提炼操作为可复用的函数。看一个从列减去分组方法的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;col1&#x27;</span>] = df[<span class="string">&#x27;col1&#x27;</span>] - g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure><p>假设你想转换多列，并修改分组的键。另外，你想用链式编程做这个转换。下面就是一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">group_demean</span>(<span class="params">df, by, cols</span>):</span><br><span class="line">    result = df.copy()</span><br><span class="line">    g = df.groupby(by)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">        result[c] = df[c] - g[c].transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>然后可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = (df[df.col1 &lt; <span class="number">0</span>]</span><br><span class="line">          .pipe(group_demean, [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], [<span class="string">&#x27;col1&#x27;</span>]))</span><br></pre></td></tr></table></figure><h1 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h1><p>和其它许多开源项目一样，pandas仍然在不断的变化和进步中。和本书中其它地方一样，这里的重点是放在接下来几年不会发生什么改变且稳定的功能。</p><p>为了深入学习pandas的知识，我建议你学习官方文档，并阅读开发团队发布的文档更新。我们还邀请你加入pandas的开发工作：修改bug、创建新功能、完善文档。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC11%E7%AB%A0%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC11%E7%AB%A0%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>时间序列（time series）数据是一种重要的结构化数据形式，应用于多个领域，包括金融学、经济学、生态学、神经科学、物理学等。在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，也就是说，数据点是根据某种规律定期出现的（比如每15秒、每5分钟、每月出现一次）。时间序列也可以是不定期的，没有固定的时间单位或单位之间的偏移量。时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p><ul><li>时间戳（timestamp），特定的时刻。</li><li>固定时期（period），如2007年1月或2010年全年。</li><li>时间间隔（interval），由起始和结束时间戳表示。时期（period）可以被看做间隔（interval）的特例。</li><li>实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径。</li></ul><p>本章主要讲解前3种时间序列。许多技术都可用于处理实验型时间序列，其索引可能是一个整数或浮点数（表示从实验开始算起已经过去的时间）。最简单也最常见的时间序列都是用时间戳进行索引的。</p><blockquote><p>提示：pandas也支持基于timedeltas的指数，它可以有效代表实验或经过的时间。这本书不涉及timedelta指数，但你可以学习pandas的文档（<a href="http://pandas.pydata.org/%EF%BC%89%E3%80%82">http://pandas.pydata.org/）。</a></p></blockquote><p>pandas提供了许多内置的时间序列处理工具和数据算法。因此，你可以高效处理非常大的时间序列，轻松地进行切片&#x2F;切块、聚合、对定期&#x2F;不定期的时间序列进行重采样等。有些工具特别适合金融和经济应用，你当然也可以用它们来分析服务器日志数据。</p><h1 id="11-1-日期和时间数据类型及工具"><a href="#11-1-日期和时间数据类型及工具" class="headerlink" title="11.1 日期和时间数据类型及工具"></a>11.1 日期和时间数据类型及工具</h1><p>Python标准库包含用于日期（date）和时间（time）数据的数据类型，而且还有日历方面的功能。我们主要会用到datetime、time以及calendar模块。datetime.datetime（也可以简写为datetime）是用得最多的数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: now = datetime.now()</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: now</span><br><span class="line">Out[<span class="number">12</span>]: datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">25</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">52</span>, <span class="number">72973</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: now.year, now.month, now.day</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">2017</span>, <span class="number">9</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p>datetime以毫秒形式存储日期和时间。timedelta表示两个datetime对象之间的时间差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: delta</span><br><span class="line">Out[<span class="number">15</span>]: datetime.timedelta(<span class="number">926</span>, <span class="number">56700</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: delta.days</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">926</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: delta.seconds</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">56700</span></span><br></pre></td></tr></table></figure><p>可以给datetime对象加上（或减去）一个或多个timedelta，这样会产生一个新对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: start + timedelta(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">20</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: start - <span class="number">2</span> * timedelta(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">21</span>]: datetime.datetime(<span class="number">2010</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>datetime模块中的数据类型参见表10-1。虽然本章主要讲的是pandas数据类型和高级时间序列处理，但你肯定会在Python的其他地方遇到有关datetime的数据类型。</p><p>表11-1 datetime模块中的数据类型</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>tzinfo  存储时区信息的基本类型</p><h2 id="字符串和datetime的相互转换"><a href="#字符串和datetime的相互转换" class="headerlink" title="字符串和datetime的相互转换"></a>字符串和datetime的相互转换</h2><p>利用str或strftime方法（传入一个格式化字符串），datetime对象和pandas的Timestamp对象（稍后就会介绍）可以被格式化为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">22</span>]: stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="built_in">str</span>(stamp)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="string">&#x27;2011-01-03 00:00:00&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: stamp.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: <span class="string">&#x27;2011-01-03&#x27;</span></span><br></pre></td></tr></table></figure><p>表11-2列出了全部的格式化编码。</p><p>表11-2 datetime格式定义（兼容ISO C89）</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>datetime.strptime可以用这些格式化编码将字符串转换为日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: value = <span class="string">&#x27;2011-01-03&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: datetime.strptime(value, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">26</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: datestrs = [<span class="string">&#x27;7/6/2011&#x27;</span>, <span class="string">&#x27;8/6/2011&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: [datetime.strptime(x, <span class="string">&#x27;%m/%d/%Y&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> datestrs]</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">[datetime.datetime(<span class="number">2011</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"> datetime.datetime(<span class="number">2011</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>)]</span><br></pre></td></tr></table></figure><p>datetime.strptime是通过已知格式进行日期解析的最佳方式。但是每次都要编写格式定义是很麻烦的事情，尤其是对于一些常见的日期格式。这种情况下，你可以用dateutil这个第三方包中的parser.parse方法（pandas中已经自动安装好了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: parse(<span class="string">&#x27;2011-01-03&#x27;</span>)</span><br><span class="line">Out[<span class="number">30</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>dateutil可以解析几乎所有人类能够理解的日期表示形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: parse(<span class="string">&#x27;Jan 31, 1997 10:45 PM&#x27;</span>)</span><br><span class="line">Out[<span class="number">31</span>]: datetime.datetime(<span class="number">1997</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure><p>在国际通用的格式中，日出现在月的前面很普遍，传入dayfirst&#x3D;True即可解决这个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: parse(<span class="string">&#x27;6/12/2011&#x27;</span>, dayfirst=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">32</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>pandas通常是用于处理成组日期的，不管这些日期是DataFrame的轴索引还是列。to_datetime方法可以解析多种不同的日期表示形式。对标准日期格式（如ISO8601）的解析非常快：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: datestrs = [<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: pd.to_datetime(datestrs)</span><br><span class="line">Out[<span class="number">34</span>]: DatetimeIndex([<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>], dtype=<span class="string">&#x27;dat</span></span><br><span class="line"><span class="string">etime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>它还可以处理缺失值（None、空字符串等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: idx = pd.to_datetime(datestrs + [<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: idx</span><br><span class="line">Out[<span class="number">36</span>]: DatetimeIndex([<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>, <span class="string">&#x27;NaT&#x27;</span>], dty</span><br><span class="line">pe=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: idx[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">37</span>]: NaT</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: pd.isnull(idx)</span><br><span class="line">Out[<span class="number">38</span>]: array([<span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure><p>NaT（Not a Time）是pandas中时间戳数据的null值。</p><blockquote><p>注意：dateutil.parser是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如”42”会被解析为2042年的今天）。</p></blockquote><p>datetime对象还有一些特定于当前环境（位于不同国家或使用不同语言的系统）的格式化选项。例如，德语或法语系统所用的月份简写就与英语系统所用的不同。表11-3进行了总结。</p><p>表11-3 特定于当前环境的日期格式</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="11-2-时间序列基础"><a href="#11-2-时间序列基础" class="headerlink" title="11.2 时间序列基础"></a>11.2 时间序列基础</h1><p>pandas最基本的时间序列类型就是以时间戳（通常以Python字符串或datatime对象表示）为索引的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: dates = [datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">   ....:          datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">   ....:          datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">10</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: ts = pd.Series(np.random.randn(<span class="number">6</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: ts</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>这些datetime对象实际上是被放在一个DatetimeIndex中的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">43</span>]: ts.index</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2011-01-02&#x27;</span>, <span class="string">&#x27;2011-01-05&#x27;</span>, <span class="string">&#x27;2011-01-07&#x27;</span>, <span class="string">&#x27;2011-01-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2011-01-10&#x27;</span>, <span class="string">&#x27;2011-01-12&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>跟其他Series一样，不同索引的时间序列之间的算术运算会自动按日期对齐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: ts + ts[::<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.409415</span></span><br><span class="line"><span class="number">2011</span>-01-05         NaN</span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">1.038877</span></span><br><span class="line"><span class="number">2011</span>-01-08         NaN</span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">3.931561</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>         NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>ts[::2] 是每隔两个取一个。</p><p>pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: ts.index.dtype</span><br><span class="line">Out[<span class="number">45</span>]: dtype(<span class="string">&#x27;&lt;M8[ns]&#x27;</span>)</span><br></pre></td></tr></table></figure><p>DatetimeIndex中的各个标量值是pandas的Timestamp对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: stamp = ts.index[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: stamp</span><br><span class="line">Out[<span class="number">47</span>]: Timestamp(<span class="string">&#x27;2011-01-02 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>只要有需要，TimeStamp可以随时自动转换为datetime对象。此外，它还可以存储频率信息（如果有的话），且知道如何执行时区转换以及其他操作。稍后将对此进行详细讲解。</p><h2 id="索引、选取、子集构造"><a href="#索引、选取、子集构造" class="headerlink" title="索引、选取、子集构造"></a>索引、选取、子集构造</h2><p>当你根据标签索引选取数据时，时间序列和其它的pandas.Series很像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">48</span>]: stamp = ts.index[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: ts[stamp]</span><br><span class="line">Out[<span class="number">49</span>]: -<span class="number">0.51943871505673811</span></span><br></pre></td></tr></table></figure><p>还有一种更为方便的用法：传入一个可以被解释为日期的字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: ts[<span class="string">&#x27;1/10/2011&#x27;</span>]</span><br><span class="line">Out[<span class="number">50</span>]: <span class="number">1.9657805725027142</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: ts[<span class="string">&#x27;20110110&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: <span class="number">1.9657805725027142</span></span><br></pre></td></tr></table></figure><p>对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">52</span>]: longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),</span><br><span class="line">   ....:                       index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: longer_ts</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0.092908</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">0.281746</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.769023</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">1.246435</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">1.007189</span></span><br><span class="line"><span class="number">2000</span>-01-06   -<span class="number">1.296221</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">0.274992</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.228913</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">1.352917</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.886429</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2002</span>-09-<span class="number">17</span>   -<span class="number">0.139298</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">18</span>   -<span class="number">1.159926</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">19</span>    <span class="number">0.618965</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">20</span>    <span class="number">1.373890</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">21</span>   -<span class="number">0.983505</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">22</span>    <span class="number">0.930944</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">23</span>   -<span class="number">0.811676</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">24</span>   -<span class="number">1.830156</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">25</span>   -<span class="number">0.138730</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">26</span>    <span class="number">0.334088</span></span><br><span class="line">Freq: D, Length: <span class="number">1000</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: longer_ts[<span class="string">&#x27;2001&#x27;</span>]</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line"><span class="number">2001</span>-01-01    <span class="number">1.599534</span></span><br><span class="line"><span class="number">2001</span>-01-02    <span class="number">0.474071</span></span><br><span class="line"><span class="number">2001</span>-01-03    <span class="number">0.151326</span></span><br><span class="line"><span class="number">2001</span>-01-04   -<span class="number">0.542173</span></span><br><span class="line"><span class="number">2001</span>-01-05   -<span class="number">0.475496</span></span><br><span class="line"><span class="number">2001</span>-01-06    <span class="number">0.106403</span></span><br><span class="line"><span class="number">2001</span>-01-07   -<span class="number">1.308228</span></span><br><span class="line"><span class="number">2001</span>-01-08    <span class="number">2.173185</span></span><br><span class="line"><span class="number">2001</span>-01-09    <span class="number">0.564561</span></span><br><span class="line"><span class="number">2001</span>-01-<span class="number">10</span>   -<span class="number">0.190481</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">22</span>    <span class="number">0.000369</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">23</span>    <span class="number">0.900885</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">24</span>   -<span class="number">0.454869</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">25</span>   -<span class="number">0.864547</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">26</span>    <span class="number">1.129120</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">27</span>    <span class="number">0.057874</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">28</span>   -<span class="number">0.433739</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">29</span>    <span class="number">0.092698</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">30</span>   -<span class="number">1.397820</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">31</span>    <span class="number">1.457823</span></span><br><span class="line">Freq: D, Length: <span class="number">365</span>, dtype: float64</span><br></pre></td></tr></table></figure><p>这里，字符串“2001”被解释成年，并根据它选取时间区间。指定月也同样奏效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">55</span>]: longer_ts[<span class="string">&#x27;2001-05&#x27;</span>]</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line"><span class="number">2001</span>-05-01   -<span class="number">0.622547</span></span><br><span class="line"><span class="number">2001</span>-05-02    <span class="number">0.936289</span></span><br><span class="line"><span class="number">2001</span>-05-03    <span class="number">0.750018</span></span><br><span class="line"><span class="number">2001</span>-05-04   -<span class="number">0.056715</span></span><br><span class="line"><span class="number">2001</span>-05-05    <span class="number">2.300675</span></span><br><span class="line"><span class="number">2001</span>-05-06    <span class="number">0.569497</span></span><br><span class="line"><span class="number">2001</span>-05-07    <span class="number">1.489410</span></span><br><span class="line"><span class="number">2001</span>-05-08    <span class="number">1.264250</span></span><br><span class="line"><span class="number">2001</span>-05-09   -<span class="number">0.761837</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">10</span>   -<span class="number">0.331617</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2001</span>-05-<span class="number">22</span>    <span class="number">0.503699</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">23</span>   -<span class="number">1.387874</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">24</span>    <span class="number">0.204851</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">25</span>    <span class="number">0.603705</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">26</span>    <span class="number">0.545680</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">27</span>    <span class="number">0.235477</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">28</span>    <span class="number">0.111835</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">29</span>   -<span class="number">1.251504</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">30</span>   -<span class="number">2.949343</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">31</span>    <span class="number">0.634634</span></span><br><span class="line">Freq: D, Length: <span class="number">31</span>, dtype: float64</span><br></pre></td></tr></table></figure><p>datetime对象也可以进行切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>由于大部分时间序列数据都是按照时间先后排序的，因此你也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">57</span>]: ts</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: ts[<span class="string">&#x27;1/6/2011&#x27;</span>:<span class="string">&#x27;1/11/2011&#x27;</span>]</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>跟之前一样，你可以传入字符串日期、datetime或Timestamp。注意，这样切片所产生的是原时间序列的视图，跟NumPy数组的切片运算是一样的。</p><p>这意味着，没有数据被复制，对切片进行修改会反映到原始数据上。</p><p>此外，还有一个等价的实例方法也可以截取两个日期之间TimeSeries：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">59</span>]: ts.truncate(after=<span class="string">&#x27;1/9/2011&#x27;</span>)</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>面这些操作对DataFrame也有效。例如，对DataFrame的行进行索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">60</span>]: dates = pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">100</span>, freq=<span class="string">&#x27;W-WED&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: long_df = pd.DataFrame(np.random.randn(<span class="number">100</span>, <span class="number">4</span>),</span><br><span class="line">   ....:                        index=dates,</span><br><span class="line">   ....:                        columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>,</span><br><span class="line">   ....:                                 <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: long_df.loc[<span class="string">&#x27;5-2001&#x27;</span>]</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2001</span>-05-02 -<span class="number">0.006045</span>  <span class="number">0.490094</span> -<span class="number">0.277186</span> -<span class="number">0.707213</span></span><br><span class="line"><span class="number">2001</span>-05-09 -<span class="number">0.560107</span>  <span class="number">2.735527</span>  <span class="number">0.927335</span>  <span class="number">1.513906</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">16</span>  <span class="number">0.538600</span>  <span class="number">1.273768</span>  <span class="number">0.667876</span> -<span class="number">0.969206</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">23</span>  <span class="number">1.676091</span> -<span class="number">0.817649</span>  <span class="number">0.050188</span>  <span class="number">1.951312</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">30</span>  <span class="number">3.260383</span>  <span class="number">0.963301</span>  <span class="number">1.201206</span> -<span class="number">1.852001</span></span><br></pre></td></tr></table></figure><h2 id="带有重复索引的时间序列"><a href="#带有重复索引的时间序列" class="headerlink" title="带有重复索引的时间序列"></a>带有重复索引的时间序列</h2><p>在某些应用场景中，可能会存在多个观测数据落在同一个时间点上的情况。下面就是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: dates = pd.DatetimeIndex([<span class="string">&#x27;1/1/2000&#x27;</span>, <span class="string">&#x27;1/2/2000&#x27;</span>, <span class="string">&#x27;1/2/2000&#x27;</span>,</span><br><span class="line">   ....:                           <span class="string">&#x27;1/2/2000&#x27;</span>, <span class="string">&#x27;1/3/2000&#x27;</span>])</span><br><span class="line">In [<span class="number">64</span>]: dup_ts = pd.Series(np.arange(<span class="number">5</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: dup_ts</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>通过检查索引的is_unique属性，我们就可以知道它是不是唯一的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: dup_ts.index.is_unique</span><br><span class="line">Out[<span class="number">66</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>对这个时间序列进行索引，要么产生标量值，要么产生切片，具体要看所选的时间点是否重复：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">67</span>]: dup_ts[<span class="string">&#x27;1/3/2000&#x27;</span>]  <span class="comment"># not duplicated</span></span><br><span class="line">Out[<span class="number">67</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: dup_ts[<span class="string">&#x27;1/2/2000&#x27;</span>]  <span class="comment"># duplicated</span></span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>假设你想要对具有非唯一时间戳的数据进行聚合。一个办法是使用groupby，并传入level&#x3D;0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: grouped = dup_ts.groupby(level=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: grouped.count()</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h1 id="11-3-日期的范围、频率以及移动"><a href="#11-3-日期的范围、频率以及移动" class="headerlink" title="11.3 日期的范围、频率以及移动"></a>11.3 日期的范围、频率以及移动</h1><p>pandas中的原生时间序列一般被认为是不规则的，也就是说，它们没有固定的频率。对于大部分应用程序而言，这是无所谓的。但是，它常常需要以某种相对固定的频率进行分析，比如每日、每月、每15分钟等（这样自然会在时间序列中引入缺失值）。幸运的是，pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。例如，我们可以将之前那个时间序列转换为一个具有固定频率（每日）的时间序列，只需调用resample即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">72</span>]: ts</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: resampler = ts.resample(<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><p>字符串“D”是每天的意思。</p><p>频率的转换（或重采样）是一个比较大的主题，稍后将专门用一节来进行讨论（11.6小节）。这里，我将告诉你如何使用基本的频率和它的倍数。</p><h2 id="生成日期范围"><a href="#生成日期范围" class="headerlink" title="生成日期范围"></a>生成日期范围</h2><p>虽然我之前用的时候没有明说，但你可能已经猜到pandas.date_range可用于根据指定的频率生成指定长度的DatetimeIndex：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: index = pd.date_range(<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: index</span><br><span class="line">Out[<span class="number">75</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-04-02&#x27;</span>, <span class="string">&#x27;2012-04-03&#x27;</span>, <span class="string">&#x27;2012-04-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-05&#x27;</span>, <span class="string">&#x27;2012-04-06&#x27;</span>, <span class="string">&#x27;2012-04-07&#x27;</span>, <span class="string">&#x27;2012-04-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-09&#x27;</span>, <span class="string">&#x27;2012-04-10&#x27;</span>, <span class="string">&#x27;2012-04-11&#x27;</span>, <span class="string">&#x27;2012-04-12&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-13&#x27;</span>, <span class="string">&#x27;2012-04-14&#x27;</span>, <span class="string">&#x27;2012-04-15&#x27;</span>, <span class="string">&#x27;2012-04-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-17&#x27;</span>, <span class="string">&#x27;2012-04-18&#x27;</span>, <span class="string">&#x27;2012-04-19&#x27;</span>, <span class="string">&#x27;2012-04-20&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-21&#x27;</span>, <span class="string">&#x27;2012-04-22&#x27;</span>, <span class="string">&#x27;2012-04-23&#x27;</span>, <span class="string">&#x27;2012-04-24&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-25&#x27;</span>, <span class="string">&#x27;2012-04-26&#x27;</span>, <span class="string">&#x27;2012-04-27&#x27;</span>, <span class="string">&#x27;2012-04-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-29&#x27;</span>, <span class="string">&#x27;2012-04-30&#x27;</span>, <span class="string">&#x27;2012-05-01&#x27;</span>, <span class="string">&#x27;2012-05-02&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-03&#x27;</span>, <span class="string">&#x27;2012-05-04&#x27;</span>, <span class="string">&#x27;2012-05-05&#x27;</span>, <span class="string">&#x27;2012-05-06&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-07&#x27;</span>, <span class="string">&#x27;2012-05-08&#x27;</span>, <span class="string">&#x27;2012-05-09&#x27;</span>, <span class="string">&#x27;2012-05-10&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-11&#x27;</span>, <span class="string">&#x27;2012-05-12&#x27;</span>, <span class="string">&#x27;2012-05-13&#x27;</span>, <span class="string">&#x27;2012-05-14&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-15&#x27;</span>, <span class="string">&#x27;2012-05-16&#x27;</span>, <span class="string">&#x27;2012-05-17&#x27;</span>, <span class="string">&#x27;2012-05-18&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-19&#x27;</span>, <span class="string">&#x27;2012-05-20&#x27;</span>, <span class="string">&#x27;2012-05-21&#x27;</span>, <span class="string">&#x27;2012-05-22&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-23&#x27;</span>, <span class="string">&#x27;2012-05-24&#x27;</span>, <span class="string">&#x27;2012-05-25&#x27;</span>, <span class="string">&#x27;2012-05-26&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-27&#x27;</span>, <span class="string">&#x27;2012-05-28&#x27;</span>, <span class="string">&#x27;2012-05-29&#x27;</span>, <span class="string">&#x27;2012-05-30&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-31&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><p>默认情况下，date_range会产生按天计算的时间点。如果只传入起始或结束日期，那就还得传入一个表示一段时间的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">76</span>]: pd.date_range(start=<span class="string">&#x27;2012-04-01&#x27;</span>, periods=<span class="number">20</span>)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-04-02&#x27;</span>, <span class="string">&#x27;2012-04-03&#x27;</span>, <span class="string">&#x27;2012-04-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-05&#x27;</span>, <span class="string">&#x27;2012-04-06&#x27;</span>, <span class="string">&#x27;2012-04-07&#x27;</span>, <span class="string">&#x27;2012-04-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-09&#x27;</span>, <span class="string">&#x27;2012-04-10&#x27;</span>, <span class="string">&#x27;2012-04-11&#x27;</span>, <span class="string">&#x27;2012-04-12&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-13&#x27;</span>, <span class="string">&#x27;2012-04-14&#x27;</span>, <span class="string">&#x27;2012-04-15&#x27;</span>, <span class="string">&#x27;2012-04-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-17&#x27;</span>, <span class="string">&#x27;2012-04-18&#x27;</span>, <span class="string">&#x27;2012-04-19&#x27;</span>, <span class="string">&#x27;2012-04-20&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: pd.date_range(end=<span class="string">&#x27;2012-06-01&#x27;</span>, periods=<span class="number">20</span>)</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-13&#x27;</span>, <span class="string">&#x27;2012-05-14&#x27;</span>, <span class="string">&#x27;2012-05-15&#x27;</span>, <span class="string">&#x27;2012-05-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-17&#x27;</span>, <span class="string">&#x27;2012-05-18&#x27;</span>, <span class="string">&#x27;2012-05-19&#x27;</span>, <span class="string">&#x27;2012-05-20&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-21&#x27;</span>, <span class="string">&#x27;2012-05-22&#x27;</span>, <span class="string">&#x27;2012-05-23&#x27;</span>, <span class="string">&#x27;2012-05-24&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-25&#x27;</span>, <span class="string">&#x27;2012-05-26&#x27;</span>, <span class="string">&#x27;2012-05-27&#x27;</span>,<span class="string">&#x27;2012-05-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-29&#x27;</span>, <span class="string">&#x27;2012-05-30&#x27;</span>, <span class="string">&#x27;2012-05-31&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><p>起始和结束日期定义了日期索引的严格边界。例如，如果你想要生成一个由每月最后一个工作日组成的日期索引，可以传入”BM”频率（表示business end of month，表11-4是频率列表），这样就只会包含时间间隔内（或刚好在边界上的）符合频率要求的日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">78</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-12-01&#x27;</span>, freq=<span class="string">&#x27;BM&#x27;</span>)</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-31&#x27;</span>, <span class="string">&#x27;2000-02-29&#x27;</span>, <span class="string">&#x27;2000-03-31&#x27;</span>, <span class="string">&#x27;2000-04-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-05-31&#x27;</span>, <span class="string">&#x27;2000-06-30&#x27;</span>, <span class="string">&#x27;2000-07-31&#x27;</span>, <span class="string">&#x27;2000-08-31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-09-29&#x27;</span>, <span class="string">&#x27;2000-10-31&#x27;</span>, <span class="string">&#x27;2000-11-30&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;BM&#x27;</span>)</span><br></pre></td></tr></table></figure><p>表11-4 基本的时间序列频率（不完整）</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-8da46ba96544b071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-3ca410609195edc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>date_range默认会保留起始和结束时间戳的时间信息（如果有的话）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">79</span>]: pd.date_range(<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, <span class="string">&#x27;2012-05-03 12:56:31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-04 12:56:31&#x27;</span>, <span class="string">&#x27;2012-05-05 12:56:31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-06 12:56:31&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><p>有时，虽然起始和结束日期带有时间信息，但你希望产生一组被规范化（normalize）到午夜的时间戳。normalize选项即可实现该功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">80</span>]: pd.date_range(<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, periods=<span class="number">5</span>, normalize=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-02&#x27;</span>, <span class="string">&#x27;2012-05-03&#x27;</span>, <span class="string">&#x27;2012-05-04&#x27;</span>, <span class="string">&#x27;2012-05-05&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-06&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="频率和日期偏移量"><a href="#频率和日期偏移量" class="headerlink" title="频率和日期偏移量"></a>频率和日期偏移量</h2><p>pandas中的频率是由一个基础频率（base frequency）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如”M”表示每月，”H”表示每小时。对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。例如，按小时计算的频率可以用Hour类表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">81</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: hour = Hour()</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: hour</span><br><span class="line">Out[<span class="number">83</span>]: &lt;Hour&gt;</span><br></pre></td></tr></table></figure><p>传入一个整数即可定义偏移量的倍数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">84</span>]: four_hours = Hour(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: four_hours</span><br><span class="line">Out[<span class="number">85</span>]: &lt;<span class="number">4</span> * Hours&gt;</span><br></pre></td></tr></table></figure><p>一般来说，无需明确创建这样的对象，只需使用诸如”H”或”4H”这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">86</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-01-03 23:59&#x27;</span>, freq=<span class="string">&#x27;4h&#x27;</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-01 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 20:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 20:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 20:00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;4H&#x27;</span>)</span><br></pre></td></tr></table></figure><p>大部分偏移量对象都可通过加法进行连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">87</span>]: Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>)</span><br><span class="line">Out[<span class="number">87</span>]: &lt;<span class="number">150</span> * Minutes&gt;</span><br></pre></td></tr></table></figure><p>同理，你也可以传入频率字符串（如”2h30min”），这种字符串可以被高效地解析为等效的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">88</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;1h30min&#x27;</span>)</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-01 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 01:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 03:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 04:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 06:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 07:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 09:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 10:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 12:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 13:30:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;90T&#x27;</span>)</span><br></pre></td></tr></table></figure><p>有些频率所描述的时间点并不是均匀分隔的。例如，”M”（日历月末）和”BM”（每月最后一个工作日）就取决于每月的天数，对于后者，还要考虑月末是不是周末。由于没有更好的术语，我将这些称为锚点偏移量（anchored offset）。</p><p>表11-4列出了pandas中的频率代码和日期偏移量类。</p><blockquote><p>笔记：用户可以根据实际需求自定义一些频率类以便提供pandas所没有的日期逻辑，但具体的细节超出了本书的范围。             </p></blockquote><p>表11-4 时间序列的基础频率</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-ff139312cd972204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-adfa57a998c0296e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-d09e577a10d0e6eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="WOM日期"><a href="#WOM日期" class="headerlink" title="WOM日期"></a>WOM日期</h2><p>WOM（Week Of Month）是一种非常实用的频率类，它以WOM开头。它使你能获得诸如“每月第3个星期五”之类的日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">89</span>]: rng = pd.date_range(<span class="string">&#x27;2012-01-01&#x27;</span>, <span class="string">&#x27;2012-09-01&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: <span class="built_in">list</span>(rng)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">[Timestamp(<span class="string">&#x27;2012-01-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-02-17 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-03-16 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-04-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-05-18 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-06-15 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-07-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-08-17 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>)]</span><br></pre></td></tr></table></figure><h2 id="移动（超前和滞后）数据"><a href="#移动（超前和滞后）数据" class="headerlink" title="移动（超前和滞后）数据"></a>移动（超前和滞后）数据</h2><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series和DataFrame都有一个shift方法用于执行单纯的前移或后移操作，保持索引不变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">91</span>]: ts = pd.Series(np.random.randn(<span class="number">4</span>),</span><br><span class="line">   ....:                index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">4</span>, freq=<span class="string">&#x27;M&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: ts</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: ts.shift(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>         NaN</span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>         NaN</span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>    <span class="number">0.838639</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: ts.shift(-<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>   -<span class="number">0.517795</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>         NaN</span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>         NaN</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><p>当我们这样进行移动时，就会在时间序列的前面或后面产生缺失数据。</p><p>shift通常用于计算一个时间序列或多个时间序列（如DataFrame的列）中的百分比变化。可以这样表达：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts / ts.shift(<span class="number">1</span>) - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于单纯的移位操作不会修改索引，所以部分数据会被丢弃。因此，如果频率已知，则可以将其传给shift以便实现对时间戳进行位移而不是对数据进行简单位移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">95</span>]: ts.shift(<span class="number">2</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-05-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-06-<span class="number">30</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><p>这里还可以使用其他频率，于是你就能非常灵活地对数据进行超前和滞后处理了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">96</span>]: ts.shift(<span class="number">3</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-03-03    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-04-03   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-05-03   -<span class="number">0.517795</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: ts.shift(<span class="number">1</span>, freq=<span class="string">&#x27;90T&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span> 01:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="通过偏移量对日期进行位移"><a href="#通过偏移量对日期进行位移" class="headerlink" title="通过偏移量对日期进行位移"></a>通过偏移量对日期进行位移</h2><p>pandas的日期偏移量还可以用在datetime或Timestamp对象上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">98</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: now + <span class="number">3</span> * Day()</span><br><span class="line">Out[<span class="number">100</span>]: Timestamp(<span class="string">&#x27;2011-11-20 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果加的是锚点偏移量（比如MonthEnd），第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">101</span>]: now + MonthEnd()</span><br><span class="line">Out[<span class="number">101</span>]: Timestamp(<span class="string">&#x27;2011-11-30 00:00:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: now + MonthEnd(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">102</span>]: Timestamp(<span class="string">&#x27;2011-12-31 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚动”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">103</span>]: offset = MonthEnd()</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: offset.rollforward(now)</span><br><span class="line">Out[<span class="number">104</span>]: Timestamp(<span class="string">&#x27;2011-11-30 00:00:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: offset.rollback(now)</span><br><span class="line">Out[<span class="number">105</span>]: Timestamp(<span class="string">&#x27;2011-10-31 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>日期偏移量还有一个巧妙的用法，即结合groupby使用这两个“滚动”方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">106</span>]: ts = pd.Series(np.random.randn(<span class="number">20</span>),</span><br><span class="line">   .....:                index=pd.date_range(<span class="string">&#x27;1/15/2000&#x27;</span>, periods=<span class="number">20</span>, freq=<span class="string">&#x27;4d&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: ts</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">15</span>   -<span class="number">0.116696</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">19</span>    <span class="number">2.389645</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">23</span>   -<span class="number">0.932454</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">27</span>   -<span class="number">0.229331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">1.140330</span></span><br><span class="line"><span class="number">2000</span>-02-04    <span class="number">0.439920</span></span><br><span class="line"><span class="number">2000</span>-02-08   -<span class="number">0.823758</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">12</span>   -<span class="number">0.520930</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">16</span>    <span class="number">0.350282</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">20</span>    <span class="number">0.204395</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">24</span>    <span class="number">0.133445</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">28</span>    <span class="number">0.327905</span></span><br><span class="line"><span class="number">2000</span>-03-03    <span class="number">0.072153</span></span><br><span class="line"><span class="number">2000</span>-03-07    <span class="number">0.131678</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">11</span>   -<span class="number">1.297459</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">15</span>    <span class="number">0.997747</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">19</span>    <span class="number">0.870955</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">23</span>   -<span class="number">0.991253</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">27</span>    <span class="number">0.151699</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">1.266151</span></span><br><span class="line">Freq: 4D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: ts.groupby(offset.rollforward).mean()</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.005833</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.015894</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.150209</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>当然，更简单、更快速地实现该功能的办法是使用resample（11.6小节将对此进行详细介绍）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">109</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.005833</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.015894</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.150209</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><h1 id="11-4-时区处理"><a href="#11-4-时区处理" class="headerlink" title="11.4 时区处理"></a>11.4 时区处理</h1><p>时间序列处理工作中最让人不爽的就是对时区的处理。许多人都选择以协调世界时（UTC，它是格林尼治标准时间（Greenwich Mean Time）的接替者，目前已经是国际标准了）来处理时间序列。时区是以UTC偏移量的形式表示的。例如，夏令时期间，纽约比UTC慢4小时，而在全年其他时间则比UTC慢5小时。</p><p>在Python中，时区信息来自第三方库pytz，它使Python可以使用Olson数据库（汇编了世界时区信息）。这对历史数据非常重要，这是因为由于各地政府的各种突发奇想，夏令时转变日期（甚至UTC偏移量）已经发生过多次改变了。就拿美国来说，DST转变时间自1900年以来就改变过多次！</p><p>有关pytz库的更多信息，请查阅其文档。就本书而言，由于pandas包装了pytz的功能，因此你可以不用记忆其API，只要记得时区的名称即可。时区名可以在shell中看到，也可以通过文档查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">110</span>]: <span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: pytz.common_timezones[-<span class="number">5</span>:]</span><br><span class="line">Out[<span class="number">111</span>]: [<span class="string">&#x27;US/Eastern&#x27;</span>, <span class="string">&#x27;US/Hawaii&#x27;</span>, <span class="string">&#x27;US/Mountain&#x27;</span>, <span class="string">&#x27;US/Pacific&#x27;</span>, <span class="string">&#x27;UTC&#x27;</span>]</span><br></pre></td></tr></table></figure><p>要从pytz中获取时区对象，使用pytz.timezone即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">112</span>]: tz = pytz.timezone(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: tz</span><br><span class="line">Out[<span class="number">113</span>]: &lt;DstTzInfo <span class="string">&#x27;America/New_York&#x27;</span> LMT-<span class="number">1</span> day, <span class="number">19</span>:04:<span class="number">00</span> STD&gt;</span><br></pre></td></tr></table></figure><p>pandas中的方法既可以接受时区名也可以接受这些对象。</p><h1 id="时区本地化和转换"><a href="#时区本地化和转换" class="headerlink" title="时区本地化和转换"></a>时区本地化和转换</h1><p>默认情况下，pandas中的时间序列是单纯（naive）的时区。看看下面这个时间序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">114</span>]: rng = pd.date_range(<span class="string">&#x27;3/9/2012 9:30&#x27;</span>, periods=<span class="number">6</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: ts</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>其索引的tz字段为None：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: <span class="built_in">print</span>(ts.index.tz)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>可以用时区集生成日期范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">118</span>]: pd.date_range(<span class="string">&#x27;3/9/2012 9:30&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;D&#x27;</span>, tz=<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-15 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-16 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-17 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-18 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><p>从单纯到本地化的转换是通过tz_localize方法处理的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">119</span>]: ts</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: ts_utc = ts.tz_localize(<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: ts_utc</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: ts_utc.index</span><br><span class="line">Out[<span class="number">122</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一旦时间序列被本地化到某个特定时区，就可以用tz_convert将其转换到别的时区了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">123</span>]: ts_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 04:<span class="number">30</span>:<span class="number">00</span>-05:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 04:<span class="number">30</span>:<span class="number">00</span>-05:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>对于上面这种时间序列（它跨越了美国东部时区的夏令时转变期），我们可以将其本地化到EST，然后转换为UTC或柏林时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">124</span>]: ts_eastern = ts.tz_localize(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: ts_eastern.tz_convert(<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: ts_eastern.tz_convert(<span class="string">&#x27;Europe/Berlin&#x27;</span>)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>tz_localize和tz_convert也是DatetimeIndex的实例方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">127</span>]: ts.index.tz_localize(<span class="string">&#x27;Asia/Shanghai&#x27;</span>)</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+08:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+08:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+08:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, Asia/Shanghai]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：对单纯时间戳的本地化操作还会检查夏令时转变期附近容易混淆或不存在的时间。</p></blockquote><h2 id="操作时区意识型Timestamp对象"><a href="#操作时区意识型Timestamp对象" class="headerlink" title="操作时区意识型Timestamp对象"></a>操作时区意识型Timestamp对象</h2><p>跟时间序列和日期范围差不多，独立的Timestamp对象也能被从单纯型（naive）本地化为时区意识型（time zone-aware），并从一个时区转换到另一个时区：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">128</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2011-03-12 04:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: stamp_utc = stamp.tz_localize(<span class="string">&#x27;utc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: stamp_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line">Out[<span class="number">130</span>]: Timestamp(<span class="string">&#x27;2011-03-11 23:00:00-0500&#x27;</span>, tz=<span class="string">&#x27;America/New_York&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在创建Timestamp时，还可以传入一个时区信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">131</span>]: stamp_moscow = pd.Timestamp(<span class="string">&#x27;2011-03-12 04:00&#x27;</span>, tz=<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: stamp_moscow</span><br><span class="line">Out[<span class="number">132</span>]: Timestamp(<span class="string">&#x27;2011-03-12 04:00:00+0300&#x27;</span>, tz=<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br></pre></td></tr></table></figure><p>时区意识型Timestamp对象在内部保存了一个UTC时间戳值（自UNIX纪元（1970年1月1日）算起的纳秒数）。这个UTC值在时区转换过程中是不会发生变化的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">133</span>]: stamp_utc.value</span><br><span class="line">Out[<span class="number">133</span>]: <span class="number">1299902400000000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: stamp_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>).value</span><br><span class="line">Out[<span class="number">134</span>]: <span class="number">1299902400000000000</span></span><br></pre></td></tr></table></figure><p>当使用pandas的DateOffset对象执行时间算术运算时，运算过程会自动关注是否存在夏令时转变期。这里，我们创建了在DST转变之前的时间戳。首先，来看夏令时转变前的30分钟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">135</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2012-03-12 01:30&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: stamp</span><br><span class="line">Out[<span class="number">137</span>]: Timestamp(<span class="string">&#x27;2012-03-12 01:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: stamp + Hour()</span><br><span class="line">Out[<span class="number">138</span>]: Timestamp(<span class="string">&#x27;2012-03-12 02:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后，夏令时转变前90分钟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">139</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2012-11-04 00:30&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: stamp</span><br><span class="line">Out[<span class="number">140</span>]: Timestamp(<span class="string">&#x27;2012-11-04 00:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: stamp + <span class="number">2</span> * Hour()</span><br><span class="line">Out[<span class="number">141</span>]: Timestamp(<span class="string">&#x27;2012-11-04 01:30:00-0500&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="不同时区之间的运算"><a href="#不同时区之间的运算" class="headerlink" title="不同时区之间的运算"></a>不同时区之间的运算</h2><p>如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC。由于时间戳其实是以UTC存储的，所以这是一个很简单的运算，并不需要发生任何转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">142</span>]: rng = pd.date_range(<span class="string">&#x27;3/7/2012 9:30&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: ts</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line"><span class="number">2012</span>-03-07 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.522356</span></span><br><span class="line"><span class="number">2012</span>-03-08 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.546348</span></span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.733537</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">1.302736</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.022199</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.364287</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">15</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.922839</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">16</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.312656</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">19</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">1.128497</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">20</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.333488</span></span><br><span class="line">Freq: B, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">&#x27;Europe/London&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: result = ts1 + ts2</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: result.index</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-07 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-08 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-15 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="11-5-时期及其算术运算"><a href="#11-5-时期及其算术运算" class="headerlink" title="11.5 时期及其算术运算"></a>11.5 时期及其算术运算</h1><p>时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数，以及表11-4中的频率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">149</span>]: p = pd.Period(<span class="number">2007</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: p</span><br><span class="line">Out[<span class="number">150</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里，这个Period对象表示的是从2007年1月1日到2007年12月31日之间的整段时间。只需对Period对象加上或减去一个整数即可达到根据其频率进行位移的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">151</span>]: p + <span class="number">5</span></span><br><span class="line">Out[<span class="number">151</span>]: Period(<span class="string">&#x27;2012&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: p - <span class="number">2</span></span><br><span class="line">Out[<span class="number">152</span>]: Period(<span class="string">&#x27;2005&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果两个Period对象拥有相同的频率，则它们的差就是它们之间的单位数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">153</span>]: pd.Period(<span class="string">&#x27;2014&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>) - p</span><br><span class="line">Out[<span class="number">153</span>]: <span class="number">7</span></span><br></pre></td></tr></table></figure><p>period_range函数可用于创建规则的时期范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">154</span>]: rng = pd.period_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-06-30&#x27;</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: rng</span><br><span class="line">Out[<span class="number">155</span>]: PeriodIndex([<span class="string">&#x27;2000-01&#x27;</span>, <span class="string">&#x27;2000-02&#x27;</span>, <span class="string">&#x27;2000-03&#x27;</span>, <span class="string">&#x27;2000-04&#x27;</span>, <span class="string">&#x27;2000-05&#x27;</span>, <span class="string">&#x27;20</span></span><br><span class="line"><span class="string">00-06&#x27;</span>], dtype=<span class="string">&#x27;period[M]&#x27;</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br></pre></td></tr></table></figure><p>PeriodIndex类保存了一组Period，它可以在任何pandas数据结构中被用作轴索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">156</span>]: pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</span><br><span class="line">Out[<span class="number">156</span>]: </span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.514551</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.559782</span></span><br><span class="line"><span class="number">2000</span>-03   -<span class="number">0.783408</span></span><br><span class="line"><span class="number">2000</span>-04   -<span class="number">1.797685</span></span><br><span class="line"><span class="number">2000</span>-05   -<span class="number">0.172670</span></span><br><span class="line"><span class="number">2000</span>-06    <span class="number">0.680215</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><p>如果你有一个字符串数组，你也可以使用PeriodIndex类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">157</span>]: values = [<span class="string">&#x27;2001Q3&#x27;</span>, <span class="string">&#x27;2002Q2&#x27;</span>, <span class="string">&#x27;2003Q1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: index = pd.PeriodIndex(values, freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: index</span><br><span class="line">Out[<span class="number">159</span>]: PeriodIndex([<span class="string">&#x27;2001Q3&#x27;</span>, <span class="string">&#x27;2002Q2&#x27;</span>, <span class="string">&#x27;2003Q1&#x27;</span>], dtype=<span class="string">&#x27;period[Q-DEC]&#x27;</span>, freq</span><br><span class="line">=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="时期的频率转换"><a href="#时期的频率转换" class="headerlink" title="时期的频率转换"></a>时期的频率转换</h2><p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率。假设我们有一个年度时期，希望将其转换为当年年初或年末的一个月度时期。该任务非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">160</span>]: p = pd.Period(<span class="string">&#x27;2007&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: p</span><br><span class="line">Out[<span class="number">161</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">162</span>]: Period(<span class="string">&#x27;2007-01&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">163</span>]: Period(<span class="string">&#x27;2007-12&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br></pre></td></tr></table></figure><p>你可以将Period(‘2007’,’A-DEC’)看做一个被划分为多个月度时期的时间段中的游标。图11-1对此进行了说明。对于一个不以12月结束的财政年度，月度子时期的归属情况就不一样了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">164</span>]: p = pd.Period(<span class="string">&#x27;2007&#x27;</span>, freq=<span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">165</span>]: p</span><br><span class="line">Out[<span class="number">165</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">166</span>]: Period(<span class="string">&#x27;2006-07&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">167</span>]: Period(<span class="string">&#x27;2007-06&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-1 Period频率转换示例"></p><p>在将高频率转换为低频率时，超时期（superperiod）是由子时期（subperiod）所属的位置决定的。例如，在A-JUN频率中，月份“2007年8月”实际上是属于周期“2008年”的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">168</span>]: p = pd.Period(<span class="string">&#x27;Aug-2007&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: p.asfreq(<span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line">Out[<span class="number">169</span>]: Period(<span class="string">&#x27;2008&#x27;</span>, <span class="string">&#x27;A-JUN&#x27;</span>)</span><br></pre></td></tr></table></figure><p>完整的PeriodIndex或TimeSeries的频率转换方式也是如此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">170</span>]: rng = pd.period_range(<span class="string">&#x27;2006&#x27;</span>, <span class="string">&#x27;2009&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">172</span>]: ts</span><br><span class="line">Out[<span class="number">172</span>]: </span><br><span class="line"><span class="number">2006</span>    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>   -<span class="number">0.302988</span></span><br><span class="line">Freq: A-DEC, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: ts.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line"><span class="number">2006</span>-01    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>-01    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>-01   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>-01   -<span class="number">0.302988</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><p>这里，根据年度时期的第一个月，每年的时期被取代为每月的时期。如果我们想要每年的最后一个工作日，我们可以使用“B”频率，并指明想要该时期的末尾：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">174</span>]: ts.asfreq(<span class="string">&#x27;B&#x27;</span>, how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line"><span class="number">2006</span>-<span class="number">12</span>-<span class="number">29</span>    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>-<span class="number">12</span>-<span class="number">31</span>    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>-<span class="number">12</span>-<span class="number">31</span>   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>-<span class="number">12</span>-<span class="number">31</span>   -<span class="number">0.302988</span></span><br><span class="line">Freq: B, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="按季度计算的时期频率"><a href="#按季度计算的时期频率" class="headerlink" title="按季度计算的时期频率"></a>按季度计算的时期频率</h2><p>季度型数据在会计、金融等领域中很常见。许多季度型数据都会涉及“财年末”的概念，通常是一年12个月中某月的最后一个日历日或工作日。就这一点来说，时期”2012Q4”根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">175</span>]: p = pd.Period(<span class="string">&#x27;2012Q4&#x27;</span>, freq=<span class="string">&#x27;Q-JAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: p</span><br><span class="line">Out[<span class="number">176</span>]: Period(<span class="string">&#x27;2012Q4&#x27;</span>, <span class="string">&#x27;Q-JAN&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）。图11-2对此进行了说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">177</span>]: p.asfreq(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">177</span>]: Period(<span class="string">&#x27;2011-11-01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: p.asfreq(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">178</span>]: Period(<span class="string">&#x27;2012-01-31&#x27;</span>, <span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11.2 不同季度型频率之间的转换"></p><p>因此，Period之间的算术运算会非常简单。例如，要获取该季度倒数第二个工作日下午4点的时间戳，你可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">179</span>]: p4pm = (p.asfreq(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) - <span class="number">1</span>).asfreq(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;s&#x27;</span>) + <span class="number">16</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: p4pm</span><br><span class="line">Out[<span class="number">180</span>]: Period(<span class="string">&#x27;2012-01-30 16:00&#x27;</span>, <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: p4pm.to_timestamp()</span><br><span class="line">Out[<span class="number">181</span>]: Timestamp(<span class="string">&#x27;2012-01-30 16:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>period_range可用于生成季度型范围。季度型范围的算术运算也跟上面是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">182</span>]: rng = pd.period_range(<span class="string">&#x27;2011Q3&#x27;</span>, <span class="string">&#x27;2012Q4&#x27;</span>, freq=<span class="string">&#x27;Q-JAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: ts = pd.Series(np.arange(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">184</span>]: ts</span><br><span class="line">Out[<span class="number">184</span>]: </span><br><span class="line">2011Q3    <span class="number">0</span></span><br><span class="line">2011Q4    <span class="number">1</span></span><br><span class="line">2012Q1    <span class="number">2</span></span><br><span class="line">2012Q2    <span class="number">3</span></span><br><span class="line">2012Q3    <span class="number">4</span></span><br><span class="line">2012Q4    <span class="number">5</span></span><br><span class="line">Freq: Q-JAN, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: new_rng = (rng.asfreq(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) - <span class="number">1</span>).asfreq(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;s&#x27;</span>) + <span class="number">16</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">186</span>]: ts.index = new_rng.to_timestamp()</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: ts</span><br><span class="line">Out[<span class="number">187</span>]:</span><br><span class="line"><span class="number">2010</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">0</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2011</span>-04-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2011</span>-07-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2012</span>-01-<span class="number">30</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h2 id="将Timestamp转换为Period（及其反向过程）"><a href="#将Timestamp转换为Period（及其反向过程）" class="headerlink" title="将Timestamp转换为Period（及其反向过程）"></a>将Timestamp转换为Period（及其反向过程）</h2><p>通过使用to_period方法，可以将由时间戳索引的Series和DataFrame对象转换为以时期索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">188</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">3</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: ts = pd.Series(np.random.randn(<span class="number">3</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">190</span>]: ts</span><br><span class="line">Out[<span class="number">190</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>    <span class="number">1.663261</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>   -<span class="number">0.996206</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">1.521760</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: pts = ts.to_period()</span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: pts</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line"><span class="number">2000</span>-01    <span class="number">1.663261</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.996206</span></span><br><span class="line"><span class="number">2000</span>-03    <span class="number">1.521760</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><p>由于时期指的是非重叠时间区间，因此对于给定的频率，一个时间戳只能属于一个时期。新PeriodIndex的频率默认是从时间戳推断而来的，你也可以指定任何别的频率。结果中允许存在重复时期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">193</span>]: rng = pd.date_range(<span class="string">&#x27;1/29/2000&#x27;</span>, periods=<span class="number">6</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: ts2 = pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">195</span>]: ts2</span><br><span class="line">Out[<span class="number">195</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: ts2.to_period(<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">Out[<span class="number">196</span>]: </span><br><span class="line"><span class="number">2000</span>-01    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.167933</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><p>要转换回时间戳，使用to_timestamp即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">197</span>]: pts = ts2.to_period()</span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: pts</span><br><span class="line">Out[<span class="number">198</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: pts.to_timestamp(how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="通过数组创建PeriodIndex"><a href="#通过数组创建PeriodIndex" class="headerlink" title="通过数组创建PeriodIndex"></a>通过数组创建PeriodIndex</h2><p>固定频率的数据集通常会将时间信息分开存放在多个列中。例如，在下面这个宏观经济数据集中，年度和季度就分别存放在不同的列中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">200</span>]: data = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: data.head(<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">201</span>]: </span><br><span class="line">     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \</span><br><span class="line"><span class="number">0</span>  <span class="number">1959.0</span>      <span class="number">1.0</span>  <span class="number">2710.349</span>    <span class="number">1707.4</span>  <span class="number">286.898</span>   <span class="number">470.045</span>   <span class="number">1886.9</span>  <span class="number">28.98</span>   </span><br><span class="line"><span class="number">1</span>  <span class="number">1959.0</span>      <span class="number">2.0</span>  <span class="number">2778.801</span>    <span class="number">1733.7</span>  <span class="number">310.859</span>   <span class="number">481.301</span>   <span class="number">1919.7</span>  <span class="number">29.15</span>   </span><br><span class="line"><span class="number">2</span>  <span class="number">1959.0</span>      <span class="number">3.0</span>  <span class="number">2775.488</span>    <span class="number">1751.8</span>  <span class="number">289.226</span>   <span class="number">491.260</span>   <span class="number">1916.4</span>  <span class="number">29.35</span>   </span><br><span class="line"><span class="number">3</span>  <span class="number">1959.0</span>      <span class="number">4.0</span>  <span class="number">2785.204</span>    <span class="number">1753.7</span>  <span class="number">299.356</span>   <span class="number">484.052</span>   <span class="number">1931.3</span>  <span class="number">29.37</span>   </span><br><span class="line"><span class="number">4</span>  <span class="number">1960.0</span>      <span class="number">1.0</span>  <span class="number">2847.699</span>    <span class="number">1770.5</span>  <span class="number">331.722</span>   <span class="number">462.199</span>   <span class="number">1955.5</span>  <span class="number">29.54</span>   </span><br><span class="line">      m1  tbilrate  unemp      pop  infl  realint  </span><br><span class="line"><span class="number">0</span>  <span class="number">139.7</span>      <span class="number">2.82</span>    <span class="number">5.8</span>  <span class="number">177.146</span>  <span class="number">0.00</span>     <span class="number">0.00</span>  </span><br><span class="line"><span class="number">1</span>  <span class="number">141.7</span>      <span class="number">3.08</span>    <span class="number">5.1</span>  <span class="number">177.830</span>  <span class="number">2.34</span>     <span class="number">0.74</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">140.5</span>      <span class="number">3.82</span>    <span class="number">5.3</span>  <span class="number">178.657</span>  <span class="number">2.74</span>     <span class="number">1.09</span>  </span><br><span class="line"><span class="number">3</span>  <span class="number">140.0</span>      <span class="number">4.33</span>    <span class="number">5.6</span>  <span class="number">179.386</span>  <span class="number">0.27</span>     <span class="number">4.06</span>  </span><br><span class="line"><span class="number">4</span>  <span class="number">139.6</span>      <span class="number">3.50</span>    <span class="number">5.2</span>  <span class="number">180.007</span>  <span class="number">2.31</span>     <span class="number">1.19</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: data.year</span><br><span class="line">Out[<span class="number">202</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">6</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">8</span>      <span class="number">1961.0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">1961.0</span></span><br><span class="line">        ...  </span><br><span class="line"><span class="number">193</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">194</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">195</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">196</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">197</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">198</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">199</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">200</span>    <span class="number">2009.0</span></span><br><span class="line"><span class="number">201</span>    <span class="number">2009.0</span></span><br><span class="line"><span class="number">202</span>    <span class="number">2009.0</span></span><br><span class="line">Name: year, Length: <span class="number">203</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">203</span>]: data.quarter</span><br><span class="line">Out[<span class="number">203</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>      <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">8</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">2.0</span></span><br><span class="line">      ... </span><br><span class="line"><span class="number">193</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">194</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">195</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">196</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">197</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">198</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">199</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">200</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">201</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">202</span>    <span class="number">3.0</span></span><br><span class="line">Name: quarter, Length: <span class="number">203</span>, dtype: float64</span><br></pre></td></tr></table></figure><p>通过将这些数组以及一个频率传入PeriodIndex，就可以将它们合并成DataFrame的一个索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">204</span>]: index = pd.PeriodIndex(year=data.year, quarter=data.quarter,</span><br><span class="line">   .....:                        freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: index</span><br><span class="line">Out[<span class="number">205</span>]: </span><br><span class="line">PeriodIndex([<span class="string">&#x27;1959Q1&#x27;</span>, <span class="string">&#x27;1959Q2&#x27;</span>, <span class="string">&#x27;1959Q3&#x27;</span>, <span class="string">&#x27;1959Q4&#x27;</span>, <span class="string">&#x27;1960Q1&#x27;</span>, <span class="string">&#x27;1960Q2&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;1960Q3&#x27;</span>, <span class="string">&#x27;1960Q4&#x27;</span>, <span class="string">&#x27;1961Q1&#x27;</span>, <span class="string">&#x27;1961Q2&#x27;</span>,</span><br><span class="line">             ...</span><br><span class="line">             <span class="string">&#x27;2007Q2&#x27;</span>, <span class="string">&#x27;2007Q3&#x27;</span>, <span class="string">&#x27;2007Q4&#x27;</span>, <span class="string">&#x27;2008Q1&#x27;</span>, <span class="string">&#x27;2008Q2&#x27;</span>, <span class="string">&#x27;2008Q3&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;2008Q4&#x27;</span>, <span class="string">&#x27;2009Q1&#x27;</span>, <span class="string">&#x27;2009Q2&#x27;</span>, <span class="string">&#x27;2009Q3&#x27;</span>],</span><br><span class="line">            dtype=<span class="string">&#x27;period[Q-DEC]&#x27;</span>, length=<span class="number">203</span>, freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">206</span>]: data.index = index</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: data.infl</span><br><span class="line">Out[<span class="number">207</span>]: </span><br><span class="line">1959Q1    <span class="number">0.00</span></span><br><span class="line">1959Q2    <span class="number">2.34</span></span><br><span class="line">1959Q3    <span class="number">2.74</span></span><br><span class="line">1959Q4    <span class="number">0.27</span></span><br><span class="line">1960Q1    <span class="number">2.31</span></span><br><span class="line">1960Q2    <span class="number">0.14</span></span><br><span class="line">1960Q3    <span class="number">2.70</span></span><br><span class="line">1960Q4    <span class="number">1.21</span></span><br><span class="line">1961Q1   -<span class="number">0.40</span></span><br><span class="line">1961Q2    <span class="number">1.47</span></span><br><span class="line">          ... </span><br><span class="line">2007Q2    <span class="number">2.75</span></span><br><span class="line">2007Q3    <span class="number">3.45</span></span><br><span class="line">2007Q4    <span class="number">6.38</span></span><br><span class="line">2008Q1    <span class="number">2.82</span></span><br><span class="line">2008Q2    <span class="number">8.53</span></span><br><span class="line">2008Q3   -<span class="number">3.16</span></span><br><span class="line">2008Q4   -<span class="number">8.79</span></span><br><span class="line">2009Q1    <span class="number">0.94</span></span><br><span class="line">2009Q2    <span class="number">3.37</span></span><br><span class="line">2009Q3    <span class="number">3.56</span></span><br><span class="line">Freq: Q-DEC, Name: infl, Length: <span class="number">203</span>, dtype: float64</span><br></pre></td></tr></table></figure><h1 id="11-6-重采样及频率转换"><a href="#11-6-重采样及频率转换" class="headerlink" title="11.6 重采样及频率转换"></a>11.6 重采样及频率转换</h1><p>重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将W-WED（每周三）转换为W-FRI既不是降采样也不是升采样。</p><p>pandas对象都带有一个resample方法，它是各种频率转换工作的主力函数。resample有一个类似于groupby的API，调用resample可以分组数据，然后会调用一个聚合函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">208</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">100</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: ts</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0.631634</span></span><br><span class="line"><span class="number">2000</span>-01-02   -<span class="number">1.594313</span></span><br><span class="line"><span class="number">2000</span>-01-03   -<span class="number">1.519937</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">1.108752</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">1.255853</span></span><br><span class="line"><span class="number">2000</span>-01-06   -<span class="number">0.024330</span></span><br><span class="line"><span class="number">2000</span>-01-07   -<span class="number">2.047939</span></span><br><span class="line"><span class="number">2000</span>-01-08   -<span class="number">0.272657</span></span><br><span class="line"><span class="number">2000</span>-01-09   -<span class="number">1.692615</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">1.423830</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.007852</span></span><br><span class="line"><span class="number">2000</span>-04-01   -<span class="number">1.638806</span></span><br><span class="line"><span class="number">2000</span>-04-02    <span class="number">1.401227</span></span><br><span class="line"><span class="number">2000</span>-04-03    <span class="number">1.758539</span></span><br><span class="line"><span class="number">2000</span>-04-04    <span class="number">0.628932</span></span><br><span class="line"><span class="number">2000</span>-04-05   -<span class="number">0.423776</span></span><br><span class="line"><span class="number">2000</span>-04-06    <span class="number">0.789740</span></span><br><span class="line"><span class="number">2000</span>-04-07    <span class="number">0.937568</span></span><br><span class="line"><span class="number">2000</span>-04-08   -<span class="number">2.253294</span></span><br><span class="line"><span class="number">2000</span>-04-09   -<span class="number">1.772919</span></span><br><span class="line">Freq: D, Length: <span class="number">100</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">211</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.165893</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.078606</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.223811</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>   -<span class="number">0.063643</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>, kind=<span class="string">&#x27;period&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.165893</span></span><br><span class="line"><span class="number">2000</span>-02    <span class="number">0.078606</span></span><br><span class="line"><span class="number">2000</span>-03    <span class="number">0.223811</span></span><br><span class="line"><span class="number">2000</span>-04   -<span class="number">0.063643</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure><p>resample是一个灵活高效的方法，可用于处理非常大的时间序列。我将通过一系列的示例说明其用法。表11-5总结它的一些选项。</p><p>表11-5 resample方法的参数<br><img src="https://upload-images.jianshu.io/upload_images/7178691-b40a57086c904e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h2><p>将数据聚合到规律的低频率是一件非常普通的时间序列处理任务。待聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界，这些面元用于将时间序列拆分为多个片段。例如，要转换到月度频率（’M’或’BM’），数据需要被划分到多个单月时间段中。各时间段都是半开放的。一个数据点只能属于一个时间段，所有时间段的并集必须能组成整个时间帧。在用resample对数据进行降采样时，需要考虑两样东西：</p><ul><li>各区间哪边是闭合的。</li><li>如何标记各个聚合面元，用区间的开头还是末尾。</li></ul><p>为了说明，我们来看一些“1分钟”数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">213</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">12</span>, freq=<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: ts = pd.Series(np.arange(<span class="number">12</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">215</span>]: ts</span><br><span class="line">Out[<span class="number">215</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:01:<span class="number">00</span>     <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:02:<span class="number">00</span>     <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:03:<span class="number">00</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">00</span>     <span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>     <span class="number">5</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:06:<span class="number">00</span>     <span class="number">6</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:07:<span class="number">00</span>     <span class="number">7</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:08:<span class="number">00</span>     <span class="number">8</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:09:<span class="number">00</span>     <span class="number">9</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">10</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">11</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: T, dtype: int64</span><br></pre></td></tr></table></figure><p>假设你想要通过求和的方式将这些数据聚合到“5分钟”块中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">216</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">216</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure><p>传入的频率将会以“5分钟”的增量定义面元边界。默认情况下，面元的右边界是包含的，因此00:00到00:05的区间中是包含00:05的。传入closed&#x3D;’left’会让区间以左边界闭合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">217</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">217</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure><p>如你所见，最终的时间序列是以各面元右边界的时间戳进行标记的。传入label&#x3D;’right’即可用面元的邮编界对其进行标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">218</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>, label=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">15</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure><p>图11-3说明了“1分钟”数据被转换为“5分钟”数据的处理过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-7a77f47844f2ee8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-3 各种closed、label约定的“5分钟”重采样演示"></p><p>最后，你可能希望对结果索引做一些位移，比如从右边界减去一秒以便更容易明白该时间戳到底表示的是哪个区间。只需通过loffset设置一个字符串或日期偏移量即可实现这个目的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">219</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">   .....:             label=<span class="string">&#x27;right&#x27;</span>, loffset=<span class="string">&#x27;-1s&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">219</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">59</span>    <span class="number">15</span></span><br><span class="line">In [<span class="number">219</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">   .....:             label=<span class="string">&#x27;right&#x27;</span>, loffset=<span class="string">&#x27;-1s&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">219</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">59</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><p>此外，也可以通过调用结果对象的shift方法来实现该目的，这样就不需要设置loffset了。</p><p>##OHLC重采样</p><p>金融领域中有一种无所不在的时间序列聚合方式，即计算各面元的四个值：第一个值（open，开盘）、最后一个值（close，收盘）、最大值（high，最高）以及最小值（low，最低）。传入how&#x3D;’ohlc’即可得到一个含有这四种聚合值的DataFrame。整个过程很高效，只需一次扫描即可计算出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">220</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>).ohlc()</span><br><span class="line">Out[<span class="number">220</span>]: </span><br><span class="line">                     <span class="built_in">open</span>  high  low  close</span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span>     <span class="number">4</span>    <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>     <span class="number">5</span>     <span class="number">9</span>    <span class="number">5</span>      <span class="number">9</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">10</span>    <span class="number">11</span>   <span class="number">10</span>     <span class="number">11</span></span><br></pre></td></tr></table></figure><p>##升采样和插值</p><p>在将数据从低频率转换到高频率时，就不需要聚合了。我们来看一个带有一些周型数据的DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">221</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">   .....:                      index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">2</span>,</span><br><span class="line">   .....:                                          freq=<span class="string">&#x27;W-WED&#x27;</span>),</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: frame</span><br><span class="line">Out[<span class="number">222</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure><p>当你对这个数据进行聚合，每组只有一个值，这样就会引入缺失值。我们使用asfreq方法转换成高频，不经过聚合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">223</span>]: df_daily = frame.resample(<span class="string">&#x27;D&#x27;</span>).asfreq()</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: df_daily</span><br><span class="line">Out[<span class="number">224</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-07       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-08       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-09       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure><p>假设你想要用前面的周型值填充“非星期三”。resampling的填充和插值方式跟fillna和reindex的一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">225</span>]: frame.resample(<span class="string">&#x27;D&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-07 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-08 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-09 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span> -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span> -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure><p>同样，这里也可以只填充指定的时期数（目的是限制前面的观测值的持续使用距离）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">226</span>]: frame.resample(<span class="string">&#x27;D&#x27;</span>).ffill(limit=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">226</span>]:</span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-07 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-08       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-09       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure><p>注意，新的日期索引完全没必要跟旧的重叠：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">227</span>]: frame.resample(<span class="string">&#x27;W-THU&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">13</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure><h2 id="通过时期进行重采样"><a href="#通过时期进行重采样" class="headerlink" title="通过时期进行重采样"></a>通过时期进行重采样</h2><p>对那些使用时期索引的数据进行重采样与时间戳很像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">228</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">24</span>, <span class="number">4</span>),</span><br><span class="line">   .....:                      index=pd.period_range(<span class="string">&#x27;1-2000&#x27;</span>, <span class="string">&#x27;12-2001&#x27;</span>,</span><br><span class="line">   .....:                                            freq=<span class="string">&#x27;M&#x27;</span>),</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">229</span>]: frame[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line">         Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01  <span class="number">0.493841</span> -<span class="number">0.155434</span>  <span class="number">1.397286</span>  <span class="number">1.507055</span></span><br><span class="line"><span class="number">2000</span>-02 -<span class="number">1.179442</span>  <span class="number">0.443171</span>  <span class="number">1.395676</span> -<span class="number">0.529658</span></span><br><span class="line"><span class="number">2000</span>-03  <span class="number">0.787358</span>  <span class="number">0.248845</span>  <span class="number">0.743239</span>  <span class="number">1.267746</span></span><br><span class="line"><span class="number">2000</span>-04  <span class="number">1.302395</span> -<span class="number">0.272154</span> -<span class="number">0.051532</span> -<span class="number">0.467740</span></span><br><span class="line"><span class="number">2000</span>-05 -<span class="number">1.040816</span>  <span class="number">0.426419</span>  <span class="number">0.312945</span> -<span class="number">1.115689</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">230</span>]: annual_frame = frame.resample(<span class="string">&#x27;A-DEC&#x27;</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: annual_frame</span><br><span class="line">Out[<span class="number">231</span>]: </span><br><span class="line">      Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line"><span class="number">2001</span>  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br></pre></td></tr></table></figure><p>升采样要稍微麻烦一些，因为你必须决定在新频率中各区间的哪端用于放置原来的值，就像asfreq方法那样。convention参数默认为’start’，也可设置为’end’：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Q-DEC: Quarterly, year ending in December</span></span><br><span class="line">In [<span class="number">232</span>]: annual_frame.resample(<span class="string">&#x27;Q-DEC&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q2  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q3  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: annual_frame.resample(<span class="string">&#x27;Q-DEC&#x27;</span>, convention=<span class="string">&#x27;end&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">233</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br></pre></td></tr></table></figure><p>由于时期指的是时间区间，所以升采样和降采样的规则就比较严格：</p><ul><li>在降采样中，目标频率必须是源频率的子时期（subperiod）。</li><li>在升采样中，目标频率必须是源频率的超时期（superperiod）。</li></ul><p>如果不满足这些条件，就会引发异常。这主要影响的是按季、年、周计算的频率。例如，由Q-MAR定义的时间区间只能升采样为A-MAR、A-JUN、A-SEP、A-DEC等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">234</span>]: annual_frame.resample(<span class="string">&#x27;Q-MAR&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q1  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q2  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q3  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br></pre></td></tr></table></figure><h1 id="11-7-移动窗口函数"><a href="#11-7-移动窗口函数" class="headerlink" title="11.7 移动窗口函数"></a>11.7 移动窗口函数</h1><p>在移动窗口（可以带有指数衰减权数）上计算的各种统计函数也是一类常见于时间序列的数组变换。这样可以圆滑噪音数据或断裂数据。我将它们称为移动窗口函数（moving window function），其中还包括那些窗口不定长的函数（如指数加权移动平均）。跟其他统计函数一样，移动窗口函数也会自动排除缺失值。</p><p>开始之前，我们加载一些时间序列数据，将其重采样为工作日频率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">235</span>]: close_px_all = pd.read_csv(<span class="string">&#x27;examples/stock_px_2.csv&#x27;</span>,</span><br><span class="line">   .....:                            parse_dates=<span class="literal">True</span>, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">236</span>]: close_px = close_px_all[[<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;XOM&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: close_px = close_px.resample(<span class="string">&#x27;B&#x27;</span>).ffill()</span><br></pre></td></tr></table></figure><p>现在引入rolling运算符，它与resample和groupby很像。可以在TimeSeries或DataFrame以及一个window（表示期数，见图11-4）上调用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">238</span>]: close_px.AAPL.plot()</span><br><span class="line">Out[<span class="number">238</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f2570cf98</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: close_px.AAPL.rolling(<span class="number">250</span>).mean().plot()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-3327483eab730b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-4 苹果公司股价的250日均线"></p><p>表达式rolling(250)与groupby很像，但不是对其进行分组，而是创建一个按照250天分组的滑动窗口对象。然后，我们就得到了苹果公司股价的250天的移动窗口。</p><p>默认情况下，rolling函数需要窗口中所有的值为非NA值。可以修改该行为以解决缺失数据的问题。其实，在时间序列开始处尚不足窗口期的那些数据就是个特例（见图11-5）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">241</span>]: appl_std250 = close_px.AAPL.rolling(<span class="number">250</span>, min_periods=<span class="number">10</span>).std()</span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: appl_std250[<span class="number">5</span>:<span class="number">12</span>]</span><br><span class="line">Out[<span class="number">242</span>]: </span><br><span class="line"><span class="number">2003</span>-01-09         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">10</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">13</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">14</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">15</span>    <span class="number">0.077496</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">16</span>    <span class="number">0.074760</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">17</span>    <span class="number">0.112368</span></span><br><span class="line">Freq: B, Name: AAPL, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: appl_std250.plot()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-15f565bed1ccad09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-5 苹果公司250日每日回报标准差"></p><p>要计算扩展窗口平均（expanding window mean），可以使用expanding而不是rolling。“扩展”意味着，从时间序列的起始处开始窗口，增加窗口直到它超过所有的序列。apple_std250时间序列的扩展窗口平均如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">244</span>]: expanding_mean = appl_std250.expanding().mean()</span><br></pre></td></tr></table></figure><p>对DataFrame调用rolling_mean（以及与之类似的函数）会将转换应用到所有的列上（见图11-6）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">246</span>]: close_px.rolling(<span class="number">60</span>).mean().plot(logy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-979f748052b2279f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-6 各股价60日均线（对数Y轴）"></p><p>rolling函数也可以接受一个指定固定大小时间补偿字符串，而不是一组时期。这样可以方便处理不规律的时间序列。这些字符串也可以传递给resample。例如，我们可以计算20天的滚动均值，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">247</span>]: close_px.rolling(<span class="string">&#x27;20D&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">247</span>]:</span><br><span class="line">                  AAPL       MSFT        XOM</span><br><span class="line"><span class="number">2003</span>-01-02    <span class="number">7.400000</span>  <span class="number">21.110000</span>  <span class="number">29.220000</span></span><br><span class="line"><span class="number">2003</span>-01-03    <span class="number">7.425000</span>  <span class="number">21.125000</span>  <span class="number">29.230000</span></span><br><span class="line"><span class="number">2003</span>-01-06    <span class="number">7.433333</span>  <span class="number">21.256667</span>  <span class="number">29.473333</span></span><br><span class="line"><span class="number">2003</span>-01-07    <span class="number">7.432500</span>  <span class="number">21.425000</span>  <span class="number">29.342500</span></span><br><span class="line"><span class="number">2003</span>-01-08    <span class="number">7.402000</span>  <span class="number">21.402000</span>  <span class="number">29.240000</span></span><br><span class="line"><span class="number">2003</span>-01-09    <span class="number">7.391667</span>  <span class="number">21.490000</span>  <span class="number">29.273333</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">10</span>    <span class="number">7.387143</span>  <span class="number">21.558571</span>  <span class="number">29.238571</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">13</span>    <span class="number">7.378750</span>  <span class="number">21.633750</span>  <span class="number">29.197500</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">14</span>    <span class="number">7.370000</span>  <span class="number">21.717778</span>  <span class="number">29.194444</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">15</span>    <span class="number">7.355000</span>  <span class="number">21.757000</span>  <span class="number">29.152000</span></span><br><span class="line"><span class="meta">... </span>               ...        ...        ...</span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-03  <span class="number">398.002143</span>  <span class="number">25.890714</span>  <span class="number">72.413571</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-04  <span class="number">396.802143</span>  <span class="number">25.807857</span>  <span class="number">72.427143</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-05  <span class="number">395.751429</span>  <span class="number">25.729286</span>  <span class="number">72.422857</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-06  <span class="number">394.099286</span>  <span class="number">25.673571</span>  <span class="number">72.375714</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-07  <span class="number">392.479333</span>  <span class="number">25.712000</span>  <span class="number">72.454667</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">10</span>  <span class="number">389.351429</span>  <span class="number">25.602143</span>  <span class="number">72.527857</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">11</span>  <span class="number">388.505000</span>  <span class="number">25.674286</span>  <span class="number">72.835000</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">12</span>  <span class="number">388.531429</span>  <span class="number">25.810000</span>  <span class="number">73.400714</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span>  <span class="number">388.826429</span>  <span class="number">25.961429</span>  <span class="number">73.905000</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span>  <span class="number">391.038000</span>  <span class="number">26.048667</span>  <span class="number">74.185333</span></span><br><span class="line">[<span class="number">2292</span> rows x <span class="number">3</span> columns]</span><br></pre></td></tr></table></figure><h2 id="指数加权函数"><a href="#指数加权函数" class="headerlink" title="指数加权函数"></a>指数加权函数</h2><p>另一种使用固定大小窗口及相等权数观测值的办法是，定义一个衰减因子（decay factor）常量，以便使近期的观测值拥有更大的权数。衰减因子的定义方式有很多，比较流行的是使用时间间隔（span），它可以使结果兼容于窗口大小等于时间间隔的简单移动窗口（simple moving window）函数。</p><p>由于指数加权统计会赋予近期的观测值更大的权数，因此相对于等权统计，它能“适应”更快的变化。</p><p>除了rolling和expanding，pandas还有ewm运算符。下面这个例子对比了苹果公司股价的30日移动平均和span&#x3D;30的指数加权移动平均（如图11-7所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">249</span>]: aapl_px = close_px.AAPL[<span class="string">&#x27;2006&#x27;</span>:<span class="string">&#x27;2007&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">250</span>]: ma60 = aapl_px.rolling(<span class="number">30</span>, min_periods=<span class="number">20</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">251</span>]: ewma60 = aapl_px.ewm(span=<span class="number">30</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">252</span>]: ma60.plot(style=<span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;Simple MA&#x27;</span>)</span><br><span class="line">Out[<span class="number">252</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f252161d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: ewma60.plot(style=<span class="string">&#x27;k-&#x27;</span>, label=<span class="string">&#x27;EW MA&#x27;</span>)</span><br><span class="line">Out[<span class="number">253</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f252161d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">254</span>]: plt.legend()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-dae48defe3749fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-7 简单移动平均与指数加权移动平均"></p><h2 id="二元移动窗口函数"><a href="#二元移动窗口函数" class="headerlink" title="二元移动窗口函数"></a>二元移动窗口函数</h2><p>有些统计运算（如相关系数和协方差）需要在两个时间序列上执行。例如，金融分析师常常对某只股票对某个参考指数（如标准普尔500指数）的相关系数感兴趣。要进行说明，我们先计算我们感兴趣的时间序列的百分数变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">256</span>]: spx_px = close_px_all[<span class="string">&#x27;SPX&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">257</span>]: spx_rets = spx_px.pct_change()</span><br><span class="line"></span><br><span class="line">In [<span class="number">258</span>]: returns = close_px.pct_change()</span><br></pre></td></tr></table></figure><p>调用rolling之后，corr聚合函数开始计算与spx_rets滚动相关系数（结果见图11-8）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">259</span>]: corr = returns.AAPL.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</span><br><span class="line"></span><br><span class="line">In [<span class="number">260</span>]: corr.plot()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-e81e0f602b4db0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-8 AAPL 6个月的回报与标准普尔500指数的相关系数"></p><p>假设你想要一次性计算多只股票与标准普尔500指数的相关系数。虽然编写一个循环并新建一个DataFrame不是什么难事，但比较啰嗦。其实，只需传入一个TimeSeries和一个DataFrame，rolling_corr就会自动计算TimeSeries（本例中就是spx_rets）与DataFrame各列的相关系数。结果如图11-9所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">262</span>]: corr = returns.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</span><br><span class="line"></span><br><span class="line">In [<span class="number">263</span>]: corr.plot()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-0a54a028a62b9b50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-9 3只股票6个月的回报与标准普尔500指数的相关系数"></p><h2 id="用户定义的移动窗口函数"><a href="#用户定义的移动窗口函数" class="headerlink" title="用户定义的移动窗口函数"></a>用户定义的移动窗口函数</h2><p>rolling_apply函数使你能够在移动窗口上应用自己设计的数组函数。唯一要求的就是：该函数要能从数组的各个片段中产生单个值（即约简）。比如说，当我们用rolling(…).quantile(q)计算样本分位数时，可能对样本中特定值的百分等级感兴趣。scipy.stats.percentileofscore函数就能达到这个目的（结果见图11-10）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">265</span>]: <span class="keyword">from</span> scipy.stats <span class="keyword">import</span> percentileofscore</span><br><span class="line"></span><br><span class="line">In [<span class="number">266</span>]: score_at_2percent = <span class="keyword">lambda</span> x: percentileofscore(x, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">267</span>]: result = returns.AAPL.rolling(<span class="number">250</span>).apply(score_at_2percent)</span><br><span class="line"></span><br><span class="line">In [<span class="number">268</span>]: result.plot()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-af49e84a90c23c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11-10 AAPL 2%回报率的百分等级（一年窗口期）"></p><p>如果你没安装SciPy，可以使用conda或pip安装。</p><h1 id="11-8-总结"><a href="#11-8-总结" class="headerlink" title="11.8 总结"></a>11.8 总结</h1><p>与前面章节接触的数据相比，时间序列数据要求不同类型的分析和数据转换工具。</p><p>在接下来的章节中，我们将学习一些高级的pandas方法和如何开始使用建模库statsmodels和scikit-learn。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E8%BF%90%E7%AE%97/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。</p><p>关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。在本章中你将会看到，由于Python和pandas强大的表达能力，我们可以执行复杂得多的分组运算（利用任何可以接受pandas对象或NumPy数组的函数）。在本章中，你将会学到：</p><ul><li>使用一个或多个键（形式可以是函数、数组或DataFrame列名）分割pandas对象。</li><li>计算分组的概述统计，比如数量、平均值或标准差，或是用户定义的函数。</li><li>应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等。</li><li>计算透视表或交叉表。</li><li>执行分位数分析以及其它统计分组分析。</li></ul><blockquote><p>笔记：对时间序列数据的聚合（groupby的特殊用法之一）也称作重采样（resampling），本书将在第11章中单独对其进行讲解。</p></blockquote><h1 id="10-1-GroupBy机制"><a href="#10-1-GroupBy机制" class="headerlink" title="10.1 GroupBy机制"></a>10.1 GroupBy机制</h1><p>Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语”split-apply-combine”（拆分－应用－合并）。第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis&#x3D;0）或列（axis&#x3D;1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。图10-1大致说明了一个简单的分组聚合过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-e5c671e09ecf94be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图10-1 分组聚合演示"></p><p>分组键可以有多种形式，且类型不必相同：</p><ul><li>列表或数组，其长度与待分组的轴一样。</li><li>表示DataFrame某个列名的值。</li><li>字典或Series，给出待分组轴上的值与分组名之间的对应关系。</li><li>函数，用于处理轴索引或索引中的各个标签。</li></ul><p>注意，后三种都只是快捷方式而已，其最终目的仍然是产生一组用于拆分对象的值。如果觉得这些东西看起来很抽象，不用担心，我将在本章中给出大量有关于此的示例。首先来看看下面这个非常简单的表格型数据集（以DataFrame的形式）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;data1&#x27;</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">   ....:                    <span class="string">&#x27;data2&#x27;</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br></pre></td></tr></table></figure><p>假设你想要按key1进行分组，并计算data1列的平均值。实现该功能的方式有很多，而我们这里要用的是：访问data1，并根据key1调用groupby：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: grouped = df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: grouped</span><br><span class="line">Out[<span class="number">13</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa31537390</span>&gt;</span><br></pre></td></tr></table></figure><p>变量grouped是一个GroupBy对象。它实际上还没有进行任何计算，只是含有一些有关分组键df[‘key1’]的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用GroupBy的mean方法来计算分组平均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">0.746672</span></span><br><span class="line">b   -<span class="number">0.537585</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure><p>稍后我将详细讲解.mean()的调用过程。这里最重要的是，数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df[‘key1’]就叫这个名字。</p><p>如果我们一次传入多个数组的列表，就会得到不同的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: means = df[<span class="string">&#x27;data1&#x27;</span>].groupby([df[<span class="string">&#x27;key1&#x27;</span>], df[<span class="string">&#x27;key2&#x27;</span>]]).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: means</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">0.880536</span></span><br><span class="line">      two     <span class="number">0.478943</span></span><br><span class="line">b     one    -<span class="number">0.519439</span></span><br><span class="line">      two    -<span class="number">0.555730</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure><p>这里，我通过两个键对数据进行了分组，得到的Series具有一个层次化索引（由唯一的键对组成）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: means.unstack()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">key2       one       two</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">0.880536</span>  <span class="number">0.478943</span></span><br><span class="line">b    -<span class="number">0.519439</span> -<span class="number">0.555730</span></span><br></pre></td></tr></table></figure><p>在这个例子中，分组键均为Series。实际上，分组键可以是任何长度适当的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: states = np.array([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: years = np.array([<span class="number">2005</span>, <span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: df[<span class="string">&#x27;data1&#x27;</span>].groupby([states, years]).mean()</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">California  <span class="number">2005</span>    <span class="number">0.478943</span></span><br><span class="line">            <span class="number">2006</span>   -<span class="number">0.519439</span></span><br><span class="line">Ohio        <span class="number">2005</span>   -<span class="number">0.380219</span></span><br><span class="line">            <span class="number">2006</span>    <span class="number">1.965781</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure><p>通常，分组信息就位于相同的要处理DataFrame中。这里，你还可以将列名（可以是字符串、数字或其他Python对象）用作分组键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: df.groupby(<span class="string">&#x27;key1&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.746672</span>  <span class="number">0.910916</span></span><br><span class="line">b    -<span class="number">0.537585</span>  <span class="number">0.525384</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).mean()</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">              data1     data2</span><br><span class="line">key1 key2                    </span><br><span class="line">a    one   <span class="number">0.880536</span>  <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line">b    one  -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line">     two  -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure><p>你可能已经注意到了，第一个例子在执行df.groupby(‘key1’).mean()时，结果中没有key2列。这是因为df[‘key2’]不是数值数据（俗称“麻烦列”），所以被从结果中排除了。默认情况下，所有数值列都会被聚合，虽然有时可能会被过滤为一个子集，稍后就会碰到。</p><p>无论你准备拿groupby做什么，都有可能会用到GroupBy的size方法，它可以返回一个含有分组大小的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).size()</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">2</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">b     one     <span class="number">1</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>注意，任何分组关键词中的缺失值，都会被从结果中除去。</p><h2 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h2><p>GroupBy对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> name, group <span class="keyword">in</span> df.groupby(<span class="string">&#x27;key1&#x27;</span>):</span><br><span class="line">   ....:     <span class="built_in">print</span>(name)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">a</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">b</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure><p>对于多重键的情况，元组的第一个元素将会是由键值组成的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: <span class="keyword">for</span> (k1, k2), group <span class="keyword">in</span> df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]):</span><br><span class="line">   ....:     <span class="built_in">print</span>((k1, k2))</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">     data1     data2 key1 key2</span><br><span class="line"><span class="number">3</span> -<span class="number">0.55573</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure><p>当然，你可以对这些数据片段做任何操作。有一个你可能会觉得有用的运算：将这些数据片段做成一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">26</span>]: pieces = <span class="built_in">dict</span>(<span class="built_in">list</span>(df.groupby(<span class="string">&#x27;key1&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: pieces[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure><p>groupby默认是在axis&#x3D;0上进行分组的，通过设置也可以在其他任何轴上进行分组。拿上面例子中的df来说，我们可以根据dtype对列进行分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: df.dtypes</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">data1    float64</span><br><span class="line">data2    float64</span><br><span class="line">key1      <span class="built_in">object</span></span><br><span class="line">key2      <span class="built_in">object</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: grouped = df.groupby(df.dtypes, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>可以如下打印分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="keyword">for</span> dtype, group <span class="keyword">in</span> grouped:</span><br><span class="line">   ....:     <span class="built_in">print</span>(dtype)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">float64</span><br><span class="line">      data1     data2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span></span><br><span class="line"><span class="built_in">object</span></span><br><span class="line">  key1 key2</span><br><span class="line"><span class="number">0</span>    a  one</span><br><span class="line"><span class="number">1</span>    a  two</span><br><span class="line"><span class="number">2</span>    b  one</span><br><span class="line"><span class="number">3</span>    b  two</span><br><span class="line"><span class="number">4</span>    a  one</span><br></pre></td></tr></table></figure><h2 id="选取一列或列的子集"><a href="#选取一列或列的子集" class="headerlink" title="选取一列或列的子集"></a>选取一列或列的子集</h2><p>对于由DataFrame产生的GroupBy对象，如果用一个（单个字符串）或一组（字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的。也就是说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[<span class="string">&#x27;data1&#x27;</span>]</span><br><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[[<span class="string">&#x27;data2&#x27;</span>]]</span><br></pre></td></tr></table></figure><p>是以下代码的语法糖：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line">df[[<span class="string">&#x27;data2&#x27;</span>]].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br></pre></td></tr></table></figure><p>尤其对于大数据集，很可能只需要对部分列进行聚合。例如，在前面那个数据集中，如果只需计算data2列的平均值并以DataFrame形式得到结果，可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[[<span class="string">&#x27;data2&#x27;</span>]].mean()</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">              data2</span><br><span class="line">key1 key2          </span><br><span class="line">a    one   <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.092908</span></span><br><span class="line">b    one   <span class="number">0.281746</span></span><br><span class="line">     two   <span class="number">0.769023</span></span><br></pre></td></tr></table></figure><p>这种索引操作所返回的对象是一个已分组的DataFrame（如果传入的是列表或数组）或已分组的Series（如果传入的是标量形式的单个列名）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: s_grouped = df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[<span class="string">&#x27;data2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: s_grouped</span><br><span class="line">Out[<span class="number">33</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa30c78da0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: s_grouped.mean()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">1.319920</span></span><br><span class="line">      two     <span class="number">0.092908</span></span><br><span class="line">b     one     <span class="number">0.281746</span></span><br><span class="line">      two     <span class="number">0.769023</span></span><br><span class="line">Name: data2, dtype: float64</span><br></pre></td></tr></table></figure><p>##通过字典或Series进行分组<br>除数组以外，分组信息还可以其他形式存在。来看另一个示例DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Travis&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan <span class="comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: people</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe     <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">Steve   <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line">Wes    -<span class="number">0.539741</span>       NaN       NaN -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">Jim     <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line">Travis -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure><p>现在，假设已知列的分组关系，并希望根据分组计算列的和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: mapping = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">   ....:            <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;f&#x27;</span> : <span class="string">&#x27;orange&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>现在，你可以将这个字典传给groupby，来构造数组，但我们可以直接传递字典（我包含了键“f”来强调，存在未使用的分组键是可以的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: by_column = people.groupby(mapping, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: by_column.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">            blue       red</span><br><span class="line">Joe     <span class="number">0.503905</span>  <span class="number">1.063885</span></span><br><span class="line">Steve   <span class="number">1.297183</span> -<span class="number">1.553778</span></span><br><span class="line">Wes    -<span class="number">1.021228</span> -<span class="number">1.116829</span></span><br><span class="line">Jim     <span class="number">0.524712</span>  <span class="number">1.770545</span></span><br><span class="line">Travis -<span class="number">4.230992</span> -<span class="number">2.405455</span></span><br></pre></td></tr></table></figure><p>Series也有同样的功能，它可以被看做一个固定大小的映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: map_series = pd.Series(mapping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: map_series</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">a       red</span><br><span class="line">b       red</span><br><span class="line">c      blue</span><br><span class="line">d      blue</span><br><span class="line">e       red</span><br><span class="line">f    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: people.groupby(map_series, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">        blue  red</span><br><span class="line">Joe        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Steve      <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Wes        <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">Jim        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Travis     <span class="number">2</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>##通过函数进行分组<br>比起使用字典或Series，使用Python函数是一种更原生的方法定义分组映射。任何被当做分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。具体点说，以上一小节的示例DataFrame为例，其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入len函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: people.groupby(<span class="built_in">len</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">3</span>  <span class="number">0.591569</span> -<span class="number">0.993608</span>  <span class="number">0.798764</span> -<span class="number">0.791374</span>  <span class="number">2.119639</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure><p>将函数跟数组、列表、字典、Series混合使用也不是问题，因为任何东西在内部都会被转换为数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: key_list = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: people.groupby([<span class="built_in">len</span>, key_list]).<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">              a         b         c         d         e</span><br><span class="line"><span class="number">3</span> one -<span class="number">0.539741</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span> -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">  two  <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">5</span> one  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> two -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure><h2 id="根据索引级别分组"><a href="#根据索引级别分组" class="headerlink" title="根据索引级别分组"></a>根据索引级别分组</h2><p>层次化索引数据集最方便的地方就在于它能够根据轴索引的一个级别进行聚合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">47</span>]: columns = pd.MultiIndex.from_arrays([[<span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>],</span><br><span class="line">   ....:                                     [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]],</span><br><span class="line">   ....:                                     names=[<span class="string">&#x27;cty&#x27;</span>, <span class="string">&#x27;tenor&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: hier_df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">5</span>), columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: hier_df</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">cty          US                            JP          </span><br><span class="line">tenor         <span class="number">1</span>         <span class="number">3</span>         <span class="number">5</span>         <span class="number">1</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0.560145</span> -<span class="number">1.265934</span>  <span class="number">0.119827</span> -<span class="number">1.063512</span>  <span class="number">0.332883</span></span><br><span class="line"><span class="number">1</span>     -<span class="number">2.359419</span> -<span class="number">0.199543</span> -<span class="number">1.541996</span> -<span class="number">0.970736</span> -<span class="number">1.307030</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0.286350</span>  <span class="number">0.377984</span> -<span class="number">0.753887</span>  <span class="number">0.331286</span>  <span class="number">1.349742</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0.069877</span>  <span class="number">0.246674</span> -<span class="number">0.011862</span>  <span class="number">1.004812</span>  <span class="number">1.327195</span></span><br></pre></td></tr></table></figure><p>要根据级别分组，使用level关键字传递级别序号或名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: hier_df.groupby(level=<span class="string">&#x27;cty&#x27;</span>, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">cty  JP  US</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="10-2-数据聚合"><a href="#10-2-数据聚合" class="headerlink" title="10.2 数据聚合"></a>10.2 数据聚合</h1><p>聚合指的是任何能够从数组产生标量值的数据转换过程。之前的例子已经用过一些，比如mean、count、min以及sum等。你可能想知道在GroupBy对象上调用mean()时究竟发生了什么。许多常见的聚合运算（如表10-1所示）都有进行优化。然而，除了这些方法，你还可以使用其它的。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-ba8de524e08b1b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表10-1 经过优化的groupby方法"></p><p>你可以使用自己发明的聚合运算，还可以调用分组对象上已经定义好的任何方法。例如，quantile可以计算Series或DataFrame列的样本分位数。</p><p>虽然quantile并没有明确地实现于GroupBy，但它是一个Series方法，所以这里是能用的。实际上，GroupBy会高效地对Series进行切片，然后对各片调用piece.quantile(0.9)，最后将这些结果组装成最终结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: df</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: grouped = df.groupby(<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: grouped[<span class="string">&#x27;data1&#x27;</span>].quantile(<span class="number">0.9</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">1.668413</span></span><br><span class="line">b   -<span class="number">0.523068</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure><p>如果要使用你自己的聚合函数，只需将其传入aggregate或agg方法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="keyword">def</span> <span class="title function_">peak_to_peak</span>(<span class="params">arr</span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> arr.<span class="built_in">max</span>() - arr.<span class="built_in">min</span>()</span><br><span class="line">In [<span class="number">55</span>]: grouped.agg(peak_to_peak)</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">2.170488</span>  <span class="number">1.300498</span></span><br><span class="line">b     <span class="number">0.036292</span>  <span class="number">0.487276</span></span><br></pre></td></tr></table></figure><p>你可能注意到注意，有些方法（如describe）也是可以用在这里的，即使严格来讲，它们并非聚合运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: grouped.describe()</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">     data1                                                              \</span><br><span class="line">     count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a      <span class="number">3.0</span>  <span class="number">0.746672</span>  <span class="number">1.109736</span> -<span class="number">0.204708</span>  <span class="number">0.137118</span>  <span class="number">0.478943</span>  <span class="number">1.222362</span>   </span><br><span class="line">b      <span class="number">2.0</span> -<span class="number">0.537585</span>  <span class="number">0.025662</span> -<span class="number">0.555730</span> -<span class="number">0.546657</span> -<span class="number">0.537585</span> -<span class="number">0.528512</span>   </span><br><span class="line">               data2                                                    \</span><br><span class="line"><span class="built_in">max</span> count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a     <span class="number">1.965781</span>   <span class="number">3.0</span>  <span class="number">0.910916</span>  <span class="number">0.712217</span>  <span class="number">0.092908</span>  <span class="number">0.669671</span>  <span class="number">1.246435</span>   </span><br><span class="line">b    -<span class="number">0.519439</span>   <span class="number">2.0</span>  <span class="number">0.525384</span>  <span class="number">0.344556</span>  <span class="number">0.281746</span>  <span class="number">0.403565</span>  <span class="number">0.525384</span>   </span><br><span class="line">                          </span><br><span class="line">           <span class="number">75</span>%       <span class="built_in">max</span>  </span><br><span class="line">key1                      </span><br><span class="line">a     <span class="number">1.319920</span>  <span class="number">1.393406</span>  </span><br><span class="line">b     <span class="number">0.647203</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure><p>在后面的10.3节，我将详细说明这到底是怎么回事。</p><blockquote><p>笔记：自定义聚合函数要比表10-1中那些经过优化的函数慢得多。这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。</p></blockquote><h2 id="面向列的多函数应用"><a href="#面向列的多函数应用" class="headerlink" title="面向列的多函数应用"></a>面向列的多函数应用</h2><p>回到前面小费的例子。使用read_csv导入数据之后，我们添加了一个小费百分比的列tip_pct：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">57</span>]: tips = pd.read_csv(<span class="string">&#x27;examples/tips.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add tip percentage of total bill</span></span><br><span class="line">In [<span class="number">58</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>] = tips[<span class="string">&#x27;tip&#x27;</span>] / tips[<span class="string">&#x27;total_bill&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: tips[:<span class="number">6</span>]</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">0</span>       <span class="number">16.99</span>  <span class="number">1.01</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.059447</span></span><br><span class="line"><span class="number">1</span>       <span class="number">10.34</span>  <span class="number">1.66</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.160542</span></span><br><span class="line"><span class="number">2</span>       <span class="number">21.01</span>  <span class="number">3.50</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.166587</span></span><br><span class="line"><span class="number">3</span>       <span class="number">23.68</span>  <span class="number">3.31</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.139780</span></span><br><span class="line"><span class="number">4</span>       <span class="number">24.59</span>  <span class="number">3.61</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.146808</span></span><br><span class="line"><span class="number">5</span>       <span class="number">25.29</span>  <span class="number">4.71</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.186240</span></span><br></pre></td></tr></table></figure><p>你已经看到，对Series或DataFrame列的聚合运算其实就是使用aggregate（使用自定义函数）或调用诸如mean、std之类的方法。然而，你可能希望对不同的列使用不同的聚合函数，或一次应用多个函数。其实这也好办，我将通过一些示例来进行讲解。首先，我根据天和smoker对tips进行分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">60</span>]: grouped = tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br></pre></td></tr></table></figure><p>注意，对于表10-1中的那些描述统计，可以将函数名以字符串的形式传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">61</span>]: grouped_pct = grouped[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: grouped_pct.agg(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">day   smoker</span><br><span class="line">Fri   No        <span class="number">0.151650</span></span><br><span class="line">      Yes       <span class="number">0.174783</span></span><br><span class="line">Sat   No        <span class="number">0.158048</span></span><br><span class="line">      Yes       <span class="number">0.147906</span></span><br><span class="line">Sun   No        <span class="number">0.160113</span></span><br><span class="line">      Yes       <span class="number">0.187250</span></span><br><span class="line">Thur  No        <span class="number">0.160298</span></span><br><span class="line">      Yes       <span class="number">0.163863</span></span><br><span class="line">Name: tip_pct, dtype: float64</span><br></pre></td></tr></table></figure><p>如果传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: grouped_pct.agg([<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>, peak_to_peak])</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">                 mean       std  peak_to_peak</span><br><span class="line">day  smoker                                  </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span>      <span class="number">0.067349</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span>      <span class="number">0.159925</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span>      <span class="number">0.235193</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span>      <span class="number">0.290095</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span>      <span class="number">0.193226</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span>      <span class="number">0.644685</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span>      <span class="number">0.193350</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span>      <span class="number">0.151240</span></span><br></pre></td></tr></table></figure><p>这里，我们传递了一组聚合函数进行聚合，独立对数据分组进行评估。</p><p>你并非一定要接受GroupBy自动给出的那些列名，特别是lambda函数，它们的名称是’<lambda>‘，这样的辨识度就很低了（通过函数的__name__属性看看就知道了）。因此，如果传入的是一个由(name,function)元组组成的列表，则各元组的第一个元素就会被用作DataFrame的列名（可以将这种二元元组列表看做一个有序映射）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">64</span>]: grouped_pct.agg([(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, np.std)])</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">                  foo       bar</span><br><span class="line">day  smoker                    </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span></span><br></pre></td></tr></table></figure><p>对于DataFrame，你还有更多选择，你可以定义一组应用于全部列的一组函数，或不同的列应用不同的函数。假设我们想要对tip_pct和total_bill列计算三个统计信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">65</span>]: functions = [<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: result = grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(functions)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: result</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">            tip_pct                     total_bill                  </span><br><span class="line">              count      mean       <span class="built_in">max</span>      count       mean    <span class="built_in">max</span></span><br><span class="line">day  smoker                                                         </span><br><span class="line">Fri  No           <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span>          <span class="number">4</span>  <span class="number">18.420000</span>  <span class="number">22.75</span></span><br><span class="line">     Yes         <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span>         <span class="number">15</span>  <span class="number">16.813333</span>  <span class="number">40.17</span></span><br><span class="line">Sat  No          <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span>         <span class="number">45</span>  <span class="number">19.661778</span>  <span class="number">48.33</span></span><br><span class="line">     Yes         <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span>         <span class="number">42</span>  <span class="number">21.276667</span>  <span class="number">50.81</span></span><br><span class="line">Sun  No          <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span>         <span class="number">57</span>  <span class="number">20.506667</span>  <span class="number">48.17</span></span><br><span class="line">     Yes         <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span>         <span class="number">19</span>  <span class="number">24.120000</span>  <span class="number">45.35</span></span><br><span class="line">Thur No          <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span>         <span class="number">45</span>  <span class="number">17.113111</span>  <span class="number">41.19</span></span><br><span class="line">     Yes         <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span>         <span class="number">17</span>  <span class="number">19.190588</span>  <span class="number">43.11</span></span><br></pre></td></tr></table></figure><p>如你所见，结果DataFrame拥有层次化的列，这相当于分别对各列进行聚合，然后用concat将结果组装到一起，使用列名用作keys参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: result[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">             count      mean       <span class="built_in">max</span></span><br><span class="line">day  smoker                           </span><br><span class="line">Fri  No          <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span></span><br><span class="line">     Yes        <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span></span><br><span class="line">Sat  No         <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span></span><br><span class="line">     Yes        <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span></span><br><span class="line">Sun  No         <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span></span><br><span class="line">     Yes        <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span></span><br><span class="line">Thur No         <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span></span><br><span class="line">     Yes        <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span></span><br></pre></td></tr></table></figure><p>跟前面一样，这里也可以传入带有自定义名称的一组元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: ftuples = [(<span class="string">&#x27;Durchschnitt&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>),(<span class="string">&#x27;Abweichung&#x27;</span>, np.var)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(ftuples)</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">                 tip_pct              total_bill            </span><br><span class="line">            Durchschnitt Abweichung Durchschnitt  Abweichung</span><br><span class="line">day  smoker                                                 </span><br><span class="line">Fri  No         <span class="number">0.151650</span>   <span class="number">0.000791</span>    <span class="number">18.420000</span>   <span class="number">25.596333</span></span><br><span class="line">     Yes        <span class="number">0.174783</span>   <span class="number">0.002631</span>    <span class="number">16.813333</span>   <span class="number">82.562438</span></span><br><span class="line">Sat  No         <span class="number">0.158048</span>   <span class="number">0.001581</span>    <span class="number">19.661778</span>   <span class="number">79.908965</span></span><br><span class="line">     Yes        <span class="number">0.147906</span>   <span class="number">0.003767</span>    <span class="number">21.276667</span>  <span class="number">101.387535</span></span><br><span class="line">Sun  No         <span class="number">0.160113</span>   <span class="number">0.001793</span>    <span class="number">20.506667</span>   <span class="number">66.099980</span></span><br><span class="line">     Yes        <span class="number">0.187250</span>   <span class="number">0.023757</span>    <span class="number">24.120000</span>  <span class="number">109.046044</span></span><br><span class="line">Thur No         <span class="number">0.160298</span>   <span class="number">0.001503</span>    <span class="number">17.113111</span>   <span class="number">59.625081</span></span><br><span class="line">     Yes        <span class="number">0.163863</span>   <span class="number">0.001551</span>    <span class="number">19.190588</span>   <span class="number">69.808518</span></span><br></pre></td></tr></table></figure><p>现在，假设你想要对一个列或不同的列应用不同的函数。具体的办法是向agg传入一个从列名映射到函数的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">71</span>]: grouped.agg(&#123;<span class="string">&#x27;tip&#x27;</span> : np.<span class="built_in">max</span>, <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">               tip  size</span><br><span class="line">day  smoker             </span><br><span class="line">Fri  No       <span class="number">3.50</span>     <span class="number">9</span></span><br><span class="line">     Yes      <span class="number">4.73</span>    <span class="number">31</span></span><br><span class="line">Sat  No       <span class="number">9.00</span>   <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">10.00</span>   <span class="number">104</span></span><br><span class="line">Sun  No       <span class="number">6.00</span>   <span class="number">167</span></span><br><span class="line">     Yes      <span class="number">6.50</span>    <span class="number">49</span></span><br><span class="line">Thur No       <span class="number">6.70</span>   <span class="number">112</span></span><br><span class="line">     Yes      <span class="number">5.00</span>    <span class="number">40</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: grouped.agg(&#123;<span class="string">&#x27;tip_pct&#x27;</span> : [<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>],</span><br><span class="line">   ....:              <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">              tip_pct                               size</span><br><span class="line">                  <span class="built_in">min</span>       <span class="built_in">max</span>      mean       std  <span class="built_in">sum</span></span><br><span class="line">day  smoker                                             </span><br><span class="line">Fri  No      <span class="number">0.120385</span>  <span class="number">0.187735</span>  <span class="number">0.151650</span>  <span class="number">0.028123</span>    <span class="number">9</span></span><br><span class="line">     Yes     <span class="number">0.103555</span>  <span class="number">0.263480</span>  <span class="number">0.174783</span>  <span class="number">0.051293</span>   <span class="number">31</span></span><br><span class="line">Sat  No      <span class="number">0.056797</span>  <span class="number">0.291990</span>  <span class="number">0.158048</span>  <span class="number">0.039767</span>  <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">0.035638</span>  <span class="number">0.325733</span>  <span class="number">0.147906</span>  <span class="number">0.061375</span>  <span class="number">104</span></span><br><span class="line">Sun  No      <span class="number">0.059447</span>  <span class="number">0.252672</span>  <span class="number">0.160113</span>  <span class="number">0.042347</span>  <span class="number">167</span></span><br><span class="line">     Yes     <span class="number">0.065660</span>  <span class="number">0.710345</span>  <span class="number">0.187250</span>  <span class="number">0.154134</span>   <span class="number">49</span></span><br><span class="line">Thur No      <span class="number">0.072961</span>  <span class="number">0.266312</span>  <span class="number">0.160298</span>  <span class="number">0.038774</span>  <span class="number">112</span></span><br><span class="line">     Yes     <span class="number">0.090014</span>  <span class="number">0.241255</span>  <span class="number">0.163863</span>  <span class="number">0.039389</span>   <span class="number">40</span></span><br></pre></td></tr></table></figure><p>只有将多个函数应用到至少一列时，DataFrame才会拥有层次化的列。</p><h2 id="以“没有行索引”的形式返回聚合数据"><a href="#以“没有行索引”的形式返回聚合数据" class="headerlink" title="以“没有行索引”的形式返回聚合数据"></a>以“没有行索引”的形式返回聚合数据</h2><p>到目前为止，所有示例中的聚合数据都有由唯一的分组键组成的索引（可能还是层次化的）。由于并不总是需要如此，所以你可以向groupby传入as_index&#x3D;False以禁用该功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], as_index=<span class="literal">False</span>).mean()</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">    day smoker  total_bill       tip      size   tip_pct</span><br><span class="line"><span class="number">0</span>   Fri     No   <span class="number">18.420000</span>  <span class="number">2.812500</span>  <span class="number">2.250000</span>  <span class="number">0.151650</span></span><br><span class="line"><span class="number">1</span>   Fri    Yes   <span class="number">16.813333</span>  <span class="number">2.714000</span>  <span class="number">2.066667</span>  <span class="number">0.174783</span></span><br><span class="line"><span class="number">2</span>   Sat     No   <span class="number">19.661778</span>  <span class="number">3.102889</span>  <span class="number">2.555556</span>  <span class="number">0.158048</span></span><br><span class="line"><span class="number">3</span>   Sat    Yes   <span class="number">21.276667</span>  <span class="number">2.875476</span>  <span class="number">2.476190</span>  <span class="number">0.147906</span></span><br><span class="line"><span class="number">4</span>   Sun     No   <span class="number">20.506667</span>  <span class="number">3.167895</span>  <span class="number">2.929825</span>  <span class="number">0.160113</span></span><br><span class="line"><span class="number">5</span>   Sun    Yes   <span class="number">24.120000</span>  <span class="number">3.516842</span>  <span class="number">2.578947</span>  <span class="number">0.187250</span></span><br><span class="line"><span class="number">6</span>  Thur     No   <span class="number">17.113111</span>  <span class="number">2.673778</span>  <span class="number">2.488889</span>  <span class="number">0.160298</span></span><br><span class="line"><span class="number">7</span>  Thur    Yes   <span class="number">19.190588</span>  <span class="number">3.030000</span>  <span class="number">2.352941</span>  <span class="number">0.163863</span></span><br></pre></td></tr></table></figure><p>当然，对结果调用reset_index也能得到这种形式的结果。使用as_index&#x3D;False方法可以避免一些不必要的计算。</p><h1 id="10-3-apply：一般性的“拆分－应用－合并”"><a href="#10-3-apply：一般性的“拆分－应用－合并”" class="headerlink" title="10.3 apply：一般性的“拆分－应用－合并”"></a>10.3 apply：一般性的“拆分－应用－合并”</h1><p>最通用的GroupBy方法是apply，本节剩余部分将重点讲解它。如图10-2所示，apply会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-7e8bb217f599b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图10-2 分组聚合示例"></p><p>回到之前那个小费数据集，假设你想要根据分组选出最高的5个tip_pct值。首先，编写一个选取指定列具有最大值的行的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">df, n=<span class="number">5</span>, column=<span class="string">&#x27;tip_pct&#x27;</span></span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> df.sort_values(by=column)[-n:]</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: top(tips, n=<span class="number">6</span>)</span><br><span class="line">Out[<span class="number">75</span>]: </span><br><span class="line">     total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes  Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes  Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No  Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes  Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure><p>现在，如果对smoker分组并用该函数调用apply，就会得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">76</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>).apply(top)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">            total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker                                                           </span><br><span class="line">No     <span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line">       <span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line">       <span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line">       <span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line">       <span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line">Yes    <span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line">       <span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line">       <span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line">       <span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line">       <span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure><p>这里发生了什么？top函数在DataFrame的各个片段上调用，然后结果由pandas.concat组装到一起，并以分组名称进行了标记。于是，最终结果就有了一个层次化索引，其内层索引值来自原DataFrame。</p><p>如果传给apply的函数能够接受其他参数或关键字，则可以将这些内容放在函数名后面一并传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">77</span>]: tips.groupby([<span class="string">&#x27;smoker&#x27;</span>, <span class="string">&#x27;day&#x27;</span>]).apply(top, n=<span class="number">1</span>, column=<span class="string">&#x27;total_bill&#x27;</span>)</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">                 total_bill    tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker day                                                             </span><br><span class="line">No     Fri  <span class="number">94</span>        <span class="number">22.75</span>   <span class="number">3.25</span>     No   Fri  Dinner     <span class="number">2</span>  <span class="number">0.142857</span></span><br><span class="line">       Sat  <span class="number">212</span>       <span class="number">48.33</span>   <span class="number">9.00</span>     No   Sat  Dinner     <span class="number">4</span>  <span class="number">0.186220</span></span><br><span class="line">       Sun  <span class="number">156</span>       <span class="number">48.17</span>   <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">6</span>  <span class="number">0.103799</span></span><br><span class="line">       Thur <span class="number">142</span>       <span class="number">41.19</span>   <span class="number">5.00</span>     No  Thur   Lunch     <span class="number">5</span>  <span class="number">0.121389</span></span><br><span class="line">Yes    Fri  <span class="number">95</span>        <span class="number">40.17</span>   <span class="number">4.73</span>    Yes   Fri  Dinner     <span class="number">4</span>  <span class="number">0.117750</span></span><br><span class="line">       Sat  <span class="number">170</span>       <span class="number">50.81</span>  <span class="number">10.00</span>    Yes   Sat  Dinner     <span class="number">3</span>  <span class="number">0.196812</span></span><br><span class="line">       Sun  <span class="number">182</span>       <span class="number">45.35</span>   <span class="number">3.50</span>    Yes   Sun  Dinner     <span class="number">3</span>  <span class="number">0.077178</span></span><br><span class="line">       Thur <span class="number">197</span>       <span class="number">43.11</span>   <span class="number">5.00</span>    Yes  Thur   Lunch     <span class="number">4</span>  <span class="number">0.115982</span></span><br></pre></td></tr></table></figure><blockquote><p>笔记：除这些基本用法之外，能否充分发挥apply的威力很大程度上取决于你的创造力。传入的那个函数能做什么全由你说了算，它只需返回一个pandas对象或标量值即可。本章后续部分的示例主要用于讲解如何利用groupby解决各种各样的问题。</p></blockquote><p>可能你已经想起来了，之前我在GroupBy对象上调用过describe：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">78</span>]: result = tips.groupby(<span class="string">&#x27;smoker&#x27;</span>)[<span class="string">&#x27;tip_pct&#x27;</span>].describe()</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: result</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">        count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%  \</span><br><span class="line">smoker                                                                      </span><br><span class="line">No      <span class="number">151.0</span>  <span class="number">0.159328</span>  <span class="number">0.039910</span>  <span class="number">0.056797</span>  <span class="number">0.136906</span>  <span class="number">0.155625</span>  <span class="number">0.185014</span>   </span><br><span class="line">Yes      <span class="number">93.0</span>  <span class="number">0.163196</span>  <span class="number">0.085119</span>  <span class="number">0.035638</span>  <span class="number">0.106771</span>  <span class="number">0.153846</span>  <span class="number">0.195059</span>   </span><br><span class="line">             <span class="built_in">max</span>  </span><br><span class="line">smoker</span><br><span class="line"></span><br><span class="line">No      <span class="number">0.291990</span>  </span><br><span class="line">Yes     <span class="number">0.710345</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: result.unstack(<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">       smoker</span><br><span class="line">count  No        <span class="number">151.000000</span></span><br><span class="line">       Yes        <span class="number">93.000000</span></span><br><span class="line">mean   No          <span class="number">0.159328</span></span><br><span class="line">       Yes         <span class="number">0.163196</span></span><br><span class="line">std    No          <span class="number">0.039910</span></span><br><span class="line">       Yes         <span class="number">0.085119</span></span><br><span class="line"><span class="built_in">min</span>    No          <span class="number">0.056797</span></span><br><span class="line">       Yes         <span class="number">0.035638</span></span><br><span class="line"><span class="number">25</span>%    No          <span class="number">0.136906</span></span><br><span class="line">       Yes         <span class="number">0.106771</span></span><br><span class="line"><span class="number">50</span>%    No          <span class="number">0.155625</span></span><br><span class="line">       Yes         <span class="number">0.153846</span></span><br><span class="line"><span class="number">75</span>%    No          <span class="number">0.185014</span></span><br><span class="line">       Yes         <span class="number">0.195059</span></span><br><span class="line"><span class="built_in">max</span>    No          <span class="number">0.291990</span></span><br><span class="line">       Yes         <span class="number">0.710345</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>在GroupBy中，当你调用诸如describe之类的方法时，实际上只是应用了下面两条代码的快捷方式而已：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x.describe()</span><br><span class="line">grouped.apply(f)</span><br></pre></td></tr></table></figure><h2 id="禁止分组键"><a href="#禁止分组键" class="headerlink" title="禁止分组键"></a>禁止分组键</h2><p>从上面的例子中可以看出，分组键会跟原始对象的索引共同构成结果对象中的层次化索引。将group_keys&#x3D;False传入groupby即可禁止该效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">81</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>, group_keys=<span class="literal">False</span>).apply(top)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">     total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line"><span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line"><span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line"><span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line"><span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure><h2 id="分位数和桶分析"><a href="#分位数和桶分析" class="headerlink" title="分位数和桶分析"></a>分位数和桶分析</h2><p>我曾在第8章中讲过，pandas有一些能根据指定面元或样本分位数将数据拆分成多块的工具（比如cut和qcut）。将这些函数跟groupby结合起来，就能非常轻松地实现对数据集的桶（bucket）或分位数（quantile）分析了。以下面这个简单的随机数据集为例，我们利用cut将其装入长度相等的桶中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">82</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;data1&#x27;</span>: np.random.randn(<span class="number">1000</span>),</span><br><span class="line">   ....:                       <span class="string">&#x27;data2&#x27;</span>: np.random.randn(<span class="number">1000</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: quartiles = pd.cut(frame.data1, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: quartiles[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line"><span class="number">0</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">1</span>    (-<span class="number">2.956</span>, -<span class="number">1.23</span>]</span><br><span class="line"><span class="number">2</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">3</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">4</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">5</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">6</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">7</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">8</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">9</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line">Name: data1, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.956</span>, -<span class="number">1.23</span>] &lt; (-<span class="number">1.23</span>, <span class="number">0.489</span>] &lt; (<span class="number">0.489</span>, <span class="number">2.</span></span><br><span class="line"><span class="number">208</span>] &lt; (<span class="number">2.208</span>, <span class="number">3.928</span>]]</span><br></pre></td></tr></table></figure><p>由cut返回的Categorical对象可直接传递到groupby。因此，我们可以像下面这样对data2列做一些统计计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">85</span>]: <span class="keyword">def</span> <span class="title function_">get_stats</span>(<span class="params">group</span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> &#123;<span class="string">&#x27;min&#x27;</span>: group.<span class="built_in">min</span>(), <span class="string">&#x27;max&#x27;</span>: group.<span class="built_in">max</span>(),</span><br><span class="line">   ....:             <span class="string">&#x27;count&#x27;</span>: group.count(), <span class="string">&#x27;mean&#x27;</span>: group.mean()&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: grouped = frame.data2.groupby(quartiles)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">87</span>]: </span><br><span class="line">                 count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                               </span><br><span class="line">(-<span class="number">2.956</span>, -<span class="number">1.23</span>]   <span class="number">95.0</span>  <span class="number">1.670835</span> -<span class="number">0.039521</span> -<span class="number">3.399312</span></span><br><span class="line">(-<span class="number">1.23</span>, <span class="number">0.489</span>]   <span class="number">598.0</span>  <span class="number">3.260383</span> -<span class="number">0.002051</span> -<span class="number">2.989741</span></span><br><span class="line">(<span class="number">0.489</span>, <span class="number">2.208</span>]   <span class="number">297.0</span>  <span class="number">2.954439</span>  <span class="number">0.081822</span> -<span class="number">3.745356</span></span><br><span class="line">(<span class="number">2.208</span>, <span class="number">3.928</span>]    <span class="number">10.0</span>  <span class="number">1.765640</span>  <span class="number">0.024750</span> -<span class="number">1.929776</span></span><br></pre></td></tr></table></figure><p>这些都是长度相等的桶。要根据样本分位数得到大小相等的桶，使用qcut即可。传入labels&#x3D;False即可只获取分位数的编号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Return quantile numbers</span></span><br><span class="line">In [<span class="number">88</span>]: grouping = pd.qcut(frame.data1, <span class="number">10</span>, labels=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: grouped = frame.data2.groupby(grouping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">       count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                     </span><br><span class="line"><span class="number">0</span>      <span class="number">100.0</span>  <span class="number">1.670835</span> -<span class="number">0.049902</span> -<span class="number">3.399312</span></span><br><span class="line"><span class="number">1</span>      <span class="number">100.0</span>  <span class="number">2.628441</span>  <span class="number">0.030989</span> -<span class="number">1.950098</span></span><br><span class="line"><span class="number">2</span>      <span class="number">100.0</span>  <span class="number">2.527939</span> -<span class="number">0.067179</span> -<span class="number">2.925113</span></span><br><span class="line"><span class="number">3</span>      <span class="number">100.0</span>  <span class="number">3.260383</span>  <span class="number">0.065713</span> -<span class="number">2.315555</span></span><br><span class="line"><span class="number">4</span>      <span class="number">100.0</span>  <span class="number">2.074345</span> -<span class="number">0.111653</span> -<span class="number">2.047939</span></span><br><span class="line"><span class="number">5</span>      <span class="number">100.0</span>  <span class="number">2.184810</span>  <span class="number">0.052130</span> -<span class="number">2.989741</span></span><br><span class="line"><span class="number">6</span>      <span class="number">100.0</span>  <span class="number">2.458842</span> -<span class="number">0.021489</span> -<span class="number">2.223506</span></span><br><span class="line"><span class="number">7</span>      <span class="number">100.0</span>  <span class="number">2.954439</span> -<span class="number">0.026459</span> -<span class="number">3.056990</span></span><br><span class="line"><span class="number">8</span>      <span class="number">100.0</span>  <span class="number">2.735527</span>  <span class="number">0.103406</span> -<span class="number">3.745356</span></span><br><span class="line"><span class="number">9</span>      <span class="number">100.0</span>  <span class="number">2.377020</span>  <span class="number">0.220122</span> -<span class="number">2.064111</span></span><br></pre></td></tr></table></figure><p>我们会在第12章详细讲解pandas的Categorical类型。</p><h2 id="示例：用特定于分组的值填充缺失值"><a href="#示例：用特定于分组的值填充缺失值" class="headerlink" title="示例：用特定于分组的值填充缺失值"></a>示例：用特定于分组的值填充缺失值</h2><p>对于缺失数据的清理工作，有时你会用dropna将其替换掉，而有时则可能会希望用一个固定值或由数据集本身所衍生出来的值去填充NA值。这时就得使用fillna这个工具了。在下面这个例子中，我用平均值去填充NA值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">91</span>]: s = pd.Series(np.random.randn(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: s[::<span class="number">2</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: s</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line"><span class="number">0</span>         NaN</span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>         NaN</span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>         NaN</span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: s.fillna(s.mean())</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">0</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。下面是一些有关美国几个州的示例数据，这些州又被分为东部和西部：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">95</span>]: states = [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line">   ....:           <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: group_key = [<span class="string">&#x27;East&#x27;</span>] * <span class="number">4</span> + [<span class="string">&#x27;West&#x27;</span>] * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: data = pd.Series(np.random.randn(<span class="number">8</span>), index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: data</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.365757</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.981994</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.613716</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>[‘East’] * 4产生了一个列表，包括了[‘East’]中元素的四个拷贝。将这些列表串联起来。</p><p>将一些值设为缺失：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">99</span>]: data[[<span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: data</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont            NaN</span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada             NaN</span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho              NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data.groupby(group_key).mean()</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">East   -<span class="number">0.535707</span></span><br><span class="line">West    <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>我们可以用分组平均值去填充NA值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">102</span>]: fill_mean = <span class="keyword">lambda</span> g: g.fillna(g.mean())</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: data.groupby(group_key).apply(fill_mean)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.535707</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.717926</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho         <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>另外，也可以在代码中预定义各组的填充值。由于分组具有一个name属性，所以我们可以拿来用一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">104</span>]: fill_values = &#123;<span class="string">&#x27;East&#x27;</span>: <span class="number">0.5</span>, <span class="string">&#x27;West&#x27;</span>: -<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: fill_func = <span class="keyword">lambda</span> g: g.fillna(fill_values[g.name])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: data.groupby(group_key).apply(fill_func)</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont       <span class="number">0.500000</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada       -<span class="number">1.000000</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h2 id="示例：随机采样和排列"><a href="#示例：随机采样和排列" class="headerlink" title="示例：随机采样和排列"></a>示例：随机采样和排列</h2><p>假设你想要从一个大数据集中随机抽取（进行替换或不替换）样本以进行蒙特卡罗模拟（Monte Carlo simulation）或其他分析工作。“抽取”的方式有很多，这里使用的方法是对Series使用sample方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hearts, Spades, Clubs, Diamonds</span></span><br><span class="line">suits = [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">card_val = (<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)) + [<span class="number">10</span>] * <span class="number">3</span>) * <span class="number">4</span></span><br><span class="line">base_names = [<span class="string">&#x27;A&#x27;</span>] + <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)) + [<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>]</span><br><span class="line">cards = []</span><br><span class="line"><span class="keyword">for</span> suit <span class="keyword">in</span> [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]:</span><br><span class="line">    cards.extend(<span class="built_in">str</span>(num) + suit <span class="keyword">for</span> num <span class="keyword">in</span> base_names)</span><br><span class="line"></span><br><span class="line">deck = pd.Series(card_val, index=cards)</span><br></pre></td></tr></table></figure><p>现在我有了一个长度为52的Series，其索引包括牌名，值则是21点或其他游戏中用于计分的点数（为了简单起见，我当A的点数为1）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">108</span>]: deck[:<span class="number">13</span>]</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">AH      <span class="number">1</span></span><br><span class="line">2H      <span class="number">2</span></span><br><span class="line">3H      <span class="number">3</span></span><br><span class="line">4H      <span class="number">4</span></span><br><span class="line">5H      <span class="number">5</span></span><br><span class="line">6H      <span class="number">6</span></span><br><span class="line">7H      <span class="number">7</span></span><br><span class="line">8H      <span class="number">8</span></span><br><span class="line">9H      <span class="number">9</span></span><br><span class="line">10H    <span class="number">10</span></span><br><span class="line">JH     <span class="number">10</span></span><br><span class="line">KH     <span class="number">10</span></span><br><span class="line">QH     <span class="number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>现在，根据我上面所讲的，从整副牌中抽出5张，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">109</span>]: <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">deck, n=<span class="number">5</span></span>):</span><br><span class="line">   .....:     <span class="keyword">return</span> deck.sample(n)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: draw(deck)</span><br><span class="line">Out[<span class="number">110</span>]: </span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">8C     <span class="number">8</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">2C     <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>假设你想要从每种花色中随机抽取两张牌。由于花色是牌名的最后一个字符，所以我们可以据此进行分组，并使用apply：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">111</span>]: get_suit = <span class="keyword">lambda</span> card: card[-<span class="number">1</span>] <span class="comment"># last letter is suit</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: deck.groupby(get_suit).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">C  2C     <span class="number">2</span></span><br><span class="line">   3C     <span class="number">3</span></span><br><span class="line">D  KD    <span class="number">10</span></span><br><span class="line">   8D     <span class="number">8</span></span><br><span class="line">H  KH    <span class="number">10</span></span><br><span class="line">   3H     <span class="number">3</span></span><br><span class="line">S  2S     <span class="number">2</span></span><br><span class="line">   4S     <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>或者，也可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">113</span>]: deck.groupby(get_suit, group_keys=<span class="literal">False</span>).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">JC    <span class="number">10</span></span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">5D     <span class="number">5</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">6H     <span class="number">6</span></span><br><span class="line">7S     <span class="number">7</span></span><br><span class="line">KS    <span class="number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h2 id="示例：分组加权平均数和相关系数"><a href="#示例：分组加权平均数和相关系数" class="headerlink" title="示例：分组加权平均数和相关系数"></a>示例：分组加权平均数和相关系数</h2><p>根据groupby的“拆分－应用－合并”范式，可以进行DataFrame的列与列之间或两个Series之间的运算（比如分组加权平均）。以下面这个数据集为例，它含有分组键、值以及一些权重值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">114</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;category&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">   .....:                                 <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;data&#x27;</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">   .....:                    <span class="string">&#x27;weights&#x27;</span>: np.random.rand(<span class="number">8</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: df</span><br><span class="line">Out[<span class="number">115</span>]: </span><br><span class="line">  category      data   weights</span><br><span class="line"><span class="number">0</span>        a  <span class="number">1.561587</span>  <span class="number">0.957515</span></span><br><span class="line"><span class="number">1</span>        a  <span class="number">1.219984</span>  <span class="number">0.347267</span></span><br><span class="line"><span class="number">2</span>        a -<span class="number">0.482239</span>  <span class="number">0.581362</span></span><br><span class="line"><span class="number">3</span>        a  <span class="number">0.315667</span>  <span class="number">0.217091</span></span><br><span class="line"><span class="number">4</span>        b -<span class="number">0.047852</span>  <span class="number">0.894406</span></span><br><span class="line"><span class="number">5</span>        b -<span class="number">0.454145</span>  <span class="number">0.918564</span></span><br><span class="line"><span class="number">6</span>        b -<span class="number">0.556774</span>  <span class="number">0.277825</span></span><br><span class="line"><span class="number">7</span>        b  <span class="number">0.253321</span>  <span class="number">0.955905</span></span><br></pre></td></tr></table></figure><p>然后可以利用category计算分组加权平均数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">116</span>]: grouped = df.groupby(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: get_wavg = <span class="keyword">lambda</span> g: np.average(g[<span class="string">&#x27;data&#x27;</span>], weights=g[<span class="string">&#x27;weights&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: grouped.apply(get_wavg)</span><br><span class="line">Out[<span class="number">118</span>]:</span><br><span class="line">category</span><br><span class="line">a    <span class="number">0.811643</span></span><br><span class="line">b   -<span class="number">0.122262</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>另一个例子，考虑一个来自Yahoo!Finance的数据集，其中含有几只股票和标准普尔500指数（符号SPX）的收盘价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">119</span>]: close_px = pd.read_csv(<span class="string">&#x27;examples/stock_px_2.csv&#x27;</span>, parse_dates=<span class="literal">True</span>,</span><br><span class="line">   .....:                        index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: close_px.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">DatetimeIndex: <span class="number">2214</span> entries, <span class="number">2003</span>-01-02 to <span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">AAPL    <span class="number">2214</span> non-null float64</span><br><span class="line">MSFT    <span class="number">2214</span> non-null float64</span><br><span class="line">XOM     <span class="number">2214</span> non-null float64</span><br><span class="line">SPX     <span class="number">2214</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">86.5</span> KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: close_px[-<span class="number">4</span>:]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">              AAPL   MSFT    XOM      SPX</span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">11</span>  <span class="number">400.29</span>  <span class="number">27.00</span>  <span class="number">76.27</span>  <span class="number">1195.54</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">12</span>  <span class="number">402.19</span>  <span class="number">26.96</span>  <span class="number">77.16</span>  <span class="number">1207.25</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span>  <span class="number">408.43</span>  <span class="number">27.18</span>  <span class="number">76.37</span>  <span class="number">1203.66</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span>  <span class="number">422.00</span>  <span class="number">27.27</span>  <span class="number">78.11</span>  <span class="number">1224.58</span></span><br></pre></td></tr></table></figure><p>来做一个比较有趣的任务：计算一个由日收益率（通过百分数变化计算）与SPX之间的年度相关系数组成的DataFrame。下面是一个实现办法，我们先创建一个函数，用它计算每列和SPX列的成对相关系数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">122</span>]: spx_corr = <span class="keyword">lambda</span> x: x.corrwith(x[<span class="string">&#x27;SPX&#x27;</span>])</span><br></pre></td></tr></table></figure><p>接下来，我们使用pct_change计算close_px的百分比变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">123</span>]: rets = close_px.pct_change().dropna()</span><br></pre></td></tr></table></figure><p>最后，我们用年对百分比变化进行分组，可以用一个一行的函数，从每行的标签返回每个datetime标签的year属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">124</span>]: get_year = <span class="keyword">lambda</span> x: x.year</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: by_year = rets.groupby(get_year)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: by_year.apply(spx_corr)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line">          AAPL      MSFT       XOM  SPX</span><br><span class="line"><span class="number">2003</span>  <span class="number">0.541124</span>  <span class="number">0.745174</span>  <span class="number">0.661265</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">0.374283</span>  <span class="number">0.588531</span>  <span class="number">0.557742</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">0.467540</span>  <span class="number">0.562374</span>  <span class="number">0.631010</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">0.428267</span>  <span class="number">0.406126</span>  <span class="number">0.518514</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">0.508118</span>  <span class="number">0.658770</span>  <span class="number">0.786264</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.681434</span>  <span class="number">0.804626</span>  <span class="number">0.828303</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.707103</span>  <span class="number">0.654902</span>  <span class="number">0.797921</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">0.710105</span>  <span class="number">0.730118</span>  <span class="number">0.839057</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.691931</span>  <span class="number">0.800996</span>  <span class="number">0.859975</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>当然，你还可以计算列与列之间的相关系数。这里，我们计算Apple和Microsoft的年相关系数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">127</span>]: by_year.apply(<span class="keyword">lambda</span> g: g[<span class="string">&#x27;AAPL&#x27;</span>].corr(g[<span class="string">&#x27;MSFT&#x27;</span>]))</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line"><span class="number">2003</span>    <span class="number">0.480868</span></span><br><span class="line"><span class="number">2004</span>    <span class="number">0.259024</span></span><br><span class="line"><span class="number">2005</span>    <span class="number">0.300093</span></span><br><span class="line"><span class="number">2006</span>    <span class="number">0.161735</span></span><br><span class="line"><span class="number">2007</span>    <span class="number">0.417738</span></span><br><span class="line"><span class="number">2008</span>    <span class="number">0.611901</span></span><br><span class="line"><span class="number">2009</span>    <span class="number">0.432738</span></span><br><span class="line"><span class="number">2010</span>    <span class="number">0.571946</span></span><br><span class="line"><span class="number">2011</span>    <span class="number">0.581987</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h2 id="示例：组级别的线性回归"><a href="#示例：组级别的线性回归" class="headerlink" title="示例：组级别的线性回归"></a>示例：组级别的线性回归</h2><p>顺着上一个例子继续，你可以用groupby执行更为复杂的分组统计分析，只要函数返回的是pandas对象或标量值即可。例如，我可以定义下面这个regress函数（利用statsmodels计量经济学库）对各数据块执行普通最小二乘法（Ordinary Least Squares，OLS）回归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regress</span>(<span class="params">data, yvar, xvars</span>):</span><br><span class="line">    Y = data[yvar]</span><br><span class="line">    X = data[xvars]</span><br><span class="line">    X[<span class="string">&#x27;intercept&#x27;</span>] = <span class="number">1.</span></span><br><span class="line">    result = sm.OLS(Y, X).fit()</span><br><span class="line">    <span class="keyword">return</span> result.params</span><br></pre></td></tr></table></figure><p>现在，为了按年计算AAPL对SPX收益率的线性回归，执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">129</span>]: by_year.apply(regress, <span class="string">&#x27;AAPL&#x27;</span>, [<span class="string">&#x27;SPX&#x27;</span>])</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">           SPX  intercept</span><br><span class="line"><span class="number">2003</span>  <span class="number">1.195406</span>   <span class="number">0.000710</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">1.363463</span>   <span class="number">0.004201</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">1.766415</span>   <span class="number">0.003246</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">1.645496</span>   <span class="number">0.000080</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">1.198761</span>   <span class="number">0.003438</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.968016</span>  -<span class="number">0.001110</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.879103</span>   <span class="number">0.002954</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">1.052608</span>   <span class="number">0.001261</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.806605</span>   <span class="number">0.001514</span></span><br></pre></td></tr></table></figure><h1 id="10-4-透视表和交叉表"><a href="#10-4-透视表和交叉表" class="headerlink" title="10.4 透视表和交叉表"></a>10.4 透视表和交叉表</h1><p>透视表（pivot table）是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）重塑运算制作透视表。DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除能为groupby提供便利之外，pivot_table还可以添加分项小计，也叫做margins。</p><p>回到小费数据集，假设我想要根据day和smoker计算分组平均数（pivot_table的默认聚合类型），并将day和smoker放到行上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">130</span>]: tips.pivot_table(index=[<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">                 size       tip   tip_pct  total_bill</span><br><span class="line">day  smoker                                          </span><br><span class="line">Fri  No      <span class="number">2.250000</span>  <span class="number">2.812500</span>  <span class="number">0.151650</span>   <span class="number">18.420000</span></span><br><span class="line">     Yes     <span class="number">2.066667</span>  <span class="number">2.714000</span>  <span class="number">0.174783</span>   <span class="number">16.813333</span></span><br><span class="line">Sat  No      <span class="number">2.555556</span>  <span class="number">3.102889</span>  <span class="number">0.158048</span>   <span class="number">19.661778</span></span><br><span class="line">     Yes     <span class="number">2.476190</span>  <span class="number">2.875476</span>  <span class="number">0.147906</span>   <span class="number">21.276667</span></span><br><span class="line">Sun  No      <span class="number">2.929825</span>  <span class="number">3.167895</span>  <span class="number">0.160113</span>   <span class="number">20.506667</span></span><br><span class="line">     Yes     <span class="number">2.578947</span>  <span class="number">3.516842</span>  <span class="number">0.187250</span>   <span class="number">24.120000</span></span><br><span class="line">Thur No      <span class="number">2.488889</span>  <span class="number">2.673778</span>  <span class="number">0.160298</span>   <span class="number">17.113111</span></span><br><span class="line">     Yes     <span class="number">2.352941</span>  <span class="number">3.030000</span>  <span class="number">0.163863</span>   <span class="number">19.190588</span></span><br></pre></td></tr></table></figure><p>可以用groupby直接来做。现在，假设我们只想聚合tip_pct和size，而且想根据time进行分组。我将smoker放到列上，把day放到行上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">131</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">                 size             tip_pct          </span><br><span class="line">smoker             No       Yes        No       Yes</span><br><span class="line">time   day                                         </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">0.159744</span>       NaN</span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span></span><br></pre></td></tr></table></figure><p>还可以对这个表作进一步的处理，传入margins&#x3D;True添加分项小计。这将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">132</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">                 size                       tip_pct                    </span><br><span class="line">smoker             No       Yes       All        No       Yes       All</span><br><span class="line">time   day                                                             </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">2.166667</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span>  <span class="number">0.158916</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">2.517241</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span>  <span class="number">0.153152</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">2.842105</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span>  <span class="number">0.166897</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">2.000000</span>  <span class="number">0.159744</span>       NaN  <span class="number">0.159744</span></span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">2.000000</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span>  <span class="number">0.188765</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">2.459016</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span>  <span class="number">0.161301</span></span><br><span class="line">All          <span class="number">2.668874</span>  <span class="number">2.408602</span>  <span class="number">2.569672</span>  <span class="number">0.159328</span>  <span class="number">0.163196</span>  <span class="number">0.160803</span></span><br></pre></td></tr></table></figure><p>这里，All值为平均数：不单独考虑烟民与非烟民（All列），不单独考虑行分组两个级别中的任何单项（All行）。</p><p>要使用其他的聚合函数，将其传给aggfunc即可。例如，使用count或len可以得到有关分组大小的交叉表（计数或频率）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">133</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], columns=<span class="string">&#x27;day&#x27;</span>,</span><br><span class="line">   .....:                  aggfunc=<span class="built_in">len</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">day             Fri   Sat   Sun  Thur    All</span><br><span class="line">time   smoker                               </span><br><span class="line">Dinner No       <span class="number">3.0</span>  <span class="number">45.0</span>  <span class="number">57.0</span>   <span class="number">1.0</span>  <span class="number">106.0</span></span><br><span class="line">       Yes      <span class="number">9.0</span>  <span class="number">42.0</span>  <span class="number">19.0</span>   NaN   <span class="number">70.0</span></span><br><span class="line">Lunch  No       <span class="number">1.0</span>   NaN   NaN  <span class="number">44.0</span>   <span class="number">45.0</span></span><br><span class="line">       Yes      <span class="number">6.0</span>   NaN   NaN  <span class="number">17.0</span>   <span class="number">23.0</span></span><br><span class="line">All            <span class="number">19.0</span>  <span class="number">87.0</span>  <span class="number">76.0</span>  <span class="number">62.0</span>  <span class="number">244.0</span></span><br></pre></td></tr></table></figure><p>如果存在空的组合（也就是NA），你可能会希望设置一个fill_value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">134</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;day&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">day                      Fri       Sat       Sun      Thur</span><br><span class="line">time   size smoker                                        </span><br><span class="line">Dinner <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.137931</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.325733</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.139622</span>  <span class="number">0.162705</span>  <span class="number">0.168859</span>  <span class="number">0.159744</span></span><br><span class="line">            Yes     <span class="number">0.171297</span>  <span class="number">0.148668</span>  <span class="number">0.207893</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.000000</span>  <span class="number">0.154661</span>  <span class="number">0.152663</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.144995</span>  <span class="number">0.152660</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.150096</span>  <span class="number">0.148143</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.117750</span>  <span class="number">0.124515</span>  <span class="number">0.193370</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.206928</span>  <span class="number">0.000000</span></span><br><span class="line">Yes     <span class="number">0.000000</span>  <span class="number">0.106572</span>  <span class="number">0.065660</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="meta">... </span>                     ...       ...       ...       ...</span><br><span class="line">Lunch  <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.181728</span></span><br><span class="line">            Yes     <span class="number">0.223776</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.166005</span></span><br><span class="line">            Yes     <span class="number">0.181969</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.158843</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.187735</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.084246</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.204952</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.138919</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.155410</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.121389</span></span><br><span class="line">       <span class="number">6</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.173706</span></span><br><span class="line">[<span class="number">21</span> rows x <span class="number">4</span> columns]</span><br></pre></td></tr></table></figure><p>pivot_table的参数说明请参见表10-2。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-c9e01844c4803a42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表10-2 pivot_table的选项"></p><h2 id="交叉表：crosstab"><a href="#交叉表：crosstab" class="headerlink" title="交叉表：crosstab"></a>交叉表：crosstab</h2><p>交叉表（cross-tabulation，简称crosstab）是一种用于计算分组频率的特殊透视表。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data</span><br><span class="line">Out[<span class="number">138</span>]:</span><br><span class="line">   Sample Nationality    Handedness</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>         USA  Right-handed</span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       Japan   Left-handed</span><br><span class="line"><span class="number">2</span>       <span class="number">3</span>         USA  Right-handed</span><br><span class="line"><span class="number">3</span>       <span class="number">4</span>       Japan  Right-handed</span><br><span class="line"><span class="number">4</span>       <span class="number">5</span>       Japan   Left-handed</span><br><span class="line"><span class="number">5</span>       <span class="number">6</span>       Japan  Right-handed</span><br><span class="line"><span class="number">6</span>       <span class="number">7</span>         USA  Right-handed</span><br><span class="line"><span class="number">7</span>       <span class="number">8</span>         USA   Left-handed</span><br><span class="line"><span class="number">8</span>       <span class="number">9</span>       Japan  Right-handed</span><br><span class="line"><span class="number">9</span>      <span class="number">10</span>         USA  Right-handed</span><br></pre></td></tr></table></figure><p>作为调查分析的一部分，我们可能想要根据国籍和用手习惯对这段数据进行统计汇总。虽然可以用pivot_table实现该功能，但是pandas.crosstab函数会更方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">139</span>]: pd.crosstab(data.Nationality, data.Handedness, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">Handedness   Left-handed  Right-handed  All</span><br><span class="line">Nationality</span><br><span class="line">Japan                  <span class="number">2</span>             <span class="number">3</span>    <span class="number">5</span></span><br><span class="line">USA                    <span class="number">1</span>             <span class="number">4</span>    <span class="number">5</span></span><br><span class="line">All                    <span class="number">3</span>             <span class="number">7</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure><p>crosstab的前两个参数可以是数组或Series，或是数组列表。就像小费数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">140</span>]: pd.crosstab([tips.time, tips.day], tips.smoker, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">smoker        No  Yes  All</span><br><span class="line">time   day                </span><br><span class="line">Dinner Fri     <span class="number">3</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line">       Sat    <span class="number">45</span>   <span class="number">42</span>   <span class="number">87</span></span><br><span class="line">       Sun    <span class="number">57</span>   <span class="number">19</span>   <span class="number">76</span></span><br><span class="line">       Thur    <span class="number">1</span>    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">Lunch  Fri     <span class="number">1</span>    <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">       Thur   <span class="number">44</span>   <span class="number">17</span>   <span class="number">61</span></span><br><span class="line">All          <span class="number">151</span>   <span class="number">93</span>  <span class="number">244</span></span><br></pre></td></tr></table></figure><h1 id="10-5-总结"><a href="#10-5-总结" class="headerlink" title="10.5 总结"></a>10.5 总结</h1><p>掌握pandas数据分组工具既有助于数据清理，也有助于建模或统计分析工作。在第14章，我们会看几个例子，对真实数据使用groupby。</p><p>在下一章，我们将关注时间序列数据。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC09%E7%AB%A0%20%E7%BB%98%E5%9B%BE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC09%E7%AB%A0%20%E7%BB%98%E5%9B%BE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>信息可视化（也叫绘图）是数据分析中最重要的工作之一。它可能是探索过程的一部分，例如，帮助我们找出异常值、必要的数据转换、得出有关模型的idea等。另外，做一个可交互的数据可视化也许是工作的最终目标。Python有许多库进行静态或动态的数据可视化，但我这里重要关注于matplotlib（<a href="http://matplotlib.org/%EF%BC%89%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%AE%83%E7%9A%84%E5%BA%93%E3%80%82">http://matplotlib.org/）和基于它的库。</a></p><p>matplotlib是一个用于创建出版质量图表的桌面绘图包（主要是2D方面）。该项目是由John Hunter于2002年启动的，其目的是为Python构建一个MATLAB式的绘图接口。matplotlib和IPython社区进行合作，简化了从IPython shell（包括现在的Jupyter notebook）进行交互式绘图。matplotlib支持各种操作系统上许多不同的GUI后端，而且还能将图片导出为各种常见的矢量（vector）和光栅（raster）图：PDF、SVG、JPG、PNG、BMP、GIF等。除了几张，本书中的大部分图都是用它生成的。</p><p>随着时间的发展，matplotlib衍生出了多个数据可视化的工具集，它们使用matplotlib作为底层。其中之一是seaborn（<a href="http://seaborn.pydata.org/%EF%BC%89%EF%BC%8C%E6%9C%AC%E7%AB%A0%E5%90%8E%E9%9D%A2%E4%BC%9A%E5%AD%A6%E4%B9%A0%E5%AE%83%E3%80%82">http://seaborn.pydata.org/），本章后面会学习它。</a></p><p>学习本章代码案例的最简单方法是在Jupyter notebook进行交互式绘图。在Jupyter notebook中执行下面的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib notebook</span><br></pre></td></tr></table></figure><h1 id="9-1-matplotlib-API入门"><a href="#9-1-matplotlib-API入门" class="headerlink" title="9.1 matplotlib API入门"></a>9.1 matplotlib API入门</h1><p> matplotlib的通常引入约定是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>在Jupyter中运行%matplotlib notebook（或在IPython中运行%matplotlib），就可以创建一个简单的图形。如果一切设置正确，会看到图9-1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data</span><br><span class="line">Out[<span class="number">14</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: plt.plot(data)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-7032e333a6ecdd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-1 简单的线图"></p><p>虽然seaborn这样的库和pandas的内置绘图函数能够处理许多普通的绘图任务，但如果需要自定义一些高级功能的话就必须学习matplotlib API。</p><blockquote><p>笔记：虽然本书没有详细地讨论matplotlib的各种功能，但足以将你引入门。matplotlib的示例库和文档是学习高级特性的最好资源。</p></blockquote><h2 id="Figure和Subplot"><a href="#Figure和Subplot" class="headerlink" title="Figure和Subplot"></a>Figure和Subplot</h2><p>matplotlib的图像都位于Figure对象中。你可以用plt.figure创建一个新的Figure：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: fig = plt.figure()</span><br></pre></td></tr></table></figure><p>如果用的是IPython，这时会弹出一个空窗口，但在Jupyter中，必须再输入更多命令才能看到。plt.figure有一些选项，特别是figsize，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。</p><p>不能通过空Figure绘图。必须用add_subplot创建一个或多个subplot才行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这条代码的意思是：图像应该是2×2的（即最多4张图），且当前选中的是4个subplot中的第一个（编号从1开始）。如果再把后面两个subplot也创建出来，最终得到的图像如图9-2所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-b8cff158e64eae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-2 带有三个subplot的Figure"></p><blockquote><p>提示：使用Jupyter notebook有一点不同，即每个小窗重新执行后，图形会被重置。因此，对于复杂的图形，，你必须将所有的绘图命令存在一个小窗里。</p></blockquote><p>这里，我们运行同一个小窗里的所有命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果这时执行一条绘图命令（如plt.plot([1.5, 3.5, -2, 1.6])），matplotlib就会在最后一个用过的subplot（如果没有则创建一个）上进行绘制，隐藏创建figure和subplot的过程。因此，如果我们执行下列命令，你就会得到如图9-3所示的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: plt.plot(np.random.randn(<span class="number">50</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-7bcbd5e56fdbbd92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-3 绘制一次之后的图像"></p><p>“k–”是一个线型选项，用于告诉matplotlib绘制黑色虚线图。上面那些由fig.add_subplot所返回的对象是AxesSubplot对象，直接调用它们的实例方法就可以在其它空着的格子里面画图了，如图9-4所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: ax1.hist(np.random.randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: ax2.scatter(np.arange(<span class="number">30</span>), np.arange(<span class="number">30</span>) + <span class="number">3</span> * np.random.randn(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-2297bcaf355db24c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-4 继续绘制两次之后的图像"></p><p>你可以在matplotlib的文档中找到各种图表类型。</p><p>创建包含subplot网格的figure是一个非常常见的任务，matplotlib有一个更为方便的方法plt.subplots，它可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: axes</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">array([[&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb626374048</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb62625db00</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6262f6c88</span>&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6261a36a0</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb626181860</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6260fd4e0</span>&gt;]], dtype</span><br><span class="line">=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>这是非常实用的，因为可以轻松地对axes数组进行索引，就好像是一个二维数组一样，例如axes[0,1]。你还可以通过sharex和sharey指定subplot应该具有相同的X轴或Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib会自动缩放各图表的界限。有关该方法的更多信息，请参见表9-1。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-88bb55faca7d01ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-1 pyplot.subplots的选项"></p><h2 id="调整subplot周围的间距"><a href="#调整subplot周围的间距" class="headerlink" title="调整subplot周围的间距"></a>调整subplot周围的间距</h2><p>默认情况下，matplotlib会在subplot外围留下一定的边距，并在subplot之间留下一定的间距。间距跟图像的高度和宽度有关，因此，如果你调整了图像大小（不管是编程还是手工），间距也会自动调整。利用Figure的subplots_adjust方法可以轻而易举地修改间距，此外，它也是个顶级函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subplots_adjust(left=<span class="literal">None</span>, bottom=<span class="literal">None</span>, right=<span class="literal">None</span>, top=<span class="literal">None</span>,</span><br><span class="line">                wspace=<span class="literal">None</span>, hspace=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>wspace和hspace用于控制宽度和高度的百分比，可以用作subplot之间的间距。下面是一个简单的例子，其中我将间距收缩到了0（如图9-5所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        axes[i, j].hist(np.random.randn(<span class="number">500</span>), bins=<span class="number">50</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0</span>, hspace=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-80be7ffc3dec88a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-5 各subplot之间没有间距"></p><p>不难看出，其中的轴标签重叠了。matplotlib不会检查标签是否重叠，所以对于这种情况，你只能自己设定刻度位置和刻度标签。后面几节将会详细介绍该内容。</p><h2 id="颜色、标记和线型"><a href="#颜色、标记和线型" class="headerlink" title="颜色、标记和线型"></a>颜色、标记和线型</h2><p>matplotlib的plot函数接受一组X和Y坐标，还可以接受一个表示颜色和线型的字符串缩写。例如，要根据x和y绘制绿色虚线，你可以执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.plot(x, y, <span class="string">&#x27;g--&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这种在一个字符串中指定颜色和线型的方式非常方便。在实际中，如果你是用代码绘图，你可能不想通过处理字符串来获得想要的格式。通过下面这种更为明确的方式也能得到同样的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.plot(x, y, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><p>常用的颜色可以使用颜色缩写，你也可以指定颜色码（例如，’#CECECE’）。你可以通过查看plot的文档字符串查看所有线型的合集（在IPython和Jupyter中使用plot?）。</p><p>线图可以使用标记强调数据点。因为matplotlib可以创建连续线图，在点之间进行插值，因此有时可能不太容易看出真实数据点的位置。标记也可以放到格式字符串中，但标记类型和线型必须放在颜色后面（见图9-6）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: plt.plot(randn(<span class="number">30</span>).cumsum(), <span class="string">&#x27;ko--&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-404d816f3e1d6621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-6 带有标记的线型图示例"></p><p>还可以将其写成更为明确的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(randn(<span class="number">30</span>).cumsum(), color=<span class="string">&#x27;k&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在线型图中，非实际数据点默认是按线性方式插值的。可以通过drawstyle选项修改（见图9-7）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: data = np.random.randn(<span class="number">30</span>).cumsum()</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: plt.plot(data, <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;Default&#x27;</span>)</span><br><span class="line">Out[<span class="number">34</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624d86160</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: plt.plot(data, <span class="string">&#x27;k-&#x27;</span>, drawstyle=<span class="string">&#x27;steps-post&#x27;</span>, label=<span class="string">&#x27;steps-post&#x27;</span>)</span><br><span class="line">Out[<span class="number">35</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624d869e8</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-3ec7642e1a592f08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-7 不同drawstyle选项的线型图"></p><p>你可能注意到运行上面代码时有输出&lt;matplotlib.lines.Line2D at …&gt;。matplotlib会返回引用了新添加的子组件的对象。大多数时候，你可以放心地忽略这些输出。这里，因为我们传递了label参数到plot，我们可以创建一个plot图例，指明每条使用plt.legend的线。</p><blockquote><p>笔记：你必须调用plt.legend（或使用ax.legend，如果引用了轴的话）来创建图例，无论你绘图时是否传递label标签选项。</p></blockquote><h2 id="刻度、标签和图例"><a href="#刻度、标签和图例" class="headerlink" title="刻度、标签和图例"></a>刻度、标签和图例</h2><p>对于大多数的图表装饰项，其主要实现方式有二：使用过程型的pyplot接口（例如，matplotlib.pyplot）以及更为面向对象的原生matplotlib API。</p><p>pyplot接口的设计目的就是交互式使用，含有诸如xlim、xticks和xticklabels之类的方法。它们分别控制图表的范围、刻度位置、刻度标签等。其使用方式有以下两种：</p><ul><li>调用时不带参数，则返回当前的参数值（例如，plt.xlim()返回当前的X轴绘图范围）。</li><li>调用时带参数，则设置参数值（例如，plt.xlim([0,10])会将X轴的范围设置为0到10）。</li></ul><p>所有这些方法都是对当前或最近创建的AxesSubplot起作用的。它们各自对应subplot对象上的两个方法，以xlim为例，就是ax.get_xlim和ax.set_xlim。我更喜欢使用subplot的实例方法（因为我喜欢明确的事情，而且在处理多个subplot时这样也更清楚一些）。当然你完全可以选择自己觉得方便的那个。</p><h2 id="设置标题、轴标签、刻度以及刻度标签"><a href="#设置标题、轴标签、刻度以及刻度标签" class="headerlink" title="设置标题、轴标签、刻度以及刻度标签"></a>设置标题、轴标签、刻度以及刻度标签</h2><p>为了说明自定义轴，我将创建一个简单的图像并绘制一段随机漫步（如图9-8所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: fig = plt.figure()</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: ax.plot(np.random.randn(<span class="number">1000</span>).cumsum())</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-caf9300dacb61fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-8 用于演示xticks的简单线型图（带有标签）"></p><p>要改变x轴刻度，最简单的办法是使用set_xticks和set_xticklabels。前者告诉matplotlib要将刻度放在数据范围中的哪些位置，默认情况下，这些位置也就是刻度标签。但我们可以通过set_xticklabels将任何其他的值用作标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: labels = ax.set_xticklabels([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>],</span><br><span class="line">   ....:                             rotation=<span class="number">30</span>, fontsize=<span class="string">&#x27;small&#x27;</span>)</span><br></pre></td></tr></table></figure><p>rotation选项设定x刻度标签倾斜30度。最后，再用set_xlabel为X轴设置一个名称，并用set_title设置一个标题（见图9-9的结果）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">42</span>]: ax.set_title(<span class="string">&#x27;My first matplotlib plot&#x27;</span>)</span><br><span class="line">Out[<span class="number">42</span>]: &lt;matplotlib.text.Text at <span class="number">0x7fb624d055f8</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: ax.set_xlabel(<span class="string">&#x27;Stages&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-741f968323bd818f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-9 用于演示xticks的简单线型图"></p><p>Y轴的修改方式与此类似，只需将上述代码中的x替换为y即可。轴的类有集合方法，可以批量设定绘图选项。前面的例子，也可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props = &#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;My first matplotlib plot&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xlabel&#x27;</span>: <span class="string">&#x27;Stages&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ax.<span class="built_in">set</span>(**props)</span><br></pre></td></tr></table></figure><h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><p>图例（legend）是另一种用于标识图表元素的重要工具。添加图例的方式有多种。最简单的是在添加subplot的时候传入label参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: <span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k&#x27;</span>, label=<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">Out[<span class="number">46</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624bdf860</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">Out[<span class="number">47</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624be90f0</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k.&#x27;</span>, label=<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line">Out[<span class="number">48</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624be9160</span>&gt;]</span><br></pre></td></tr></table></figure><p>在此之后，你可以调用ax.legend()或plt.legend()来自动创建图例（结果见图9-10）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">49</span>]: ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-651ff89750c0a89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-10 带有三条线以及图例的简单线型图"></p><p>legend方法有几个其它的loc位置参数选项。请查看文档字符串（使用ax.legend?）。</p><p>loc告诉matplotlib要将图例放在哪。如果你不是吹毛求疵的话，”best”是不错的选择，因为它会选择最不碍事的位置。要从图例中去除一个或多个元素，不传入label或传入label&#x3D;’<em>nolegend</em>‘即可。（中文第一版这里把best错写成了beat）</p><h2 id="注解以及在Subplot上绘图"><a href="#注解以及在Subplot上绘图" class="headerlink" title="注解以及在Subplot上绘图"></a>注解以及在Subplot上绘图</h2><p>除标准的绘图类型，你可能还希望绘制一些子集的注解，可能是文本、箭头或其他图形等。注解和文字可以通过text、arrow和annotate函数进行添加。text可以将文本绘制在图表的指定坐标(x,y)，还可以加上一些自定义格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.text(x, y, <span class="string">&#x27;Hello world!&#x27;</span>,</span><br><span class="line">        family=<span class="string">&#x27;monospace&#x27;</span>, fontsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>注解中可以既含有文本也含有箭头。例如，我们根据最近的标准普尔500指数价格（来自Yahoo!Finance）绘制一张曲线图，并标出2008年到2009年金融危机期间的一些重要日期。你可以在Jupyter notebook的一个小窗中试验这段代码（图9-11是结果）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;examples/spx.csv&#x27;</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">spx = data[<span class="string">&#x27;SPX&#x27;</span>]</span><br><span class="line"></span><br><span class="line">spx.plot(ax=ax, style=<span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">crisis_data = [</span><br><span class="line">    (datetime(<span class="number">2007</span>, <span class="number">10</span>, <span class="number">11</span>), <span class="string">&#x27;Peak of bull market&#x27;</span>),</span><br><span class="line">    (datetime(<span class="number">2008</span>, <span class="number">3</span>, <span class="number">12</span>), <span class="string">&#x27;Bear Stearns Fails&#x27;</span>),</span><br><span class="line">    (datetime(<span class="number">2008</span>, <span class="number">9</span>, <span class="number">15</span>), <span class="string">&#x27;Lehman Bankruptcy&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date, label <span class="keyword">in</span> crisis_data:</span><br><span class="line">    ax.annotate(label, xy=(date, spx.asof(date) + <span class="number">75</span>),</span><br><span class="line">                xytext=(date, spx.asof(date) + <span class="number">225</span>),</span><br><span class="line">                arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, headwidth=<span class="number">4</span>, width=<span class="number">2</span>,</span><br><span class="line">                                headlength=<span class="number">4</span>),</span><br><span class="line">                horizontalalignment=<span class="string">&#x27;left&#x27;</span>, verticalalignment=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Zoom in on 2007-2010</span></span><br><span class="line">ax.set_xlim([<span class="string">&#x27;1/1/2007&#x27;</span>, <span class="string">&#x27;1/1/2011&#x27;</span>])</span><br><span class="line">ax.set_ylim([<span class="number">600</span>, <span class="number">1800</span>])</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&#x27;Important dates in the 2008-2009 financial crisis&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-3127eaa51f5e4c2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-11 2008-2009年金融危机期间的重要日期"></p><p>这张图中有几个重要的点要强调：ax.annotate方法可以在指定的x和y坐标轴绘制标签。我们使用set_xlim和set_ylim人工设定起始和结束边界，而不使用matplotlib的默认方法。最后，用ax.set_title添加图标标题。</p><p>更多有关注解的示例，请访问matplotlib的在线示例库。</p><p>图形的绘制要麻烦一些。matplotlib有一些表示常见图形的对象。这些对象被称为块（patch）。其中有些（如Rectangle和Circle），可以在matplotlib.pyplot中找到，但完整集合位于matplotlib.patches。</p><p>要在图表中添加一个图形，你需要创建一个块对象shp，然后通过ax.add_patch(shp)将其添加到subplot中（如图9-12所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rect = plt.Rectangle((<span class="number">0.2</span>, <span class="number">0.75</span>), <span class="number">0.4</span>, <span class="number">0.15</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">circ = plt.Circle((<span class="number">0.7</span>, <span class="number">0.2</span>), <span class="number">0.15</span>, color=<span class="string">&#x27;b&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">pgon = plt.Polygon([[<span class="number">0.15</span>, <span class="number">0.15</span>], [<span class="number">0.35</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.6</span>]],</span><br><span class="line">                   color=<span class="string">&#x27;g&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.add_patch(rect)</span><br><span class="line">ax.add_patch(circ)</span><br><span class="line">ax.add_patch(pgon)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-1f8a3d7a3a02d7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-12 由三个块图形组成的图"></p><p>如果查看许多常见图表对象的具体实现代码，你就会发现它们其实就是由块patch组装而成的。</p><h2 id="将图表保存到文件"><a href="#将图表保存到文件" class="headerlink" title="将图表保存到文件"></a>将图表保存到文件</h2><p>利用plt.savefig可以将当前图表保存到文件。该方法相当于Figure对象的实例方法savefig。例如，要将图表保存为SVG文件，你只需输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;figpath.svg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>文件类型是通过文件扩展名推断出来的。因此，如果你使用的是.pdf，就会得到一个PDF文件。我在发布图片时最常用到两个重要的选项是dpi（控制“每英寸点数”分辨率）和bbox_inches（可以剪除当前图表周围的空白部分）。要得到一张带有最小白边且分辨率为400DPI的PNG图片，你可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;figpath.png&#x27;</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure><p>savefig并非一定要写入磁盘，也可以写入任何文件型的对象，比如BytesIO：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">buffer = BytesIO()</span><br><span class="line">plt.savefig(buffer)</span><br><span class="line">plot_data = buffer.getvalue()</span><br></pre></td></tr></table></figure><p>表9-2列出了savefig的其它选项。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-4bee796bf7262423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-2 Figure.savefig的选项"></p><h2 id="matplotlib配置"><a href="#matplotlib配置" class="headerlink" title="matplotlib配置"></a>matplotlib配置</h2><p>matplotlib自带一些配色方案，以及为生成出版质量的图片而设定的默认配置信息。幸运的是，几乎所有默认行为都能通过一组全局参数进行自定义，它们可以管理图像大小、subplot边距、配色方案、字体大小、网格类型等。一种Python编程方式配置系统的方法是使用rc方法。例如，要将全局的图像默认大小设置为10×10，你可以执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.rc(<span class="string">&#x27;figure&#x27;</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>rc的第一个参数是希望自定义的对象，如’figure’、’axes’、’xtick’、’ytick’、’grid’、’legend’等。其后可以跟上一系列的关键字参数。一个简单的办法是将这些选项写成一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font_options = &#123;<span class="string">&#x27;family&#x27;</span> : <span class="string">&#x27;monospace&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;weight&#x27;</span> : <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;size&#x27;</span>   : <span class="string">&#x27;small&#x27;</span>&#125;</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, **font_options)</span><br></pre></td></tr></table></figure><p>要了解全部的自定义选项，请查阅matplotlib的配置文件matplotlibrc（位于matplotlib&#x2F;mpl-data目录中）。如果对该文件进行了自定义，并将其放在你自己的.matplotlibrc目录中，则每次使用matplotlib时就会加载该文件。</p><p>下一节，我们会看到，seaborn包有若干内置的绘图主题或类型，它们使用了matplotlib的内部配置。</p><h1 id="9-2-使用pandas和seaborn绘图"><a href="#9-2-使用pandas和seaborn绘图" class="headerlink" title="9.2 使用pandas和seaborn绘图"></a>9.2 使用pandas和seaborn绘图</h1><p>matplotlib实际上是一种比较低级的工具。要绘制一张图表，你组装一些基本组件就行：数据展示（即图表类型：线型图、柱状图、盒形图、散布图、等值线图等）、图例、标题、刻度标签以及其他注解型信息。</p><p>在pandas中，我们有多列数据，还有行和列标签。pandas自身就有内置的方法，用于简化从DataFrame和Series绘制图形。另一个库seaborn（<a href="https://seaborn.pydata.org/%EF%BC%89%EF%BC%8C%E7%94%B1Michael">https://seaborn.pydata.org/），由Michael</a> Waskom创建的静态图形库。Seaborn简化了许多常见可视类型的创建。</p><blockquote><p>提示：引入seaborn会修改matplotlib默认的颜色方案和绘图类型，以提高可读性和美观度。即使你不使用seaborn API，你可能也会引入seaborn，作为提高美观度和绘制常见matplotlib图形的简化方法。</p></blockquote><h2 id="线型图"><a href="#线型图" class="headerlink" title="线型图"></a>线型图</h2><p>Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线型图（如图9-13所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">60</span>]: s = pd.Series(np.random.randn(<span class="number">10</span>).cumsum(), index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: s.plot()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-f28e5ab2ac94c7a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-13 简单的Series图表示例"></p><p>该Series对象的索引会被传给matplotlib，并用以绘制X轴。可以通过use_index&#x3D;False禁用该功能。X轴的刻度和界限可以通过xticks和xlim选项进行调节，Y轴就用yticks和ylim。plot参数的完整列表请参见表9-3。我只会讲解其中几个，剩下的就留给读者自己去研究了。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-6d9fbf863c09370a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-44e50562aeb5eb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-3 Series.plot方法的参数"></p><p>pandas的大部分绘图方法都有一个可选的ax参数，它可以是一个matplotlib的subplot对象。这使你能够在网格布局中更为灵活地处理subplot的位置。</p><p>DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例（如图9-14所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">62</span>]: df = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>).cumsum(<span class="number">0</span>),</span><br><span class="line">   ....:                   columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">   ....:                   index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: df.plot()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-a1234d5e5ee41a40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-14 简单的DataFrame绘图"></p><p>plot属性包含一批不同绘图类型的方法。例如，df.plot()等价于df.plot.line()。后面会学习这些方法。</p><blockquote><p>笔记：plot的其他关键字参数会被传给相应的matplotlib绘图函数，所以要更深入地自定义图表，就必须学习更多有关matplotlib API的知识。</p></blockquote><p>DataFrame还有一些用于对列进行灵活处理的选项，例如，是要将所有列都绘制到一个subplot中还是创建各自的subplot。详细信息请参见表9-4。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-96651ecaa90f1c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-4 专用于DataFrame的plot参数"></p><blockquote><p>注意： 有关时间序列的绘图，请见第11章。</p></blockquote><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>plot.bar()和plot.barh()分别绘制水平和垂直的柱状图。这时，Series和DataFrame的索引将会被用作X（bar）或Y（barh）刻度（如图9-15所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">64</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: data = pd.Series(np.random.rand(<span class="number">16</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcdefghijklmnop&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: data.plot.bar(ax=axes[<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">Out[<span class="number">66</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7fb62493d470</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: data.plot.barh(ax=axes[<span class="number">1</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-cd54c7ccfa3f0687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-15 水平和垂直的柱状图"></p><p>color&#x3D;’k’和alpha&#x3D;0.7设定了图形的颜色为黑色，并使用部分的填充透明度。对于DataFrame，柱状图会将每一行的值分为一组，并排显示，如图9-16所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: df = pd.DataFrame(np.random.rand(<span class="number">6</span>, <span class="number">4</span>),</span><br><span class="line">   ....:                   index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>],</span><br><span class="line">   ....:                   columns=pd.Index([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>], name=<span class="string">&#x27;Genus&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: df</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">Genus         A         B         C         D</span><br><span class="line">one    <span class="number">0.370670</span>  <span class="number">0.602792</span>  <span class="number">0.229159</span>  <span class="number">0.486744</span></span><br><span class="line">two    <span class="number">0.420082</span>  <span class="number">0.571653</span>  <span class="number">0.049024</span>  <span class="number">0.880592</span></span><br><span class="line">three  <span class="number">0.814568</span>  <span class="number">0.277160</span>  <span class="number">0.880316</span>  <span class="number">0.431326</span></span><br><span class="line">four   <span class="number">0.374020</span>  <span class="number">0.899420</span>  <span class="number">0.460304</span>  <span class="number">0.100843</span></span><br><span class="line">five   <span class="number">0.433270</span>  <span class="number">0.125107</span>  <span class="number">0.494675</span>  <span class="number">0.961825</span></span><br><span class="line">six    <span class="number">0.601648</span>  <span class="number">0.478576</span>  <span class="number">0.205690</span>  <span class="number">0.560547</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: df.plot.bar()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-bfc141acb37d99b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-16 DataFrame的柱状图"></p><p>注意，DataFrame各列的名称”Genus”被用作了图例的标题。</p><p>设置stacked&#x3D;True即可为DataFrame生成堆积柱状图，这样每行的值就会被堆积在一起（如图9-17所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: df.plot.barh(stacked=<span class="literal">True</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-c19e4246eb897978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-17 DataFrame的堆积柱状图"></p><blockquote><p>笔记：柱状图有一个非常不错的用法：利用value_counts图形化显示Series中各值的出现频率，比如s.value_counts().plot.bar()。</p></blockquote><p>再以本书前面用过的那个有关小费的数据集为例，假设我们想要做一张堆积柱状图以展示每天各种聚会规模的数据点的百分比。我用read_csv将数据加载进来，然后根据日期和聚会规模创建一张交叉表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">75</span>]: tips = pd.read_csv(<span class="string">&#x27;examples/tips.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: party_counts = pd.crosstab(tips[<span class="string">&#x27;day&#x27;</span>], tips[<span class="string">&#x27;size&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: party_counts</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">size  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">day                      </span><br><span class="line">Fri   <span class="number">1</span>  <span class="number">16</span>   <span class="number">1</span>   <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">Sat   <span class="number">2</span>  <span class="number">53</span>  <span class="number">18</span>  <span class="number">13</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line">Sun   <span class="number">0</span>  <span class="number">39</span>  <span class="number">15</span>  <span class="number">18</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line">Thur  <span class="number">1</span>  <span class="number">48</span>   <span class="number">4</span>   <span class="number">5</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Not many 1- and 6-person parties</span></span><br><span class="line">In [<span class="number">78</span>]: party_counts = party_counts.loc[:, <span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>然后进行规格化，使得各行的和为1，并生成图表（如图9-18所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Normalize to sum to 1</span></span><br><span class="line">In [<span class="number">79</span>]: party_pcts = party_counts.div(party_counts.<span class="built_in">sum</span>(<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: party_pcts</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">size         <span class="number">2</span>         <span class="number">3</span>         <span class="number">4</span>         <span class="number">5</span></span><br><span class="line">day                                         </span><br><span class="line">Fri   <span class="number">0.888889</span>  <span class="number">0.055556</span>  <span class="number">0.055556</span>  <span class="number">0.000000</span></span><br><span class="line">Sat   <span class="number">0.623529</span>  <span class="number">0.211765</span>  <span class="number">0.152941</span>  <span class="number">0.011765</span></span><br><span class="line">Sun   <span class="number">0.520000</span>  <span class="number">0.200000</span>  <span class="number">0.240000</span>  <span class="number">0.040000</span></span><br><span class="line">Thur  <span class="number">0.827586</span>  <span class="number">0.068966</span>  <span class="number">0.086207</span>  <span class="number">0.017241</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: party_pcts.plot.bar()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-2918f67936823834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-18 每天各种聚会规模的比例"></p><p>于是，通过该数据集就可以看出，聚会规模在周末会变大。</p><p>对于在绘制一个图形之前，需要进行合计的数据，使用seaborn可以减少工作量。用seaborn来看每天的小费比例（图9-19是结果）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">83</span>]: <span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>] = tips[<span class="string">&#x27;tip&#x27;</span>] / (tips[<span class="string">&#x27;total_bill&#x27;</span>] - tips[<span class="string">&#x27;tip&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: tips.head()</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">0</span>       <span class="number">16.99</span>  <span class="number">1.01</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.063204</span></span><br><span class="line"><span class="number">1</span>       <span class="number">10.34</span>  <span class="number">1.66</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.191244</span></span><br><span class="line"><span class="number">2</span>       <span class="number">21.01</span>  <span class="number">3.50</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.199886</span></span><br><span class="line"><span class="number">3</span>       <span class="number">23.68</span>  <span class="number">3.31</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.162494</span></span><br><span class="line"><span class="number">4</span>       <span class="number">24.59</span>  <span class="number">3.61</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.172069</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: sns.barplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, data=tips, orient=<span class="string">&#x27;h&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-c33e8b3add99904b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-19 小费的每日比例，带有误差条"></p><p>seaborn的绘制函数使用data参数，它可能是pandas的DataFrame。其它的参数是关于列的名字。因为一天的每个值有多次观察，柱状图的值是tip_pct的平均值。绘制在柱状图上的黑线代表95%置信区间（可以通过可选参数配置）。</p><p>seaborn.barplot有颜色选项，使我们能够通过一个额外的值设置（见图9-20）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">88</span>]: sns.barplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, data=tips, orient=<span class="string">&#x27;h&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-06abe2f070222115.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-20 根据天和时间的小费比例"></p><p>注意，seaborn已经自动修改了图形的美观度：默认调色板，图形背景和网格线的颜色。你可以用seaborn.set在不同的图形外观之间切换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">90</span>]: sns.<span class="built_in">set</span>(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="直方图和密度图"><a href="#直方图和密度图" class="headerlink" title="直方图和密度图"></a>直方图和密度图</h2><p>直方图（histogram）是一种可以对值频率进行离散化显示的柱状图。数据点被拆分到离散的、间隔均匀的面元中，绘制的是各面元中数据点的数量。再以前面那个小费数据为例，通过在Series使用plot.hist方法，我们可以生成一张“小费占消费总额百分比”的直方图（如图9-21所示）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">92</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>].plot.hist(bins=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-255279376f7649a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-21 小费百分比的直方图"></p><p>与此相关的一种图表类型是密度图，它是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的。一般的过程是将该分布近似为一组核（即诸如正态分布之类的较为简单的分布）。因此，密度图也被称作KDE（Kernel Density Estimate，核密度估计）图。使用plot.kde和标准混合正态分布估计即可生成一张密度图（见图9-22）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">94</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>].plot.density()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-ee929d033159516a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-22  小费百分比的密度图"></p><p>seaborn的distplot方法绘制直方图和密度图更加简单，还可以同时画出直方图和连续密度估计图。作为例子，考虑一个双峰分布，由两个不同的标准正态分布组成（见图9-23）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">96</span>]: comp1 = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: comp2 = np.random.normal(<span class="number">10</span>, <span class="number">2</span>, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: values = pd.Series(np.concatenate([comp1, comp2]))</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: sns.distplot(values, bins=<span class="number">100</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-975f04d750c4efe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-23 标准混合密度估计的标准直方图"></p><h2 id="散布图或点图"><a href="#散布图或点图" class="headerlink" title="散布图或点图"></a>散布图或点图</h2><p>点图或散布图是观察两个一维数据序列之间的关系的有效手段。在下面这个例子中，我加载了来自statsmodels项目的macrodata数据集，选择了几个变量，然后计算对数差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">100</span>]: macro = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data = macro[[<span class="string">&#x27;cpi&#x27;</span>, <span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;tbilrate&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: trans_data = np.log(data).diff().dropna()</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: trans_data[-<span class="number">5</span>:]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">          cpi        m1  tbilrate     unemp</span><br><span class="line"><span class="number">198</span> -<span class="number">0.007904</span>  <span class="number">0.045361</span> -<span class="number">0.396881</span>  <span class="number">0.105361</span></span><br><span class="line"><span class="number">199</span> -<span class="number">0.021979</span>  <span class="number">0.066753</span> -<span class="number">2.277267</span>  <span class="number">0.139762</span></span><br><span class="line"><span class="number">200</span>  <span class="number">0.002340</span>  <span class="number">0.010286</span>  <span class="number">0.606136</span>  <span class="number">0.160343</span></span><br><span class="line"><span class="number">201</span>  <span class="number">0.008419</span>  <span class="number">0.037461</span> -<span class="number">0.200671</span>  <span class="number">0.127339</span></span><br><span class="line"><span class="number">202</span>  <span class="number">0.008894</span>  <span class="number">0.012202</span> -<span class="number">0.405465</span>  <span class="number">0.042560</span></span><br></pre></td></tr></table></figure><p>然后可以使用seaborn的regplot方法，它可以做一个散布图，并加上一条线性回归的线（见图9-24）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">105</span>]: sns.regplot(<span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>, data=trans_data)</span><br><span class="line">Out[<span class="number">105</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7fb613720be0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: plt.title(<span class="string">&#x27;Changes in log %s versus log %s&#x27;</span> % (<span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-2133d20739478a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-24 seaborn的回归/散布图"></p><p>在探索式数据分析工作中，同时观察一组变量的散布图是很有意义的，这也被称为散布图矩阵（scatter plot matrix）。纯手工创建这样的图表很费工夫，所以seaborn提供了一个便捷的pairplot函数，它支持在对角线上放置每个变量的直方图或密度估计（见图9-25）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">107</span>]: sns.pairplot(trans_data, diag_kind=<span class="string">&#x27;kde&#x27;</span>, plot_kws=&#123;<span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.2</span>&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-20aa530a44e06f61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-25 statsmodels macro data的散布图矩阵"></p><p>你可能注意到了plot_kws参数。它可以让我们传递配置选项到非对角线元素上的图形使用。对于更详细的配置选项，可以查阅seaborn.pairplot文档字符串。</p><p>##分面网格（facet grid）和类型数据<br>要是数据集有额外的分组维度呢？有多个分类变量的数据可视化的一种方法是使用小面网格。seaborn有一个有用的内置函数factorplot，可以简化制作多种分面图（见图9-26）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">108</span>]: sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, col=<span class="string">&#x27;smoker&#x27;</span>,</span><br><span class="line">  .....:                kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-737ba19a0cbdd46f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-26 按照天/时间/吸烟者的小费百分比"></p><p>除了在分面中用不同的颜色按时间分组，我们还可以通过给每个时间值添加一行来扩展分面网格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">109</span>]: sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, row=<span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">   .....:                col=<span class="string">&#x27;smoker&#x27;</span>,</span><br><span class="line">   .....:                kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-4e52192441c609f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-27 按天的tip_pct，通过time/smoker分面"></p><p>factorplot支持其它的绘图类型，你可能会用到。例如，盒图（它可以显示中位数，四分位数，和异常值）就是一个有用的可视化类型（见图9-28）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">110</span>]: sns.factorplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, kind=<span class="string">&#x27;box&#x27;</span>,</span><br><span class="line">   .....:                data=tips[tips.tip_pct &lt; <span class="number">0.5</span>])</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-356fb27a7c658920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-28 按天的tip_pct的盒图"></p><p>使用更通用的seaborn.FacetGrid类，你可以创建自己的分面网格。请查阅seaborn的文档（<a href="https://seaborn.pydata.org/%EF%BC%89%E3%80%82">https://seaborn.pydata.org/）。</a></p><h1 id="9-3-其它的Python可视化工具"><a href="#9-3-其它的Python可视化工具" class="headerlink" title="9.3 其它的Python可视化工具"></a>9.3 其它的Python可视化工具</h1><p>与其它开源库类似，Python创建图形的方式非常多（根本罗列不完）。自从2010年，许多开发工作都集中在创建交互式图形以便在Web上发布。利用工具如Boken（<a href="https://bokeh.pydata.org/en/latest/%EF%BC%89%E5%92%8CPlotly%EF%BC%88https://github.com/plotly/plotly.py%EF%BC%89%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E4%BA%A4%E4%BA%92%E5%9B%BE%E5%BD%A2%EF%BC%8C%E7%94%A8%E4%BA%8E%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%82">https://bokeh.pydata.org/en/latest/）和Plotly（https://github.com/plotly/plotly.py），现在可以创建动态交互图形，用于网页浏览器。</a></p><p>对于创建用于打印或网页的静态图形，我建议默认使用matplotlib和附加的库，比如pandas和seaborn。对于其它数据可视化要求，学习其它的可用工具可能是有用的。我鼓励你探索绘图的生态系统，因为它将持续发展。</p><h1 id="9-4-总结"><a href="#9-4-总结" class="headerlink" title="9.4 总结"></a>9.4 总结</h1><p>本章的目的是熟悉一些基本的数据可视化操作，使用pandas，matplotlib，和seaborn。如果视觉显示数据分析的结果对你的工作很重要，我鼓励你寻求更多的资源来了解更高效的数据可视化。这是一个活跃的研究领域，你可以通过在线和纸质的形式学习许多优秀的资源。</p><p>下一章，我们将重点放在pandas的数据聚合和分组操作上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC08%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%81%9A%E5%90%88%E3%80%81%E5%90%88%E5%B9%B6%E5%92%8C%E9%87%8D%E5%A1%91/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC08%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%EF%BC%9A%E8%81%9A%E5%90%88%E3%80%81%E5%90%88%E5%B9%B6%E5%92%8C%E9%87%8D%E5%A1%91/</url>
      
        <content type="html"><![CDATA[<p>在许多应用中，数据可能分散在许多文件或数据库中，存储的形式也不利于分析。本章关注可以聚合、合并、重塑数据的方法。</p><p>首先，我会介绍pandas的层次化索引，它广泛用于以上操作。然后，我深入介绍了一些特殊的数据操作。在第14章，你可以看到这些工具的多种应用。</p><h1 id="8-1-层次化索引"><a href="#8-1-层次化索引" class="headerlink" title="8.1 层次化索引"></a>8.1 层次化索引</h1><p>层次化索引（hierarchical indexing）是pandas的一项重要功能，它使你能在一个轴上拥有多个（两个以上）索引级别。抽象点说，它使你能以低维度形式处理高维度数据。我们先来看一个简单的例子：创建一个Series，并用一个由列表或数组组成的列表作为索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: data = pd.Series(np.random.randn(<span class="number">9</span>),</span><br><span class="line">   ...:                  index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ...:                         [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: data</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">a  <span class="number">1</span>   -<span class="number">0.204708</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.478943</span></span><br><span class="line">   <span class="number">3</span>   -<span class="number">0.519439</span></span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>看到的结果是经过美化的带有MultiIndex索引的Series的格式。索引之间的“间隔”表示“直接使用上面的标签”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: data.index</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">MultiIndex(levels=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]],</span><br><span class="line">           labels=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p>对于一个层次化索引的对象，可以使用所谓的部分索引，使用它选取数据子集的操作更简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: data[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data.loc[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>有时甚至还可以在“内层”中进行选取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: data.loc[:, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">a    <span class="number">0.478943</span></span><br><span class="line">c    <span class="number">0.092908</span></span><br><span class="line">d    <span class="number">0.281746</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>层次化索引在数据重塑和基于分组的操作（如透视表生成）中扮演着重要的角色。例如，可以通过unstack方法将这段数据重新安排到一个DataFrame中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: data.unstack()</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">          <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line">a -<span class="number">0.204708</span>  <span class="number">0.478943</span> -<span class="number">0.519439</span></span><br><span class="line">b -<span class="number">0.555730</span>       NaN  <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1.393406</span>  <span class="number">0.092908</span>       NaN</span><br><span class="line">d       NaN  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure><p>unstack的逆运算是stack：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: data.unstack().stack()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">a  <span class="number">1</span>   -<span class="number">0.204708</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.478943</span></span><br><span class="line">   <span class="number">3</span>   -<span class="number">0.519439</span></span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>stack和unstack将在本章后面详细讲解。</p><p>对于一个DataFrame，每条轴都可以有分层索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">   ....:                      columns=[[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>],</span><br><span class="line">   ....:                               [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: frame</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">     Ohio     Colorado</span><br><span class="line">    Green Red    Green</span><br><span class="line">a <span class="number">1</span>     <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b <span class="number">1</span>     <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure><p>各层都可以有名字（可以是字符串，也可以是别的Python对象）。如果指定了名称，它们就会显示在控制台输出中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: frame.index.names = [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: frame.columns.names = [<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: frame</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key1 key2                   </span><br><span class="line">a    <span class="number">1</span>        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：小心区分索引名state、color与行标签。</p></blockquote><p>有了部分列索引，因此可以轻松选取列分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: frame[<span class="string">&#x27;Ohio&#x27;</span>]</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">color      Green  Red</span><br><span class="line">key1 key2            </span><br><span class="line">a    <span class="number">1</span>         <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">b    <span class="number">1</span>         <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">9</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以单独创建MultiIndex然后复用。上面那个DataFrame中的（带有分级名称）列可以这样创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultiIndex.from_arrays([[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]],</span><br><span class="line">                       names=[<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="重排与分级排序"><a href="#重排与分级排序" class="headerlink" title="重排与分级排序"></a>重排与分级排序</h2><p>有时，你需要重新调整某条轴上各级别的顺序，或根据指定级别上的值对数据进行排序。swaplevel接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: frame.swaplevel(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key2 key1                   </span><br><span class="line"><span class="number">1</span>    a        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    a        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line"><span class="number">1</span>    b        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line"><span class="number">2</span>    b        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure><p>而sort_index则根据单个级别中的值对数据进行排序。交换级别时，常常也会用到sort_index，这样最终结果就是按照指定顺序进行字母排序了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key1 key2                   </span><br><span class="line">a    <span class="number">1</span>        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">a    <span class="number">2</span>        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b    <span class="number">2</span>        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key2 key1                   </span><br><span class="line"><span class="number">1</span>    a        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">     b        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line"><span class="number">2</span>    a        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">     b        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="根据级别汇总统计"><a href="#根据级别汇总统计" class="headerlink" title="根据级别汇总统计"></a>根据级别汇总统计</h2><p>许多对DataFrame和Series的描述和汇总统计都有一个level选项，它用于指定在某条轴上求和的级别。再以上面那个DataFrame为例，我们可以根据行或列上的级别来进行求和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">27</span>]: frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">state  Ohio     Colorado</span><br><span class="line">color Green Red    Green</span><br><span class="line">key2                    </span><br><span class="line"><span class="number">1</span>         <span class="number">6</span>   <span class="number">8</span>       <span class="number">10</span></span><br><span class="line"><span class="number">2</span>        <span class="number">12</span>  <span class="number">14</span>       <span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;color&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">color      Green  Red</span><br><span class="line">key1 key2            </span><br><span class="line">a    <span class="number">1</span>         <span class="number">2</span>    <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">8</span>    <span class="number">4</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">14</span>    <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">20</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这其实是利用了pandas的groupby功能，本书稍后将对其进行详细讲解。</p><h2 id="使用DataFrame的列进行索引"><a href="#使用DataFrame的列进行索引" class="headerlink" title="使用DataFrame的列进行索引"></a>使用DataFrame的列进行索引</h2><p>人们经常想要将DataFrame的一个或多个列当做行索引来用，或者可能希望将行索引变成DataFrame的列。以下面这个DataFrame为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>), <span class="string">&#x27;b&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>, <span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">   ....:                       <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">   ....:                             <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;d&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: frame</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">   a  b    c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line"><span class="number">5</span>  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>DataFrame的set_index函数会将其一个或多个列转换为行索引，并创建一个新的DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: frame2 = frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: frame2</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">       a  b</span><br><span class="line">c   d      </span><br><span class="line">one <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line">two <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>默认情况下，那些列会从DataFrame中移除，但也可以将其保留下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], drop=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">       a  b    c  d</span><br><span class="line">c   d              </span><br><span class="line">one <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line">two <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>reset_index的功能跟set_index刚好相反，层次化索引的级别会被转移到列里面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: frame2.reset_index()</span><br><span class="line">Out[<span class="number">34</span>]:</span><br><span class="line">c  d  a  b</span><br><span class="line"><span class="number">0</span>  one  <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  one  <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  one  <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line"><span class="number">3</span>  two  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  two  <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two  <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  two  <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="8-2-合并数据集"><a href="#8-2-合并数据集" class="headerlink" title="8.2 合并数据集"></a>8.2 合并数据集</h1><p>pandas对象中的数据可以通过一些方式进行合并：</p><ul><li>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。SQL或其他关系型数据库的用户对此应该会比较熟悉，因为它实现的就是数据库的join操作。</li><li>pandas.concat可以沿着一条轴将多个对象堆叠到一起。</li><li>实例方法combine_first可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</li></ul><p>我将分别对它们进行讲解，并给出一些例子。本书剩余部分的示例中将经常用到它们。</p><p>##数据库风格的DataFrame合并</p><p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于SQL）的核心。pandas的merge函数是对数据应用这些算法的主要切入点。</p><p>以一个简单的例子开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: df1</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a</span><br><span class="line"><span class="number">6</span>      <span class="number">6</span>   b</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: df2</span><br><span class="line">Out[<span class="number">38</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   d</span><br></pre></td></tr></table></figure><p>这是一种多对一的合并。df1中的数据有多个被标记为a和b的行，而df2中key列的每个值则仅对应一行。对这些对象调用merge即可得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: pd.merge(df1, df2)</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意，我并没有指明要用哪个列进行连接。如果没有指定，merge就会将重叠列的列名当做键。不过，最好明确指定一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果两个对象的列名不同，也可以分别进行指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df3 = pd.DataFrame(&#123;<span class="string">&#x27;lkey&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df4 = pd.DataFrame(&#123;<span class="string">&#x27;rkey&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: pd.merge(df3, df4, left_on=<span class="string">&#x27;lkey&#x27;</span>, right_on=<span class="string">&#x27;rkey&#x27;</span>)</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>    a      <span class="number">0</span>    a</span><br></pre></td></tr></table></figure><p>可能你已经注意到了，结果里面c和d以及与之相关的数据消失了。默认情况下，merge做的是“内连接”；结果中的键是交集。其他方式还有”left”、”right”以及”outer”。外连接求取的是键的并集，组合了左连接和右连接的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: pd.merge(df1, df2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">5.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">3.0</span>   c    NaN</span><br><span class="line"><span class="number">7</span>    NaN   d    <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>表8-1对这些选项进行了总结。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表8-1 不同的连接类型"></p><p>多对多的合并有些不直观。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: df1</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   b</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: df2</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   b</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   d</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">    data1 key  data2</span><br><span class="line"><span class="number">0</span>       <span class="number">0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">0</span>   b    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>       <span class="number">1</span>   b    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>       <span class="number">2</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">2</span>   a    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>       <span class="number">3</span>   c    NaN</span><br><span class="line"><span class="number">7</span>       <span class="number">4</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">8</span>       <span class="number">4</span>   a    <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>       <span class="number">5</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">10</span>      <span class="number">5</span>   b    <span class="number">3.0</span></span><br></pre></td></tr></table></figure><p>多对多连接产生的是行的笛卡尔积。由于左边的DataFrame有3个”b”行，右边的有2个，所以最终结果中就有6个”b”行。连接方式只影响出现在结果中的不同的键的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: pd.merge(df1, df2, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">1</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>      <span class="number">5</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">6</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">8</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">4</span>   a      <span class="number">2</span></span><br></pre></td></tr></table></figure><p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;rval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">  key1 key2  lval  rval</span><br><span class="line"><span class="number">0</span>  foo  one   <span class="number">1.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  foo  one   <span class="number">1.0</span>   <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  foo  two   <span class="number">2.0</span>   NaN</span><br><span class="line"><span class="number">3</span>  bar  one   <span class="number">3.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  bar  two   NaN   <span class="number">7.0</span></span><br></pre></td></tr></table></figure><p>结果中会出现哪些键组合取决于所选的合并方式，你可以这样来理解：多个键形成一系列元组，并将其当做单个连接键（当然，实际上并不是这么回事）。</p><blockquote><p>注意：在进行列－列连接时，DataFrame对象中的索引会被丢弃。</p></blockquote><p>对于合并运算需要考虑的最后一个问题是对重复列名的处理。虽然你可以手工处理列名重叠的问题（查看前面介绍的重命名轴标签），但merge有一个更实用的suffixes选项，用于指定附加到左右两个DataFrame对象的重叠列名上的字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line">  key1 key2_x  lval key2_y  rval</span><br><span class="line"><span class="number">0</span>  foo    one     <span class="number">1</span>    one     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo    one     <span class="number">1</span>    one     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo    two     <span class="number">2</span>    one     <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo    two     <span class="number">2</span>    one     <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar    one     <span class="number">3</span>    one     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar    one     <span class="number">3</span>    two     <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>, suffixes=(<span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span>))</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">  key1 key2_left  lval key2_right  rval</span><br><span class="line"><span class="number">0</span>  foo       one     <span class="number">1</span>        one     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo       one     <span class="number">1</span>        one     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo       two     <span class="number">2</span>        one     <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo       two     <span class="number">2</span>        one     <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar       one     <span class="number">3</span>        one     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar       one     <span class="number">3</span>        two     <span class="number">7</span></span><br></pre></td></tr></table></figure><p>merge的参数请参见表8-2。使用DataFrame的行索引合并是下一节的主题。</p><p>表8-2 merge函数的参数</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>indicator 添加特殊的列_merge，它可以指明每个行的来源，它的值有left_only、right_only或both，根据每行的合并数据的来源。</p><h2 id="索引上的合并"><a href="#索引上的合并" class="headerlink" title="索引上的合并"></a>索引上的合并</h2><p>有时候，DataFrame中的连接键位于其索引中。在这种情况下，你可以传入left_index&#x3D;True或right_index&#x3D;True（或两个都传）以说明索引应该被用作连接键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: left1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;value&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: right1 = pd.DataFrame(&#123;<span class="string">&#x27;group_val&#x27;</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: left1</span><br><span class="line">Out[<span class="number">58</span>]:</span><br><span class="line"></span><br><span class="line">  key  value</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: right1</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">   group_val</span><br><span class="line">a        <span class="number">3.5</span></span><br><span class="line">b        <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br></pre></td></tr></table></figure><p>由于默认的merge方法是求取连接键的交集，因此你可以通过外连接的方式得到它们的并集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">61</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span>        NaN</span><br></pre></td></tr></table></figure><p>对于层次化索引的数据，事情就有点复杂了，因为索引的合并默认是多键合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">62</span>]: lefth = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>,</span><br><span class="line">   ....:                                <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;key2&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;data&#x27;</span>: np.arange(<span class="number">5.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)),</span><br><span class="line">   ....:                       index=[[<span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>,</span><br><span class="line">   ....:                               <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>],</span><br><span class="line">   ....:                              [<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;event2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: lefth</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">   data    key1  key2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4.0</span>  Nevada  <span class="number">2002</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: righth</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line">             event1  event2</span><br><span class="line">Nevada <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></span><br><span class="line">       <span class="number">2000</span>       <span class="number">2</span>       <span class="number">3</span></span><br><span class="line">Ohio   <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line">       <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></span><br><span class="line">       <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></span><br><span class="line">       <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></span><br></pre></td></tr></table></figure><p>这种情况下，你必须以列表的形式指明用作合并键的多个列（注意用how&#x3D;’outer’对重复索引值的处理）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">66</span>]: </span><br><span class="line">   data    key1  key2  event1  event2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>],</span><br><span class="line">   ....:          right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">   data    key1  key2  event1  event2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>     <span class="number">4.0</span>     <span class="number">5.0</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>     <span class="number">6.0</span>     <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span>     <span class="number">8.0</span>     <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span>    <span class="number">10.0</span>    <span class="number">11.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span>     <span class="number">0.0</span>     <span class="number">1.0</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4.0</span>  Nevada  <span class="number">2002</span>     NaN     NaN</span><br><span class="line"><span class="number">4</span>   NaN  Nevada  <span class="number">2000</span>     <span class="number">2.0</span>     <span class="number">3.0</span></span><br></pre></td></tr></table></figure><p>同时使用合并双方的索引也没问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: left2 = pd.DataFrame([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>], [<span class="number">5.</span>, <span class="number">6.</span>]],</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: right2 = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">13</span>, <span class="number">14</span>]],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;Missouri&#x27;</span>, <span class="string">&#x27;Alabama&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: left2</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   Ohio  Nevada</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: right2</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">   Missouri  Alabama</span><br><span class="line">b       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e      <span class="number">13.0</span>     <span class="number">14.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: pd.merge(left2, right2, how=<span class="string">&#x27;outer&#x27;</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN</span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span></span><br></pre></td></tr></table></figure><p>DataFrame还有一个便捷的join实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的DataFrame对象，但要求没有重叠的列。在上面那个例子中，我们可以编写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: left2.join(right2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN</span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span></span><br></pre></td></tr></table></figure><p>因为一些历史版本的遗留原因，DataFrame的join方法默认使用的是左连接，保留左边表的行索引。它还支持在调用的DataFrame的列上，连接传递的DataFrame索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: left1.join(right1, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span>        NaN</span><br></pre></td></tr></table></figure><p>最后，对于简单的索引合并，你还可以向join传入一组DataFrame，下一节会介绍更为通用的concat函数，也能实现此功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">75</span>]: another = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">16.</span>, <span class="number">17.</span>]],</span><br><span class="line">   ....:                        index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">   ....:                        columns=[<span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: another</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">   New York  Oregon</span><br><span class="line">a       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">c       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">e      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line">f      <span class="number">16.0</span>    <span class="number">17.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: left2.join([right2, another])</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama  New York  Oregon</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span>       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span>      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: left2.join([right2, another], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama  New York  Oregon</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span>       NaN     NaN</span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span>       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span>       NaN     NaN</span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span>      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line">f   NaN     NaN       NaN      NaN      <span class="number">16.0</span>    <span class="number">17.0</span></span><br></pre></td></tr></table></figure><h2 id="轴向连接"><a href="#轴向连接" class="headerlink" title="轴向连接"></a>轴向连接</h2><p>另一种数据合并运算也被称作连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy的concatenation函数可以用NumPy数组来做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">79</span>]: arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>对于pandas对象（如Series和DataFrame），带有标签的轴使你能够进一步推广数组的连接运算。具体点说，你还需要考虑以下这些东西：</p><ul><li>如果对象在其它轴上的索引不同，我们应该合并这些轴的不同元素还是只使用交集？</li><li>连接的数据集是否需要在结果对象中可识别？</li><li>连接轴中保存的数据是否需要保留？许多情况下，DataFrame默认的整数标签最好在连接时删掉。</li></ul><p>pandas的concat函数提供了一种能够解决这些问题的可靠方式。我将给出一些例子来讲解其使用方式。假设有三个没有重叠索引的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">82</span>]: s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br></pre></td></tr></table></figure><p>对这些对象调用concat可以将值和索引粘合在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">85</span>]: pd.concat([s1, s2, s3])</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">d    <span class="number">3</span></span><br><span class="line">e    <span class="number">4</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>默认情况下，concat是在axis&#x3D;0上工作的，最终产生一个新的Series。如果传入axis&#x3D;1，则结果就会变成一个DataFrame（axis&#x3D;1是列）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">86</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">a  <span class="number">0.0</span>  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>  NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>  NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>  NaN</span><br><span class="line">f  NaN  NaN  <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN  <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>这种情况下，另外的轴上没有重叠，从索引的有序并集（外连接）上就可以看出来。传入join&#x3D;’inner’即可得到它们的交集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">87</span>]: s4 = pd.concat([s1, s3])</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: s4</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">     <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0.0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1.0</span>  <span class="number">1</span></span><br><span class="line">f  NaN  <span class="number">5</span></span><br><span class="line">g  NaN  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这个例子中，f和g标签消失了，是因为使用的是join&#x3D;’inner’选项。</p><p>你可以通过join_axes指定要在其它轴上使用的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">91</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>, join_axes=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]])</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">a  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">c  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line">e  NaN  NaN</span><br></pre></td></tr></table></figure><p>不过有个问题，参与连接的片段在结果中区分不开。假设你想要在连接轴上创建一个层次化索引。使用keys参数即可达到这个目的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">92</span>]: result = pd.concat([s1, s1, s3], keys=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: result</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">one    a    <span class="number">0</span></span><br><span class="line">       b    <span class="number">1</span></span><br><span class="line">two    a    <span class="number">0</span></span><br><span class="line">       b    <span class="number">1</span></span><br><span class="line">three  f    <span class="number">5</span></span><br><span class="line">       g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: result.unstack()</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">         a    b    f    g</span><br><span class="line">one    <span class="number">0.0</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">two    <span class="number">0.0</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">three  NaN  NaN  <span class="number">5.0</span>  <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>如果沿着axis&#x3D;1对Series进行合并，则keys就会成为DataFrame的列头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">95</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">   one  two  three</span><br><span class="line">a  <span class="number">0.0</span>  NaN    NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN    NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>    NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>    NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>    NaN</span><br><span class="line">f  NaN  NaN    <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN    <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>同样的逻辑也适用于DataFrame对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">96</span>]: df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                    columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: df2 = pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                    columns=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: df1</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">   one  two</span><br><span class="line">a    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">c    <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: df2</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   three  four</span><br><span class="line">a      <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">c      <span class="number">7</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>])</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">  level1     level2     </span><br><span class="line">     one two  three four</span><br><span class="line">a      <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b      <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c      <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p>如果传入的不是列表而是一个字典，则字典的键就会被当做keys选项的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">101</span>]: pd.concat(&#123;<span class="string">&#x27;level1&#x27;</span>: df1, <span class="string">&#x27;level2&#x27;</span>: df2&#125;, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">  level1     level2     </span><br><span class="line">     one two  three four</span><br><span class="line">a      <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b      <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c      <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p>此外还有两个用于管理层次化索引创建方式的参数（参见表8-3）。举个例子，我们可以用names参数命名创建的轴级别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">102</span>]: pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>],</span><br><span class="line">   .....:           names=[<span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>])</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">upper level1     level2     </span><br><span class="line">lower    one two  three four</span><br><span class="line">a          <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b          <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c          <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p>最后一个关于DataFrame的问题是，DataFrame的行索引不包含任何相关数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">103</span>]: df1 = pd.DataFrame(np.random.randn(<span class="number">3</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">3</span>), columns=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: df1</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: df2</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">          b         d         a</span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br></pre></td></tr></table></figure><p>在这种情况下，传入ignore_index&#x3D;True即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">107</span>]: pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.021228</span>  <span class="number">0.476985</span>       NaN  <span class="number">3.248944</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.302614</span> -<span class="number">0.577087</span>       NaN  <span class="number">0.124121</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表8-3 concat函数的参数"></p><h2 id="合并重叠数据"><a href="#合并重叠数据" class="headerlink" title="合并重叠数据"></a>合并重叠数据</h2><p>还有一种数据组合问题不能用简单的合并（merge）或连接（concatenation）运算来处理。比如说，你可能有索引全部或部分重叠的两个数据集。举个有启发性的例子，我们使用NumPy的where函数，它表示一种等价于面向数组的if-else：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">108</span>]: a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan],</span><br><span class="line">   .....:               index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: b = pd.Series(np.arange(<span class="built_in">len</span>(a), dtype=np.float64),</span><br><span class="line">   .....:               index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: b[-<span class="number">1</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: a</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">f    NaN</span><br><span class="line">e    <span class="number">2.5</span></span><br><span class="line">d    NaN</span><br><span class="line">c    <span class="number">3.5</span></span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: b</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">b    <span class="number">4.0</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: np.where(pd.isnull(a), b, a)</span><br><span class="line">Out[<span class="number">113</span>]: array([ <span class="number">0.</span> ,  <span class="number">2.5</span>,  <span class="number">2.</span> ,  <span class="number">3.5</span>,  <span class="number">4.5</span>,  nan])</span><br></pre></td></tr></table></figure><p>Series有一个combine_first方法，实现的也是一样的功能，还带有pandas的数据对齐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">114</span>]: b[:-<span class="number">2</span>].combine_first(a[<span class="number">2</span>:])</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">a    NaN</span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>对于DataFrame，combine_first自然也会在列上做同样的事情，因此你可以将其看做：用传递对象中的数据为调用对象的缺失数据“打补丁”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">115</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1.</span>, np.nan, <span class="number">5.</span>, np.nan],</span><br><span class="line">   .....:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">2.</span>, np.nan, <span class="number">6.</span>],</span><br><span class="line">   .....:                     <span class="string">&#x27;c&#x27;</span>: <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">18</span>, <span class="number">4</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">5.</span>, <span class="number">4.</span>, np.nan, <span class="number">3.</span>, <span class="number">7.</span>],</span><br><span class="line">   .....:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">6.</span>, <span class="number">8.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: df1</span><br><span class="line">Out[<span class="number">117</span>]: </span><br><span class="line">     a    b   c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  NaN  <span class="number">2.0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  NaN  <span class="number">10</span></span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.0</span>  <span class="number">14</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: df2</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">     a    b</span><br><span class="line"><span class="number">0</span>  <span class="number">5.0</span>  NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>  NaN  <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: df1.combine_first(df2)</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">     a    b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">2.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  <span class="number">4.0</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span>   NaN</span><br></pre></td></tr></table></figure><h1 id="8-3-重塑和轴向旋转"><a href="#8-3-重塑和轴向旋转" class="headerlink" title="8.3 重塑和轴向旋转"></a>8.3 重塑和轴向旋转</h1><p>有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（reshape）或轴向旋转（pivot）运算。</p><h2 id="重塑层次化索引"><a href="#重塑层次化索引" class="headerlink" title="重塑层次化索引"></a>重塑层次化索引</h2><p>层次化索引为DataFrame数据的重排任务提供了一种具有良好一致性的方式。主要功能有二：</p><ul><li>stack：将数据的列“旋转”为行。</li><li>unstack：将数据的行“旋转”为列。</li></ul><p>我将通过一系列的范例来讲解这些操作。接下来看一个简单的DataFrame，其中的行列索引均为字符串数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">120</span>]: data = pd.DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                     index=pd.Index([<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Colorado&#x27;</span>], name=<span class="string">&#x27;state&#x27;</span>),</span><br><span class="line">   .....:                     columns=pd.Index([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">   .....:                     name=<span class="string">&#x27;number&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: data</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">number    one  two  three</span><br><span class="line">state                    </span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">3</span>    <span class="number">4</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure><p>对该数据使用stack方法即可将列转换为行，得到一个Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">122</span>]: result = data.stack()</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: result</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">state     number</span><br><span class="line">Ohio      one       <span class="number">0</span></span><br><span class="line">          two       <span class="number">1</span></span><br><span class="line">          three     <span class="number">2</span></span><br><span class="line">Colorado  one       <span class="number">3</span></span><br><span class="line">          two       <span class="number">4</span></span><br><span class="line">          three     <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>对于一个层次化索引的Series，你可以用unstack将其重排为一个DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">124</span>]: result.unstack()</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">number    one  two  three</span><br><span class="line">state                    </span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">3</span>    <span class="number">4</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure><p>默认情况下，unstack操作的是最内层（stack也是如此）。传入分层级别的编号或名称即可对其它级别进行unstack操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">125</span>]: result.unstack(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line">state   Ohio  Colorado</span><br><span class="line">number                </span><br><span class="line">one        <span class="number">0</span>         <span class="number">3</span></span><br><span class="line">two        <span class="number">1</span>         <span class="number">4</span></span><br><span class="line">three      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: result.unstack(<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line">state   Ohio  Colorado</span><br><span class="line">number                </span><br><span class="line">one        <span class="number">0</span>         <span class="number">3</span></span><br><span class="line">two        <span class="number">1</span>         <span class="number">4</span></span><br><span class="line">three      <span class="number">2</span>         <span class="number">5</span></span><br></pre></td></tr></table></figure><p>如果不是所有的级别值都能在各分组中找到的话，则unstack操作可能会引入缺失数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">127</span>]: s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: s2 = pd.Series([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data2 = pd.concat([s1, s2], keys=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data2</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">one  a    <span class="number">0</span></span><br><span class="line">     b    <span class="number">1</span></span><br><span class="line">     c    <span class="number">2</span></span><br><span class="line">     d    <span class="number">3</span></span><br><span class="line">two  c    <span class="number">4</span></span><br><span class="line">     d    <span class="number">5</span></span><br><span class="line">     e    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: data2.unstack()</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">       a    b    c    d    e</span><br><span class="line">one  <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  NaN</span><br><span class="line">two  NaN  NaN  <span class="number">4.0</span>  <span class="number">5.0</span>  <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>stack默认会滤除缺失数据，因此该运算是可逆的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">132</span>]: data2.unstack()</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">       a    b    c    d    e</span><br><span class="line">one  <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  NaN</span><br><span class="line">two  NaN  NaN  <span class="number">4.0</span>  <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: data2.unstack().stack()</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">one  a    <span class="number">0.0</span></span><br><span class="line">     b    <span class="number">1.0</span></span><br><span class="line">     c    <span class="number">2.0</span></span><br><span class="line">     d    <span class="number">3.0</span></span><br><span class="line">two  c    <span class="number">4.0</span></span><br><span class="line">     d    <span class="number">5.0</span></span><br><span class="line">     e    <span class="number">6.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: data2.unstack().stack(dropna=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">one  a    <span class="number">0.0</span></span><br><span class="line">     b    <span class="number">1.0</span></span><br><span class="line">     c    <span class="number">2.0</span></span><br><span class="line">     d    <span class="number">3.0</span></span><br><span class="line">     e    NaN</span><br><span class="line">two  a    NaN</span><br><span class="line">     b    NaN</span><br><span class="line">     c    <span class="number">4.0</span></span><br><span class="line">     d    <span class="number">5.0</span></span><br><span class="line">     e    <span class="number">6.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>在对DataFrame进行unstack操作时，作为旋转轴的级别将会成为结果中的最低级别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">135</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;left&#x27;</span>: result, <span class="string">&#x27;right&#x27;</span>: result + <span class="number">5</span>&#125;,</span><br><span class="line">   .....:                   columns=pd.Index([<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>], name=<span class="string">&#x27;side&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: df</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">side             left  right</span><br><span class="line">state    number             </span><br><span class="line">Ohio     one        <span class="number">0</span>      <span class="number">5</span></span><br><span class="line">         two        <span class="number">1</span>      <span class="number">6</span></span><br><span class="line">         three      <span class="number">2</span>      <span class="number">7</span></span><br><span class="line">Colorado one        <span class="number">3</span>      <span class="number">8</span></span><br><span class="line">         two        <span class="number">4</span>      <span class="number">9</span></span><br><span class="line">         three      <span class="number">5</span>     <span class="number">10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: df.unstack(<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">side   left          right</span><br><span class="line">state  Ohio Colorado  Ohio Colorado</span><br><span class="line">number                             </span><br><span class="line">one       <span class="number">0</span>        <span class="number">3</span>     <span class="number">5</span>        <span class="number">8</span></span><br><span class="line">two       <span class="number">1</span>        <span class="number">4</span>     <span class="number">6</span>        <span class="number">9</span></span><br><span class="line">three     <span class="number">2</span>        <span class="number">5</span>     <span class="number">7</span>       <span class="number">10</span></span><br></pre></td></tr></table></figure><p>当调用stack，我们可以指明轴的名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">138</span>]: df.unstack(<span class="string">&#x27;state&#x27;</span>).stack(<span class="string">&#x27;side&#x27;</span>)</span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">state         Colorado  Ohio</span><br><span class="line">number side                 </span><br><span class="line">one    left          <span class="number">3</span>     <span class="number">0</span></span><br><span class="line">       right         <span class="number">8</span>     <span class="number">5</span></span><br><span class="line">two    left          <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">       right         <span class="number">9</span>     <span class="number">6</span></span><br><span class="line">three  left          <span class="number">5</span>     <span class="number">2</span></span><br><span class="line">       right        <span class="number">10</span>     <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="将“长格式”旋转为“宽格式”"><a href="#将“长格式”旋转为“宽格式”" class="headerlink" title="将“长格式”旋转为“宽格式”"></a>将“长格式”旋转为“宽格式”</h2><p>多个时间序列数据通常是以所谓的“长格式”（long）或“堆叠格式”（stacked）存储在数据库和CSV中的。我们先加载一些示例数据，做一些时间序列规整和数据清洗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">139</span>]: data = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: data.head()</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \</span><br><span class="line"><span class="number">0</span>  <span class="number">1959.0</span>      <span class="number">1.0</span>  <span class="number">2710.349</span>    <span class="number">1707.4</span>  <span class="number">286.898</span>   <span class="number">470.045</span>   <span class="number">1886.9</span>  <span class="number">28.98</span>   </span><br><span class="line"><span class="number">1</span>  <span class="number">1959.0</span>      <span class="number">2.0</span>  <span class="number">2778.801</span>    <span class="number">1733.7</span>  <span class="number">310.859</span>   <span class="number">481.301</span>   <span class="number">1919.7</span>  <span class="number">29.15</span>   </span><br><span class="line"><span class="number">2</span>  <span class="number">1959.0</span>      <span class="number">3.0</span>  <span class="number">2775.488</span>    <span class="number">1751.8</span>  <span class="number">289.226</span>   <span class="number">491.260</span>   <span class="number">1916.4</span>  <span class="number">29.35</span>   </span><br><span class="line"><span class="number">3</span>  <span class="number">1959.0</span>      <span class="number">4.0</span>  <span class="number">2785.204</span>    <span class="number">1753.7</span>  <span class="number">299.356</span>   <span class="number">484.052</span>   <span class="number">1931.3</span>  <span class="number">29.37</span>   </span><br><span class="line"><span class="number">4</span>  <span class="number">1960.0</span>      <span class="number">1.0</span>  <span class="number">2847.699</span>    <span class="number">1770.5</span>  <span class="number">331.722</span>   <span class="number">462.199</span>   <span class="number">1955.5</span>  <span class="number">29.54</span>   </span><br><span class="line">      m1  tbilrate  unemp      pop  infl  realint  </span><br><span class="line"><span class="number">0</span>  <span class="number">139.7</span>      <span class="number">2.82</span>    <span class="number">5.8</span>  <span class="number">177.146</span>  <span class="number">0.00</span>     <span class="number">0.00</span></span><br><span class="line"><span class="number">1</span>  <span class="number">141.7</span>      <span class="number">3.08</span>    <span class="number">5.1</span>  <span class="number">177.830</span>  <span class="number">2.34</span>     <span class="number">0.74</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">140.5</span>      <span class="number">3.82</span>    <span class="number">5.3</span>  <span class="number">178.657</span>  <span class="number">2.74</span>     <span class="number">1.09</span>  </span><br><span class="line"><span class="number">3</span>  <span class="number">140.0</span>      <span class="number">4.33</span>    <span class="number">5.6</span>  <span class="number">179.386</span>  <span class="number">0.27</span>     <span class="number">4.06</span>  </span><br><span class="line"><span class="number">4</span>  <span class="number">139.6</span>      <span class="number">3.50</span>    <span class="number">5.2</span>  <span class="number">180.007</span>  <span class="number">2.31</span>     <span class="number">1.19</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: periods = pd.PeriodIndex(year=data.year, quarter=data.quarter,</span><br><span class="line">   .....:                          name=<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: columns = pd.Index([<span class="string">&#x27;realgdp&#x27;</span>, <span class="string">&#x27;infl&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>], name=<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: data = data.reindex(columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: data.index = periods.to_timestamp(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: ldata = data.stack().reset_index().rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>这就是多个时间序列（或者其它带有两个或多个键的可观察数据，这里，我们的键是date和item）的长格式。表中的每行代表一次观察。</p><p>关系型数据库（如MySQL）中的数据经常都是这样存储的，因为固定架构（即列名和数据类型）有一个好处：随着表中数据的添加，item列中的值的种类能够增加。在前面的例子中，date和item通常就是主键（用关系型数据库的说法），不仅提供了关系完整性，而且提供了更为简单的查询支持。有的情况下，使用这样的数据会很麻烦，你可能会更喜欢DataFrame，不同的item值分别形成一列，date列中的时间戳则用作索引。DataFrame的pivot方法完全可以实现这个转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">147</span>]: pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: pivoted</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">item        infl    realgdp  unemp</span><br><span class="line">date                              </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>   <span class="number">2710.349</span>    <span class="number">5.8</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>   <span class="number">2778.801</span>    <span class="number">5.1</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>   <span class="number">2775.488</span>    <span class="number">5.3</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>   <span class="number">2785.204</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>   <span class="number">2847.699</span>    <span class="number">5.2</span></span><br><span class="line"><span class="number">1960</span>-06-<span class="number">30</span>  <span class="number">0.14</span>   <span class="number">2834.390</span>    <span class="number">5.2</span></span><br><span class="line"><span class="number">1960</span>-09-<span class="number">30</span>  <span class="number">2.70</span>   <span class="number">2839.022</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">1.21</span>   <span class="number">2802.616</span>    <span class="number">6.3</span></span><br><span class="line"><span class="number">1961</span>-03-<span class="number">31</span> -<span class="number">0.40</span>   <span class="number">2819.264</span>    <span class="number">6.8</span></span><br><span class="line"><span class="number">1961</span>-06-<span class="number">30</span>  <span class="number">1.47</span>   <span class="number">2872.005</span>    <span class="number">7.0</span></span><br><span class="line"><span class="meta">... </span>         ...        ...    ...</span><br><span class="line"><span class="number">2007</span>-06-<span class="number">30</span>  <span class="number">2.75</span>  <span class="number">13203.977</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">2007</span>-09-<span class="number">30</span>  <span class="number">3.45</span>  <span class="number">13321.109</span>    <span class="number">4.7</span></span><br><span class="line"><span class="number">2007</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">6.38</span>  <span class="number">13391.249</span>    <span class="number">4.8</span></span><br><span class="line"><span class="number">2008</span>-03-<span class="number">31</span>  <span class="number">2.82</span>  <span class="number">13366.865</span>    <span class="number">4.9</span></span><br><span class="line"><span class="number">2008</span>-06-<span class="number">30</span>  <span class="number">8.53</span>  <span class="number">13415.266</span>    <span class="number">5.4</span></span><br><span class="line"><span class="number">2008</span>-09-<span class="number">30</span> -<span class="number">3.16</span>  <span class="number">13324.600</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">2008</span>-<span class="number">12</span>-<span class="number">31</span> -<span class="number">8.79</span>  <span class="number">13141.920</span>    <span class="number">6.9</span></span><br><span class="line"><span class="number">2009</span>-03-<span class="number">31</span>  <span class="number">0.94</span>  <span class="number">12925.410</span>    <span class="number">8.1</span></span><br><span class="line"><span class="number">2009</span>-06-<span class="number">30</span>  <span class="number">3.37</span>  <span class="number">12901.504</span>    <span class="number">9.2</span></span><br><span class="line"><span class="number">2009</span>-09-<span class="number">30</span>  <span class="number">3.56</span>  <span class="number">12990.341</span>    <span class="number">9.6</span></span><br><span class="line">[<span class="number">203</span> rows x <span class="number">3</span> columns]</span><br></pre></td></tr></table></figure><p>前两个传递的值分别用作行和列索引，最后一个可选值则是用于填充DataFrame的数据列。假设有两个需要同时重塑的数据列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">149</span>]: ldata[<span class="string">&#x27;value2&#x27;</span>] = np.random.randn(<span class="built_in">len</span>(ldata))</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: ldata[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">150</span>]: </span><br><span class="line">        date     item     value    value2</span><br><span class="line"><span class="number">0</span> <span class="number">1959</span>-03-<span class="number">31</span>  realgdp  <span class="number">2710.349</span>  <span class="number">0.523772</span></span><br><span class="line"><span class="number">1</span> <span class="number">1959</span>-03-<span class="number">31</span>     infl     <span class="number">0.000</span>  <span class="number">0.000940</span></span><br><span class="line"><span class="number">2</span> <span class="number">1959</span>-03-<span class="number">31</span>    unemp     <span class="number">5.800</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> <span class="number">1959</span>-06-<span class="number">30</span>  realgdp  <span class="number">2778.801</span> -<span class="number">0.713544</span></span><br><span class="line"><span class="number">4</span> <span class="number">1959</span>-06-<span class="number">30</span>     infl     <span class="number">2.340</span> -<span class="number">0.831154</span></span><br><span class="line"><span class="number">5</span> <span class="number">1959</span>-06-<span class="number">30</span>    unemp     <span class="number">5.100</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">6</span> <span class="number">1959</span>-09-<span class="number">30</span>  realgdp  <span class="number">2775.488</span> -<span class="number">1.860761</span></span><br><span class="line"><span class="number">7</span> <span class="number">1959</span>-09-<span class="number">30</span>     infl     <span class="number">2.740</span> -<span class="number">0.860757</span></span><br><span class="line"><span class="number">8</span> <span class="number">1959</span>-09-<span class="number">30</span>    unemp     <span class="number">5.300</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">9</span> <span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  realgdp  <span class="number">2785.204</span> -<span class="number">1.265934</span></span><br></pre></td></tr></table></figure><p>如果忽略最后一个参数，得到的DataFrame就会带有层次化的列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">151</span>]: pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: pivoted[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">           value                    value2                    </span><br><span class="line">item        infl   realgdp unemp      infl   realgdp     unemp</span><br><span class="line">date                                                          </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>   <span class="number">5.8</span>  <span class="number">0.000940</span>  <span class="number">0.523772</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>   <span class="number">5.1</span> -<span class="number">0.831154</span> -<span class="number">0.713544</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>   <span class="number">5.3</span> -<span class="number">0.860757</span> -<span class="number">1.860761</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>   <span class="number">5.6</span>  <span class="number">0.119827</span> -<span class="number">1.265934</span> -<span class="number">1.063512</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>   <span class="number">5.2</span> -<span class="number">2.359419</span>  <span class="number">0.332883</span> -<span class="number">0.199543</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: pivoted[<span class="string">&#x27;value&#x27;</span>][:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">item        infl   realgdp  unemp</span><br><span class="line">date                             </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>    <span class="number">5.8</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>    <span class="number">5.1</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>    <span class="number">5.3</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>    <span class="number">5.2</span></span><br></pre></td></tr></table></figure><p>注意，pivot其实就是用set_index创建层次化索引，再用unstack重塑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">154</span>]: unstacked = ldata.set_index([<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>]).unstack(<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: unstacked[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">155</span>]: </span><br><span class="line">           value                    value2                    </span><br><span class="line">item        infl   realgdp unemp      infl   realgdp     unemp</span><br><span class="line">date                                                          </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>   <span class="number">5.8</span>  <span class="number">0.000940</span>  <span class="number">0.523772</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>   <span class="number">5.1</span> -<span class="number">0.831154</span> -<span class="number">0.713544</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>   <span class="number">5.3</span> -<span class="number">0.860757</span> -<span class="number">1.860761</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>   <span class="number">5.6</span>  <span class="number">0.119827</span> -<span class="number">1.265934</span> -<span class="number">1.063512</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>   <span class="number">5.2</span> -<span class="number">2.359419</span>  <span class="number">0.332883</span> -<span class="number">0.199543</span></span><br><span class="line"><span class="number">1960</span>-06-<span class="number">30</span>  <span class="number">0.14</span>  <span class="number">2834.390</span>   <span class="number">5.2</span> -<span class="number">0.970736</span> -<span class="number">1.541996</span> -<span class="number">1.307030</span></span><br><span class="line"><span class="number">1960</span>-09-<span class="number">30</span>  <span class="number">2.70</span>  <span class="number">2839.022</span>   <span class="number">5.6</span>  <span class="number">0.377984</span>  <span class="number">0.286350</span> -<span class="number">0.753887</span></span><br></pre></td></tr></table></figure><h2 id="将“宽格式”旋转为“长格式”"><a href="#将“宽格式”旋转为“长格式”" class="headerlink" title="将“宽格式”旋转为“长格式”"></a>将“宽格式”旋转为“长格式”</h2><p>旋转DataFrame的逆运算是pandas.melt。它不是将一列转换到多个新的DataFrame，而是合并多个列成为一个，产生一个比输入长的DataFrame。看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">157</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;C&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">   A  B  C  key</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span>  foo</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span>  bar</span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span>  baz</span><br></pre></td></tr></table></figure><p>key列可能是分组指标，其它的列是数据值。当使用pandas.melt，我们必须指明哪些列是分组指标。下面使用key作为唯一的分组指标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">159</span>]: melted = pd.melt(df, [<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: melted</span><br><span class="line">Out[<span class="number">160</span>]: </span><br><span class="line">   key variable  value</span><br><span class="line"><span class="number">0</span>  foo        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  bar        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  baz        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  foo        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  bar        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  baz        B      <span class="number">6</span></span><br><span class="line"><span class="number">6</span>  foo        C      <span class="number">7</span></span><br><span class="line"><span class="number">7</span>  bar        C      <span class="number">8</span></span><br><span class="line"><span class="number">8</span>  baz        C      <span class="number">9</span></span><br></pre></td></tr></table></figure><p>使用pivot，可以重塑回原来的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">161</span>]: reshaped = melted.pivot(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;variable&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: reshaped</span><br><span class="line">Out[<span class="number">162</span>]: </span><br><span class="line">variable  A  B  C</span><br><span class="line">key              </span><br><span class="line">bar       <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line">baz       <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line">foo       <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>因为pivot的结果从列创建了一个索引，用作行标签，我们可以使用reset_index将数据移回列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">163</span>]: reshaped.reset_index()</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">variable  key  A  B  C</span><br><span class="line"><span class="number">0</span>         bar  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line"><span class="number">1</span>         baz  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"><span class="number">2</span>         foo  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>你还可以指定列的子集，作为值的列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">164</span>]: pd.melt(df, id_vars=[<span class="string">&#x27;key&#x27;</span>], value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">   key variable  value</span><br><span class="line"><span class="number">0</span>  foo        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  bar        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  baz        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  foo        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  bar        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  baz        B      <span class="number">6</span></span><br></pre></td></tr></table></figure><p>pandas.melt也可以不用分组指标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">165</span>]: pd.melt(df, value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">Out[<span class="number">165</span>]: </span><br><span class="line">  variable  value</span><br><span class="line"><span class="number">0</span>        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>        B      <span class="number">6</span></span><br><span class="line"><span class="number">6</span>        C      <span class="number">7</span></span><br><span class="line"><span class="number">7</span>        C      <span class="number">8</span></span><br><span class="line"><span class="number">8</span>        C      <span class="number">9</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: pd.melt(df, value_vars=[<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">Out[<span class="number">166</span>]: </span><br><span class="line">  variable value</span><br><span class="line"><span class="number">0</span>      key   foo</span><br><span class="line"><span class="number">1</span>      key   bar</span><br><span class="line"><span class="number">2</span>      key   baz</span><br><span class="line"><span class="number">3</span>        A     <span class="number">1</span></span><br><span class="line"><span class="number">4</span>        A     <span class="number">2</span></span><br><span class="line"><span class="number">5</span>        A     <span class="number">3</span></span><br><span class="line"><span class="number">6</span>        B     <span class="number">4</span></span><br><span class="line"><span class="number">7</span>        B     <span class="number">5</span></span><br><span class="line"><span class="number">8</span>        B     <span class="number">6</span></span><br></pre></td></tr></table></figure><p>#8.4 总结</p><p>现在你已经掌握了pandas数据导入、清洗、重塑，我们可以进一步学习matplotlib数据可视化。我们在稍后会回到pandas，学习更高级的分析。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC06%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E3%80%81%E5%AD%98%E5%82%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC06%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E3%80%81%E5%AD%98%E5%82%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>访问数据是使用本书所介绍的这些工具的第一步。我会着重介绍pandas的数据输入与输出，虽然别的库中也有不少以此为目的的工具。</p><p>输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用Web API操作网络资源。</p><h1 id="6-1-读写文本格式的数据"><a href="#6-1-读写文本格式的数据" class="headerlink" title="6.1 读写文本格式的数据"></a>6.1 读写文本格式的数据</h1><p>pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。表6-1对它们进行了总结，其中read_csv和read_table可能会是你今后用得最多的。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表6-1 pandas中的解析函数"></p><p>我将大致介绍一下这些函数在将文本数据转换为DataFrame时所用到的一些技术。这些函数的选项可以划分为以下几个大类：</p><ul><li>索引：将一个或多个列当做返回的DataFrame处理，以及是否从文件、用户获取列名。</li><li>类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。</li><li>日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。</li><li>迭代：支持对大文件进行逐块迭代。</li><li>不规整数据问题：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。</li></ul><p>因为工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是read_csv）的选项逐渐变得复杂起来。面对不同的参数，感到头痛很正常（read_csv有超过50个参数）。pandas文档有这些参数的例子，如果你感到阅读某个文件很难，可以通过相似的足够多的例子找到正确的参数。</p><p>其中一些函数，比如pandas.read_csv，有类型推断功能，因为列数据的类型不属于数据类型。也就是说，你不需要指定列的类型到底是数值、整数、布尔值，还是字符串。其它的数据格式，如HDF5、Feather和msgpack，会在格式中存储数据类型。</p><p>日期和其他自定义类型的处理需要多花点工夫才行。首先我们来看一个以逗号分隔的（CSV）文本文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: !cat examples/ex1.csv</span><br><span class="line">a,b,c,d,message</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure><blockquote><p>笔记：这里，我用的是Unix的cat shell命令将文件的原始内容打印到屏幕上。如果你用的是Windows，你可以使用type达到同样的效果。</p></blockquote><p>由于该文件以逗号分隔，所以我们可以使用read_csv将其读入一个DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: df = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: df</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>我们还可以使用read_table，并指定分隔符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: pd.read_table(<span class="string">&#x27;examples/ex1.csv&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>并不是所有文件都有标题行。看看下面这个文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: !cat examples/ex2.csv</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure><p>读入该文件的办法有两个。你可以让pandas为其分配默认的列名，也可以自己定义列名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>      <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>  hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>  world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>    foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>假设你希望将message列做成DataFrame的索引。你可以明确表示要将该列放到索引4的位置上，也可以通过index_col参数指定”message”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: names = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=names, index_col=<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">         a   b   c   d</span><br><span class="line">message               </span><br><span class="line">hello    <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line">world    <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line">foo      <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span></span><br></pre></td></tr></table></figure><p>如果希望将多个列做成一个层次化索引，只需传入由列编号或列名组成的列表即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: !cat examples/csv_mindex.csv</span><br><span class="line">key1,key2,value1,value2</span><br><span class="line">one,a,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">one,b,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">one,c,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">one,d,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">two,a,<span class="number">9</span>,<span class="number">10</span></span><br><span class="line">two,b,<span class="number">11</span>,<span class="number">12</span></span><br><span class="line">two,c,<span class="number">13</span>,<span class="number">14</span></span><br><span class="line">two,d,<span class="number">15</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: parsed = pd.read_csv(<span class="string">&#x27;examples/csv_mindex.csv&#x27;</span>,</span><br><span class="line">   ....:                      index_col=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: parsed</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">           value1  value2</span><br><span class="line">key1 key2                </span><br><span class="line">one  a          <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">     b          <span class="number">3</span>       <span class="number">4</span></span><br><span class="line">     c          <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">     d          <span class="number">7</span>       <span class="number">8</span></span><br><span class="line">two  a          <span class="number">9</span>      <span class="number">10</span></span><br><span class="line">     b         <span class="number">11</span>      <span class="number">12</span></span><br><span class="line">     c         <span class="number">13</span>      <span class="number">14</span></span><br><span class="line">     d         <span class="number">15</span>      <span class="number">16</span></span><br></pre></td></tr></table></figure><p>有些情况下，有些表格可能不是用固定的分隔符去分隔字段的（比如空白符或其它模式）。看看下面这个文本文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: <span class="built_in">list</span>(<span class="built_in">open</span>(<span class="string">&#x27;examples/ex3.txt&#x27;</span>))</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">[<span class="string">&#x27;            A         B         C\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;aaa -0.264438 -1.026059 -0.619500\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;bbb  0.927272  0.302904 -0.032399\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ccc -0.264273 -0.386314 -0.217601\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ddd -0.871858 -0.348382  1.100491\n&#x27;</span>]</span><br></pre></td></tr></table></figure><p>虽然可以手动对数据进行规整，这里的字段是被数量不同的空白字符间隔开的。这种情况下，你可以传递一个正则表达式作为read_table的分隔符。可以用正则表达式表达为\s+，于是有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: result = pd.read_table(<span class="string">&#x27;examples/ex3.txt&#x27;</span>, sep=<span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: result</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">            A         B         C</span><br><span class="line">aaa -<span class="number">0.264438</span> -<span class="number">1.026059</span> -<span class="number">0.619500</span></span><br><span class="line">bbb  <span class="number">0.927272</span>  <span class="number">0.302904</span> -<span class="number">0.032399</span></span><br><span class="line">ccc -<span class="number">0.264273</span> -<span class="number">0.386314</span> -<span class="number">0.217601</span></span><br><span class="line">ddd -<span class="number">0.871858</span> -<span class="number">0.348382</span>  <span class="number">1.100491</span></span><br></pre></td></tr></table></figure><p>这里，由于列名比数据行的数量少，所以read_table推断第一列应该是DataFrame的索引。</p><p>这些解析器函数还有许多参数可以帮助你处理各种各样的异形文件格式（表6-2列出了一些）。比如说，你可以用skiprows跳过文件的第一行、第三行和第四行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: !cat examples/ex4.csv</span><br><span class="line"><span class="comment"># hey!</span></span><br><span class="line">a,b,c,d,message</span><br><span class="line"><span class="comment"># just wanted to make things more difficult for you</span></span><br><span class="line"><span class="comment"># who reads CSV files with computers, anyway?</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">24</span>]: pd.read_csv(<span class="string">&#x27;examples/ex4.csv&#x27;</span>, skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，pandas会用一组经常出现的标记值进行识别，比如NA及NULL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: !cat examples/ex5.csv</span><br><span class="line">something,a,b,c,d,message</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,NA</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">26</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: result</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: pd.isnull(result)</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">   something      a      b      c      d  message</span><br><span class="line"><span class="number">0</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>   <span class="literal">True</span>  <span class="literal">False</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>    <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>na_values可以用一个列表或集合的字符串表示缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=[<span class="string">&#x27;NULL&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: result</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>字典的各列可以使用不同的NA标记值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: sentinels = &#123;<span class="string">&#x27;message&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;NA&#x27;</span>], <span class="string">&#x27;something&#x27;</span>: [<span class="string">&#x27;two&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=sentinels)</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line">something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       NaN  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     NaN</span><br></pre></td></tr></table></figure><p>表6-2列出了pandas.read_csv和pandas.read_table常用的选项。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="逐块读取文本文件"><a href="#逐块读取文本文件" class="headerlink" title="逐块读取文本文件"></a>逐块读取文本文件</h2><p>在处理很大的文件时，或找出大文件中的参数集以便于后续处理时，你可能只想读取文件的一小部分或逐块对文件进行迭代。</p><p>在看大文件之前，我们先设置pandas显示地更紧些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: pd.options.display.max_rows = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>然后有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: result</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">           one       two     three      four key</span><br><span class="line"><span class="number">0</span>     <span class="number">0.467976</span> -<span class="number">0.038649</span> -<span class="number">0.295344</span> -<span class="number">1.824726</span>   L</span><br><span class="line"><span class="number">1</span>    -<span class="number">0.358893</span>  <span class="number">1.404453</span>  <span class="number">0.704965</span> -<span class="number">0.200638</span>   B</span><br><span class="line"><span class="number">2</span>    -<span class="number">0.501840</span>  <span class="number">0.659254</span> -<span class="number">0.421691</span> -<span class="number">0.057688</span>   G</span><br><span class="line"><span class="number">3</span>     <span class="number">0.204886</span>  <span class="number">1.074134</span>  <span class="number">1.388361</span> -<span class="number">0.982404</span>   R</span><br><span class="line"><span class="number">4</span>     <span class="number">0.354628</span> -<span class="number">0.133116</span>  <span class="number">0.283763</span> -<span class="number">0.837063</span>   Q</span><br><span class="line"><span class="meta">... </span>       ...       ...       ...       ...  ..</span><br><span class="line"><span class="number">9995</span>  <span class="number">2.311896</span> -<span class="number">0.417070</span> -<span class="number">1.409599</span> -<span class="number">0.515821</span>   L</span><br><span class="line"><span class="number">9996</span> -<span class="number">0.479893</span> -<span class="number">0.650419</span>  <span class="number">0.745152</span> -<span class="number">0.646038</span>   E</span><br><span class="line"><span class="number">9997</span>  <span class="number">0.523331</span>  <span class="number">0.787112</span>  <span class="number">0.486066</span>  <span class="number">1.093156</span>   K</span><br><span class="line"><span class="number">9998</span> -<span class="number">0.362559</span>  <span class="number">0.598894</span> -<span class="number">1.843201</span>  <span class="number">0.887292</span>   G</span><br><span class="line"><span class="number">9999</span> -<span class="number">0.096376</span> -<span class="number">1.012999</span> -<span class="number">0.657431</span> -<span class="number">0.573315</span>   <span class="number">0</span></span><br><span class="line">[<span class="number">10000</span> rows x <span class="number">5</span> columns]</span><br><span class="line">If you want to only read a small</span><br></pre></td></tr></table></figure><p>如果只想读取几行（避免读取整个文件），通过nrows进行指定即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">36</span>]: pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>, nrows=<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">        one       two     three      four key</span><br><span class="line"><span class="number">0</span>  <span class="number">0.467976</span> -<span class="number">0.038649</span> -<span class="number">0.295344</span> -<span class="number">1.824726</span>   L</span><br><span class="line"><span class="number">1</span> -<span class="number">0.358893</span>  <span class="number">1.404453</span>  <span class="number">0.704965</span> -<span class="number">0.200638</span>   B</span><br><span class="line"><span class="number">2</span> -<span class="number">0.501840</span>  <span class="number">0.659254</span> -<span class="number">0.421691</span> -<span class="number">0.057688</span>   G</span><br><span class="line"><span class="number">3</span>  <span class="number">0.204886</span>  <span class="number">1.074134</span>  <span class="number">1.388361</span> -<span class="number">0.982404</span>   R</span><br><span class="line"><span class="number">4</span>  <span class="number">0.354628</span> -<span class="number">0.133116</span>  <span class="number">0.283763</span> -<span class="number">0.837063</span>   Q</span><br></pre></td></tr></table></figure><p>要逐块读取文件，可以指定chunksize（行数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">874</span>]: chunker = pd.read_csv(<span class="string">&#x27;ch06/ex6.csv&#x27;</span>, chunksize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">875</span>]: chunker</span><br><span class="line">Out[<span class="number">875</span>]: &lt;pandas.io.parsers.TextParser at <span class="number">0x8398150</span>&gt;</span><br></pre></td></tr></table></figure><p>read_csv所返回的这个TextParser对象使你可以根据chunksize对文件进行逐块迭代。比如说，我们可以迭代处理ex6.csv，将值计数聚合到”key”列中，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunker = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>, chunksize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">&#x27;key&#x27;</span>].value_counts(), fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>然后有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: tot[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">E    <span class="number">368.0</span></span><br><span class="line">X    <span class="number">364.0</span></span><br><span class="line">L    <span class="number">346.0</span></span><br><span class="line">O    <span class="number">343.0</span></span><br><span class="line">Q    <span class="number">340.0</span></span><br><span class="line">M    <span class="number">338.0</span></span><br><span class="line">J    <span class="number">337.0</span></span><br><span class="line">F    <span class="number">335.0</span></span><br><span class="line">K    <span class="number">334.0</span></span><br><span class="line">H    <span class="number">330.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>TextParser还有一个get_chunk方法，它使你可以读取任意大小的块。</p><h2 id="将数据写出到文本格式"><a href="#将数据写出到文本格式" class="headerlink" title="将数据写出到文本格式"></a>将数据写出到文本格式</h2><p>数据也可以被输出为分隔符格式的文本。我们再来看看之前读过的一个CSV文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: data = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: data</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>利用DataFrame的to_csv方法，我们可以将数据写到一个以逗号分隔的文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">43</span>]: data.to_csv(<span class="string">&#x27;examples/out.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: !cat examples/out.csv</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line"><span class="number">0</span>,one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,</span><br><span class="line"><span class="number">1</span>,two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line"><span class="number">2</span>,three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure><p>当然，还可以使用其他分隔符（由于这里直接写出到sys.stdout，所以仅仅是打印出文本结果而已）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: data.to_csv(sys.stdout, sep=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">|something|a|b|c|d|message</span><br><span class="line"><span class="number">0</span>|one|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3.0</span>|<span class="number">4</span>|</span><br><span class="line"><span class="number">1</span>|two|<span class="number">5</span>|<span class="number">6</span>||<span class="number">8</span>|world</span><br><span class="line"><span class="number">2</span>|three|<span class="number">9</span>|<span class="number">10</span>|<span class="number">11.0</span>|<span class="number">12</span>|foo</span><br></pre></td></tr></table></figure><p>缺失值在输出结果中会被表示为空字符串。你可能希望将其表示为别的标记值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">47</span>]: data.to_csv(sys.stdout, na_rep=<span class="string">&#x27;NULL&#x27;</span>)</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line"><span class="number">0</span>,one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,NULL</span><br><span class="line"><span class="number">1</span>,two,<span class="number">5</span>,<span class="number">6</span>,NULL,<span class="number">8</span>,world</span><br><span class="line"><span class="number">2</span>,three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure><p>如果没有设置其他选项，则会写出行和列的标签。当然，它们也都可以被禁用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">48</span>]: data.to_csv(sys.stdout, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure><p>此外，你还可以只写出一部分的列，并以你指定的顺序排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">49</span>]: data.to_csv(sys.stdout, index=<span class="literal">False</span>, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">a,b,c</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>Series也有一个to_csv方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: dates = pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: ts = pd.Series(np.arange(<span class="number">7</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: ts.to_csv(<span class="string">&#x27;examples/tseries.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: !cat examples/tseries.csv</span><br><span class="line"><span class="number">2000</span>-01-01,<span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02,<span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-03,<span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-04,<span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-05,<span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-06,<span class="number">5</span></span><br><span class="line"><span class="number">2000</span>-01-07,<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="处理分隔符格式"><a href="#处理分隔符格式" class="headerlink" title="处理分隔符格式"></a>处理分隔符格式</h2><p>大部分存储在磁盘上的表格型数据都能用pandas.read_table进行加载。然而，有时还是需要做一些手工处理。由于接收到含有畸形行的文件而使read_table出毛病的情况并不少见。为了说明这些基本工具，看看下面这个简单的CSV文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: !cat examples/ex7.csv</span><br><span class="line"><span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><p>对于任何单字符分隔符文件，可以直接使用Python内置的csv模块。将任意已打开的文件或文件型的对象传给csv.reader：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">reader = csv.reader(f)</span><br></pre></td></tr></table></figure><p>对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">   ....:     <span class="built_in">print</span>(line)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br></pre></td></tr></table></figure><p>现在，为了使数据格式合乎要求，你需要对其做一些整理工作。我们一步一步来做。首先，读取文件到一个多行的列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">57</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   ....:     lines = <span class="built_in">list</span>(csv.reader(f))</span><br></pre></td></tr></table></figure><p>然后，我们将这些行分为标题行和数据行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">58</span>]: header, values = lines[<span class="number">0</span>], lines[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p>然后，我们可以用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">59</span>]: data_dict = &#123;h: v <span class="keyword">for</span> h, v <span class="keyword">in</span> <span class="built_in">zip</span>(header, <span class="built_in">zip</span>(*values))&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: data_dict</span><br><span class="line">Out[<span class="number">60</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), <span class="string">&#x27;b&#x27;</span>: (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2&#x27;</span>), <span class="string">&#x27;c&#x27;</span>: (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure><p>CSV文件的形式有很多。只需定义csv.Dialect的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_dialect</span>(csv.Dialect):</span><br><span class="line">    lineterminator = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    delimiter = <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    quotechar = <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br></pre></td></tr></table></figure><p>各个CSV语支的参数也可以用关键字的形式提供给csv.reader，而无需定义子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader = csv.reader(f, delimiter=<span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可用的选项（csv.Dialect的属性）及其功能如表6-3所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-7a1cee622459072b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>笔记：对于那些使用复杂分隔符或多字符分隔符的文件，csv模块就无能为力了。这种情况下，你就只能使用字符串的split方法或正则表达式方法re.split进行行拆分和其他整理工作了。</p></blockquote><p>要手工输出分隔符文件，你可以使用csv.writer。它接受一个已打开且可写的文件对象以及跟csv.reader相同的那些语支和格式化选项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mydata.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    writer = csv.writer(f, dialect=my_dialect)</span><br><span class="line">    writer.writerow((<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="JSON数据"><a href="#JSON数据" class="headerlink" title="JSON数据"></a>JSON数据</h2><p>JSON（JavaScript Object Notation的简称）已经成为通过HTTP请求在Web浏览器和其他应用程序之间发送数据的标准格式之一。它是一种比表格型文本格式（如CSV）灵活得多的数据格式。下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;Wes&quot;,</span></span><br><span class="line"><span class="string"> &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],</span></span><br><span class="line"><span class="string"> &quot;pet&quot;: null,</span></span><br><span class="line"><span class="string"> &quot;siblings&quot;: [&#123;&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]&#125;,</span></span><br><span class="line"><span class="string">              &#123;&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,</span></span><br><span class="line"><span class="string">               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]&#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>除其空值null和一些其他的细微差别（如列表末尾不允许存在多余的逗号）之外，JSON非常接近于有效的Python代码。基本类型有对象（字典）、数组（列表）、字符串、数值、布尔值以及null。对象中所有的键都必须是字符串。许多Python库都可以读写JSON数据。我将使用json，因为它是构建于Python标准库中的。通过json.loads即可将JSON字符串转换成Python形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">62</span>]: <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: result = json.loads(obj)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: result</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Wes&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;pet&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;places_lived&#x27;</span>: [<span class="string">&#x27;United States&#x27;</span>, <span class="string">&#x27;Spain&#x27;</span>, <span class="string">&#x27;Germany&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;siblings&#x27;</span>: [&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Scott&#x27;</span>, <span class="string">&#x27;pets&#x27;</span>: [<span class="string">&#x27;Zeus&#x27;</span>, <span class="string">&#x27;Zuko&#x27;</span>]&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">38</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Katie&#x27;</span>, <span class="string">&#x27;pets&#x27;</span>: [<span class="string">&#x27;Sixes&#x27;</span>, <span class="string">&#x27;Stache&#x27;</span>, <span class="string">&#x27;Cisco&#x27;</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure><p>json.dumps则将Python对象转换成JSON格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">65</span>]: asjson = json.dumps(result)</span><br></pre></td></tr></table></figure><p>如何将（一个或一组）JSON对象转换为DataFrame或其他便于分析的数据结构就由你决定了。最简单方便的方式是：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: siblings = pd.DataFrame(result[<span class="string">&#x27;siblings&#x27;</span>], columns=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: siblings</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">    name  age</span><br><span class="line"><span class="number">0</span>  Scott   <span class="number">30</span></span><br><span class="line"><span class="number">1</span>  Katie   <span class="number">38</span></span><br></pre></td></tr></table></figure><p>pandas.read_json可以自动将特别格式的JSON数据集转换为Series或DataFrame。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: !cat examples/example.json</span><br><span class="line">[&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;a&quot;</span>: <span class="number">4</span>, <span class="string">&quot;b&quot;</span>: <span class="number">5</span>, <span class="string">&quot;c&quot;</span>: <span class="number">6</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;a&quot;</span>: <span class="number">7</span>, <span class="string">&quot;b&quot;</span>: <span class="number">8</span>, <span class="string">&quot;c&quot;</span>: <span class="number">9</span>&#125;]</span><br></pre></td></tr></table></figure><p>pandas.read_json的默认选项假设JSON数组中的每个对象是表格中的一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: data = pd.read_json(<span class="string">&#x27;examples/example.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: data</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   a  b  c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure><p>第7章中关于USDA Food Database的那个例子进一步讲解了JSON数据的读取和处理（包括嵌套记录）。</p><p>如果你需要将数据从pandas输出到JSON，可以使用to_json方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">71</span>]: <span class="built_in">print</span>(data.to_json())</span><br><span class="line">&#123;<span class="string">&quot;a&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">1</span>,<span class="string">&quot;1&quot;</span>:<span class="number">4</span>,<span class="string">&quot;2&quot;</span>:<span class="number">7</span>&#125;,<span class="string">&quot;b&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">2</span>,<span class="string">&quot;1&quot;</span>:<span class="number">5</span>,<span class="string">&quot;2&quot;</span>:<span class="number">8</span>&#125;,<span class="string">&quot;c&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">3</span>,<span class="string">&quot;1&quot;</span>:<span class="number">6</span>,<span class="string">&quot;2&quot;</span>:<span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: <span class="built_in">print</span>(data.to_json(orient=<span class="string">&#x27;records&#x27;</span>))</span><br><span class="line">[&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,<span class="string">&quot;c&quot;</span>:<span class="number">3</span>&#125;,&#123;<span class="string">&quot;a&quot;</span>:<span class="number">4</span>,<span class="string">&quot;b&quot;</span>:<span class="number">5</span>,<span class="string">&quot;c&quot;</span>:<span class="number">6</span>&#125;,&#123;<span class="string">&quot;a&quot;</span>:<span class="number">7</span>,<span class="string">&quot;b&quot;</span>:<span class="number">8</span>,<span class="string">&quot;c&quot;</span>:<span class="number">9</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="XML和HTML：Web信息收集"><a href="#XML和HTML：Web信息收集" class="headerlink" title="XML和HTML：Web信息收集"></a>XML和HTML：Web信息收集</h2><p>Python有许多可以读写常见的HTML和XML格式数据的库，包括lxml、Beautiful Soup和html5lib。lxml的速度比较快，但其它的库处理有误的HTML或XML文件更好。</p><p>pandas有一个内置的功能，read_html，它可以使用lxml和Beautiful Soup自动将HTML文件中的表格解析为DataFrame对象。为了进行展示，我从美国联邦存款保险公司下载了一个HTML文件（pandas文档中也使用过），它记录了银行倒闭的情况。首先，你需要安装read_html用到的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install lxml</span><br><span class="line">pip install beautifulsoup4 html5lib</span><br></pre></td></tr></table></figure><p>如果你用的不是conda，可以使用<code>pip install lxml</code>。</p><p>pandas.read_html有一些选项，默认条件下，它会搜索、尝试解析<table>标签内的的表格数据。结果是一个列表的DataFrame对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: tables = pd.read_html(<span class="string">&#x27;examples/fdic_failed_bank_list.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: <span class="built_in">len</span>(tables)</span><br><span class="line">Out[<span class="number">74</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: failures = tables[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: failures.head()</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">                      Bank Name             City  ST   CERT  \</span><br><span class="line"><span class="number">0</span>                   Allied Bank         Mulberry  AR     <span class="number">91</span>   </span><br><span class="line"><span class="number">1</span>  The Woodbury Banking Company         Woodbury  GA  <span class="number">11297</span>   </span><br><span class="line"><span class="number">2</span>        First CornerStone Bank  King of Prussia  PA  <span class="number">35312</span>   </span><br><span class="line"><span class="number">3</span>            Trust Company Bank          Memphis  TN   <span class="number">9956</span>   </span><br><span class="line"><span class="number">4</span>    North Milwaukee State Bank        Milwaukee  WI  <span class="number">20364</span>   </span><br><span class="line">                 Acquiring Institution        Closing Date       Updated Date  </span><br><span class="line"><span class="number">0</span>                         Today<span class="string">&#x27;s Bank  September 23, 2016  November 17, 2016  </span></span><br><span class="line"><span class="string">1                          United Bank     August 19, 2016  November 17, 2016  </span></span><br><span class="line"><span class="string">2  First-Citizens Bank &amp; Trust Company         May 6, 2016  September 6, 2016  </span></span><br><span class="line"><span class="string">3           The Bank of Fayette County      April 29, 2016  September 6, 2016  </span></span><br><span class="line"><span class="string">4  First-Citizens Bank &amp; Trust Company      March 11, 2016      June 16, 2016</span></span><br></pre></td></tr></table></figure><p>因为failures有许多列，pandas插入了一个换行符\。</p><p>这里，我们可以做一些数据清洗和分析（后面章节会进一步讲解），比如计算按年份计算倒闭的银行数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">77</span>]: close_timestamps = pd.to_datetime(failures[<span class="string">&#x27;Closing Date&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: close_timestamps.dt.year.value_counts()</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line"><span class="number">2010</span>    <span class="number">157</span></span><br><span class="line"><span class="number">2009</span>    <span class="number">140</span></span><br><span class="line"><span class="number">2011</span>     <span class="number">92</span></span><br><span class="line"><span class="number">2012</span>     <span class="number">51</span></span><br><span class="line"><span class="number">2008</span>     <span class="number">25</span></span><br><span class="line">       ... </span><br><span class="line"><span class="number">2004</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2007</span>      <span class="number">3</span></span><br><span class="line"><span class="number">2003</span>      <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>      <span class="number">2</span></span><br><span class="line">Name: Closing Date, Length: <span class="number">15</span>, dtype: int64</span><br></pre></td></tr></table></figure><h2 id="利用lxml-objectify解析XML"><a href="#利用lxml-objectify解析XML" class="headerlink" title="利用lxml.objectify解析XML"></a>利用lxml.objectify解析XML</h2><p>XML（Extensible Markup Language）是另一种常见的支持分层、嵌套数据以及元数据的结构化数据格式。本书所使用的这些文件实际上来自于一个很大的XML文档。</p><p>前面，我介绍了pandas.read_html函数，它可以使用lxml或Beautiful Soup从HTML解析数据。XML和HTML的结构很相似，但XML更为通用。这里，我会用一个例子演示如何利用lxml从XML格式解析数据。</p><p>纽约大都会运输署发布了一些有关其公交和列车服务的数据资料（<a href="http://www.mta.info/developers/download.html%EF%BC%89%E3%80%82%E8%BF%99%E9%87%8C%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%E7%9C%8B%E7%9C%8B%E5%8C%85%E5%90%AB%E5%9C%A8%E4%B8%80%E7%BB%84XML%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5%E6%95%B0%E6%8D%AE%E3%80%82%E6%AF%8F%E9%A1%B9%E5%88%97%E8%BD%A6%E6%88%96%E5%85%AC%E4%BA%A4%E6%9C%8D%E5%8A%A1%E9%83%BD%E6%9C%89%E5%90%84%E8%87%AA%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%88%E5%A6%82Metro-North">http://www.mta.info/developers/download.html）。这里，我们将看看包含在一组XML文件中的运行情况数据。每项列车或公交服务都有各自的文件（如Metro-North</a> Railroad的文件是Performance_MNR.xml），其中每条XML记录就是一条月度数据，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">INDICATOR</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_SEQ</span>&gt;</span>373889<span class="tag">&lt;/<span class="name">INDICATOR_SEQ</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PARENT_SEQ</span>&gt;</span><span class="tag">&lt;/<span class="name">PARENT_SEQ</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AGENCY_NAME</span>&gt;</span>Metro-North Railroad<span class="tag">&lt;/<span class="name">AGENCY_NAME</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_NAME</span>&gt;</span>Escalator Availability<span class="tag">&lt;/<span class="name">INDICATOR_NAME</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DESCRIPTION</span>&gt;</span>Percent of the time that escalators are operational</span><br><span class="line">  systemwide. The availability rate is based on physical observations performed</span><br><span class="line">  the morning of regular business days only. This is a new indicator the agency</span><br><span class="line">  began reporting in 2009.<span class="tag">&lt;/<span class="name">DESCRIPTION</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PERIOD_YEAR</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">PERIOD_YEAR</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PERIOD_MONTH</span>&gt;</span>12<span class="tag">&lt;/<span class="name">PERIOD_MONTH</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CATEGORY</span>&gt;</span>Service Indicators<span class="tag">&lt;/<span class="name">CATEGORY</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FREQUENCY</span>&gt;</span>M<span class="tag">&lt;/<span class="name">FREQUENCY</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DESIRED_CHANGE</span>&gt;</span>U<span class="tag">&lt;/<span class="name">DESIRED_CHANGE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_UNIT</span>&gt;</span>%<span class="tag">&lt;/<span class="name">INDICATOR_UNIT</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DECIMAL_PLACES</span>&gt;</span>1<span class="tag">&lt;/<span class="name">DECIMAL_PLACES</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YTD_TARGET</span>&gt;</span>97.00<span class="tag">&lt;/<span class="name">YTD_TARGET</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YTD_ACTUAL</span>&gt;</span><span class="tag">&lt;/<span class="name">YTD_ACTUAL</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MONTHLY_TARGET</span>&gt;</span>97.00<span class="tag">&lt;/<span class="name">MONTHLY_TARGET</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MONTHLY_ACTUAL</span>&gt;</span><span class="tag">&lt;/<span class="name">MONTHLY_ACTUAL</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">INDICATOR</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们先用lxml.objectify解析该文件，然后通过getroot得到该XML文件的根节点的引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> objectify</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;datasets/mta_perf/Performance_MNR.xml&#x27;</span></span><br><span class="line">parsed = objectify.parse(<span class="built_in">open</span>(path))</span><br><span class="line">root = parsed.getroot()</span><br></pre></td></tr></table></figure><p>root.INDICATOR返回一个用于产生各个<INDICATOR>XML元素的生成器。对于每条记录，我们可以用标记名（如YTD_ACTUAL）和数据值填充一个字典（排除几个标记）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data = []</span><br><span class="line"></span><br><span class="line">skip_fields = [<span class="string">&#x27;PARENT_SEQ&#x27;</span>, <span class="string">&#x27;INDICATOR_SEQ&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;DESIRED_CHANGE&#x27;</span>, <span class="string">&#x27;DECIMAL_PLACES&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> elt <span class="keyword">in</span> root.INDICATOR:</span><br><span class="line">    el_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> elt.getchildren():</span><br><span class="line">        <span class="keyword">if</span> child.tag <span class="keyword">in</span> skip_fields:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        el_data[child.tag] = child.pyval</span><br><span class="line">    data.append(el_data)</span><br></pre></td></tr></table></figure><p>最后，将这组字典转换为一个DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">81</span>]: perf = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: perf.head()</span><br><span class="line">Out[<span class="number">82</span>]:</span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: []</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure><p>XML数据可以比本例复杂得多。每个标记都可以有元数据。看看下面这个HTML的链接标签（它也算是一段有效的XML）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">tag = <span class="string">&#x27;&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;&#x27;</span></span><br><span class="line">root = objectify.parse(StringIO(tag)).getroot()</span><br></pre></td></tr></table></figure><p>现在就可以访问标签或链接文本中的任何字段了（如href）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">84</span>]: root</span><br><span class="line">Out[<span class="number">84</span>]: &lt;Element a at <span class="number">0x7f6b15817748</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: root.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">Out[<span class="number">85</span>]: <span class="string">&#x27;http://www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: root.text</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">&#x27;Google&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="6-2-二进制数据格式"><a href="#6-2-二进制数据格式" class="headerlink" title="6.2 二进制数据格式"></a>6.2 二进制数据格式</h1><p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化。pandas对象都有一个用于将数据以pickle格式保存到磁盘上的to_pickle方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">87</span>]: frame = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: frame</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: frame.to_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br></pre></td></tr></table></figure><p>你可以通过pickle直接读取被pickle化的数据，或是使用更为方便的pandas.read_pickle：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">90</span>]: pd.read_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><blockquote><p>注意：pickle仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的；今天pickle的对象可能无法被后续版本的库unpickle出来。虽然我尽力保证这种事情不会发生在pandas中，但是今后的某个时候说不定还是得“打破”该pickle格式。</p></blockquote><p>pandas内置支持两个二进制数据格式：HDF5和MessagePack。下一节，我会给出几个HDF5的例子，但我建议你尝试下不同的文件格式，看看它们的速度以及是否适合你的分析工作。pandas或NumPy数据的其它存储格式有：</p><ul><li>bcolz：一种可压缩的列存储二进制格式，基于Blosc压缩库。</li><li>Feather：我与R语言社区的Hadley Wickham设计的一种跨语言的列存储文件格式。Feather使用了Apache Arrow的列式内存格式。</li></ul><h2 id="使用HDF5格式"><a href="#使用HDF5格式" class="headerlink" title="使用HDF5格式"></a>使用HDF5格式</h2><p>HDF5是一种存储大规模科学数组数据的非常好的文件格式。它可以被作为C标准库，带有许多语言的接口，如Java、Python和MATLAB等。HDF5中的HDF指的是层次型数据格式（hierarchical data format）。每个HDF5文件都含有一个文件系统式的节点结构，它使你能够存储多个数据集并支持元数据。与其他简单格式相比，HDF5支持多种压缩器的即时压缩，还能更高效地存储重复模式数据。对于那些非常大的无法直接放入内存的数据集，HDF5就是不错的选择，因为它可以高效地分块读写。</p><p>虽然可以用PyTables或h5py库直接访问HDF5文件，pandas提供了更为高级的接口，可以简化存储Series和DataFrame对象。HDFStore类可以像字典一样，处理低级的细节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">92</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: store = pd.HDFStore(<span class="string">&#x27;mydata.h5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: store[<span class="string">&#x27;obj1&#x27;</span>] = frame</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: store[<span class="string">&#x27;obj1_col&#x27;</span>] = frame[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: store</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.io.pytables.HDFStore&#x27;</span>&gt;</span><br><span class="line">File path: mydata.h5</span><br><span class="line">/obj1                frame        (shape-&gt;[<span class="number">100</span>,<span class="number">1</span>])                               </span><br><span class="line">        </span><br><span class="line">/obj1_col            series       (shape-&gt;[<span class="number">100</span>])                                 </span><br><span class="line">        </span><br><span class="line">/obj2                frame_table  (typ-&gt;appendable,nrows-&gt;<span class="number">100</span>,ncols-&gt;<span class="number">1</span>,indexers-&gt;</span><br><span class="line">[index])</span><br><span class="line">/obj3                frame_table  (typ-&gt;appendable,nrows-&gt;<span class="number">100</span>,ncols-&gt;<span class="number">1</span>,indexers-&gt;</span><br><span class="line">[index])</span><br></pre></td></tr></table></figure><p>HDF5文件中的对象可以通过与字典一样的API进行获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: store[<span class="string">&#x27;obj1&#x27;</span>]</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">           a</span><br><span class="line"><span class="number">0</span>  -<span class="number">0.204708</span></span><br><span class="line"><span class="number">1</span>   <span class="number">0.478943</span></span><br><span class="line"><span class="number">2</span>  -<span class="number">0.519439</span></span><br><span class="line"><span class="number">3</span>  -<span class="number">0.555730</span></span><br><span class="line"><span class="number">4</span>   <span class="number">1.965781</span></span><br><span class="line">..       ...</span><br><span class="line"><span class="number">95</span>  <span class="number">0.795253</span></span><br><span class="line"><span class="number">96</span>  <span class="number">0.118110</span></span><br><span class="line"><span class="number">97</span> -<span class="number">0.748532</span></span><br><span class="line"><span class="number">98</span>  <span class="number">0.584970</span></span><br><span class="line"><span class="number">99</span>  <span class="number">0.152677</span></span><br><span class="line">[<span class="number">100</span> rows x <span class="number">1</span> columns]</span><br></pre></td></tr></table></figure><p>HDFStore支持两种存储模式，’fixed’和’table’。后者通常会更慢，但是支持使用特殊语法进行查询操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">98</span>]: store.put(<span class="string">&#x27;obj2&#x27;</span>, frame, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: store.select(<span class="string">&#x27;obj2&#x27;</span>, where=[<span class="string">&#x27;index &gt;= 10 and index &lt;= 15&#x27;</span>])</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">           a</span><br><span class="line"><span class="number">10</span>  <span class="number">1.007189</span></span><br><span class="line"><span class="number">11</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">12</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">13</span>  <span class="number">0.228913</span></span><br><span class="line"><span class="number">14</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">15</span>  <span class="number">0.886429</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: store.close()</span><br></pre></td></tr></table></figure><p>put是store[‘obj2’] &#x3D; frame方法的显示版本，允许我们设置其它的选项，比如格式。</p><p>pandas.read_hdf函数可以快捷使用这些工具：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">101</span>]: frame.to_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: pd.read_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, where=[<span class="string">&#x27;index &lt; 5&#x27;</span>])</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">          a</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span></span><br></pre></td></tr></table></figure><blockquote><p>笔记：如果你要处理的数据位于远程服务器，比如Amazon S3或HDFS，使用专门为分布式存储（比如Apache Parquet）的二进制格式也许更加合适。Python的Parquet和其它存储格式还在不断的发展之中，所以这本书中没有涉及。</p></blockquote><p>如果需要本地处理海量数据，我建议你好好研究一下PyTables和h5py，看看它们能满足你的哪些需求。。由于许多数据分析问题都是IO密集型（而不是CPU密集型），利用HDF5这样的工具能显著提升应用程序的效率。</p><blockquote><p>注意：HDF5不是数据库。它最适合用作“一次写多次读”的数据集。虽然数据可以在任何时候被添加到文件中，但如果同时发生多个写操作，文件就可能会被破坏。</p></blockquote><h2 id="读取Microsoft-Excel文件"><a href="#读取Microsoft-Excel文件" class="headerlink" title="读取Microsoft Excel文件"></a>读取Microsoft Excel文件</h2><p>pandas的ExcelFile类或pandas.read_excel函数支持读取存储在Excel 2003（或更高版本）中的表格型数据。这两个工具分别使用扩展包xlrd和openpyxl读取XLS和XLSX文件。你可以用pip或conda安装它们。</p><p>要使用ExcelFile，通过传递xls或xlsx路径创建一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">104</span>]: xlsx = pd.ExcelFile(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><p>存储在表单中的数据可以read_excel读取到DataFrame（原书这里写的是用parse解析，但代码中用的是read_excel，是个笔误：只换了代码，没有改文字）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">105</span>]: pd.read_excel(xlsx, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>如果要读取一个文件中的多个表单，创建ExcelFile会更快，但你也可以将文件名传递到pandas.read_excel：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">106</span>]: frame = pd.read_excel(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: frame</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure><p>如果要将pandas数据写入为Excel格式，你必须首先创建一个ExcelWriter，然后使用pandas对象的to_excel方法将数据写入到其中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">108</span>]: writer = pd.ExcelWriter(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: frame.to_excel(writer, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: writer.save()</span><br></pre></td></tr></table></figure><p>你还可以不使用ExcelWriter，而是传递文件的路径到to_excel：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">111</span>]: frame.to_excel(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="6-3-Web-APIs交互"><a href="#6-3-Web-APIs交互" class="headerlink" title="6.3 Web APIs交互"></a>6.3 Web APIs交互</h1><p>许多网站都有一些通过JSON或其他格式提供数据的公共API。通过Python访问这些API的办法有不少。一个简单易用的办法（推荐）是requests包（<a href="http://docs.python-requests.org)./">http://docs.python-requests.org）。</a></p><p>为了搜索最新的30个GitHub上的pandas主题，我们可以发一个HTTP GET请求，使用requests扩展库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">113</span>]: <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: url = <span class="string">&#x27;https://api.github.com/repos/pandas-dev/pandas/issues&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: resp</span><br><span class="line">Out[<span class="number">116</span>]: &lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p>响应对象的json方法会返回一个包含被解析过的JSON字典，加载到一个Python对象中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: data = resp.json()</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: data[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">Out[<span class="number">118</span>]: <span class="string">&#x27;Period does not round down for frequencies less that 1 hour&#x27;</span></span><br></pre></td></tr></table></figure><p>data中的每个元素都是一个包含所有GitHub主题页数据（不包含评论）的字典。我们可以直接传递数据到DataFrame，并提取感兴趣的字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">119</span>]: issues = pd.DataFrame(data, columns=[<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">   .....:                                      <span class="string">&#x27;labels&#x27;</span>, <span class="string">&#x27;state&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: issues</span><br><span class="line">Out[<span class="number">120</span>]:</span><br><span class="line">    number                                              title  \</span><br><span class="line"><span class="number">0</span>    <span class="number">17666</span>  Period does <span class="keyword">not</span> <span class="built_in">round</span> down <span class="keyword">for</span> frequencies les...   </span><br><span class="line"><span class="number">1</span>    <span class="number">17665</span>           DOC: improve docstring of function where   </span><br><span class="line"><span class="number">2</span>    <span class="number">17664</span>               COMPAT: skip <span class="number">32</span>-bit test on <span class="built_in">int</span> <span class="built_in">repr</span>   </span><br><span class="line"><span class="number">3</span>    <span class="number">17662</span>                          implement Delegator <span class="keyword">class</span></span><br><span class="line"><span class="number">4</span>    <span class="number">17654</span>  BUG: Fix series rename called <span class="keyword">with</span> <span class="built_in">str</span> alterin...   </span><br><span class="line">..     ...                                                ...   </span><br><span class="line"><span class="number">25</span>   <span class="number">17603</span>  BUG: Correctly localize naive datetime strings...   </span><br><span class="line"><span class="number">26</span>   <span class="number">17599</span>                     core.dtypes.generic --&gt; cython   </span><br><span class="line"><span class="number">27</span>   <span class="number">17596</span>   Merge cdate_range functionality into bdate_range   </span><br><span class="line"><span class="number">28</span>   <span class="number">17587</span>  Time Grouper bug fix when applied <span class="keyword">for</span> <span class="built_in">list</span> gro...   </span><br><span class="line"><span class="number">29</span>   <span class="number">17583</span>  BUG: fix tz-aware DatetimeIndex + TimedeltaInd...   </span><br><span class="line">                                               labels state  </span><br><span class="line"><span class="number">0</span>                                                  []  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">1</span>   [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">134699</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com...  open  </span></span><br><span class="line"><span class="string">2   [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 563047854, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github....  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">3</span>                                                  []  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">4</span>   [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">76811</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com/...  open  </span></span><br><span class="line"><span class="string">..                                                ...   ...  </span></span><br><span class="line"><span class="string">25  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 76811, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.com/...  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">26</span>  [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">49094459</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.c...  open  </span></span><br><span class="line"><span class="string">27  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 35818298, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.c...  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">28</span>  [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">233160</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com...  open  </span></span><br><span class="line"><span class="string">29  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 76811, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.com/...  <span class="built_in">open</span>  </span><br><span class="line">[<span class="number">30</span> rows x <span class="number">4</span> columns]</span><br></pre></td></tr></table></figure><p>花费一些精力，你就可以创建一些更高级的常见的Web API的接口，返回DataFrame对象，方便进行分析。</p><h1 id="6-4-数据库交互"><a href="#6-4-数据库交互" class="headerlink" title="6.4 数据库交互"></a>6.4 数据库交互</h1><p>在商业场景下，大多数数据可能不是存储在文本或Excel文件中。基于SQL的关系型数据库（如SQL Server、PostgreSQL和MySQL等）使用非常广泛，其它一些数据库也很流行。数据库的选择通常取决于性能、数据完整性以及应用程序的伸缩性需求。</p><p>将数据从SQL加载到DataFrame的过程很简单，此外pandas还有一些能够简化该过程的函数。例如，我将使用SQLite数据库（通过Python内置的sqlite3驱动器）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">121</span>]: <span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   .....: CREATE TABLE test</span></span><br><span class="line"><span class="string">   .....: (a VARCHAR(20), b VARCHAR(20),</span></span><br><span class="line"><span class="string">   .....:  c REAL,        d INTEGER</span></span><br><span class="line"><span class="string">   .....: );&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: con = sqlite3.connect(<span class="string">&#x27;mydata.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: con.execute(query)</span><br><span class="line">Out[<span class="number">124</span>]: &lt;sqlite3.Cursor at <span class="number">0x7f6b12a50f10</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: con.commit()</span><br></pre></td></tr></table></figure><p>然后插入几行数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">126</span>]: data = [(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line">   .....:         (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line">   .....:         (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: stmt = <span class="string">&quot;INSERT INTO test VALUES(?, ?, ?, ?)&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: con.executemany(stmt, data)</span><br><span class="line">Out[<span class="number">128</span>]: &lt;sqlite3.Cursor at <span class="number">0x7f6b15c66ce0</span>&gt;</span><br></pre></td></tr></table></figure><p>从表中选取数据时，大部分Python SQL驱动器（PyODBC、psycopg2、MySQLdb、pymssql等）都会返回一个元组列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">130</span>]: cursor = con.execute(<span class="string">&#x27;select * from test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: rows = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: rows</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">[(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line"> (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p>你可以将这个元组列表传给DataFrame构造器，但还需要列名（位于光标的description属性中）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">133</span>]: cursor.description</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">((<span class="string">&#x27;a&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;b&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;c&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;d&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: pd.DataFrame(rows, columns=[x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cursor.description])</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">             a           b     c  d</span><br><span class="line"><span class="number">0</span>      Atlanta     Georgia  <span class="number">1.25</span>  <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  Tallahassee     Florida  <span class="number">2.60</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   Sacramento  California  <span class="number">1.70</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这种数据规整操作相当多，你肯定不想每查一次数据库就重写一次。<a href="http://www.sqlalchemy.org/">SQLAlchemy项目</a>是一个流行的Python SQL工具，它抽象出了SQL数据库中的许多常见差异。pandas有一个read_sql函数，可以让你轻松的从SQLAlchemy连接读取数据。这里，我们用SQLAlchemy连接SQLite数据库，并从之前创建的表读取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">135</span>]: <span class="keyword">import</span> sqlalchemy <span class="keyword">as</span> sqla</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: db = sqla.create_engine(<span class="string">&#x27;sqlite:///mydata.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: pd.read_sql(<span class="string">&#x27;select * from test&#x27;</span>, db)</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">             a           b     c  d</span><br><span class="line"><span class="number">0</span>      Atlanta     Georgia  <span class="number">1.25</span>  <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  Tallahassee     Florida  <span class="number">2.60</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   Sacramento  California  <span class="number">1.70</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h1><p>访问数据通常是数据分析的第一步。在本章中，我们已经学了一些有用的工具。在接下来的章节中，我们将深入研究数据规整、数据可视化、时间序列分析和其它主题。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC05%E7%AB%A0%20pandas%E5%85%A5%E9%97%A8/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC05%E7%AB%A0%20pandas%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>pandas是本书后续内容的首选库。它含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。pandas经常和其它工具一同使用，如数值计算工具NumPy和SciPy，分析库statsmodels和scikit-learn，和数据可视化库matplotlib。pandas是基于NumPy数组构建的，特别是基于数组的函数和不使用for循环的数据处理。</p><p>虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是pandas是专门为处理表格和混杂数据设计的。而NumPy更适合处理统一的数值数组数据。</p><p>自从2010年pandas开源以来，pandas逐渐成长为一个非常大的库，应用于许多真实案例。开发者社区已经有了800个独立的贡献者，他们在解决日常数据问题的同时为这个项目提供贡献。</p><p>在本书后续部分中，我将使用下面这样的pandas引入约定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><p>因此，只要你在代码中看到pd.，就得想到这是pandas。因为Series和DataFrame用的次数非常多，所以将其引入本地命名空间中会更方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure><h1 id="5-1-pandas的数据结构介绍"><a href="#5-1-pandas的数据结构介绍" class="headerlink" title="5.1 pandas的数据结构介绍"></a>5.1 pandas的数据结构介绍</h1><p>要使用pandas，你首先就得熟悉它的两个主要数据结构：Series和DataFrame。虽然它们并不能解决所有问题，但它们为大多数应用提供了一种可靠的、易于使用的基础。</p><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: obj</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: obj.values</span><br><span class="line">Out[<span class="number">13</span>]: array([ <span class="number">4</span>,  <span class="number">7</span>, -<span class="number">5</span>,  <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: obj.index  <span class="comment"># like range(4)</span></span><br><span class="line">Out[<span class="number">14</span>]: RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: obj2</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: obj2.index</span><br><span class="line">Out[<span class="number">17</span>]: Index([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: obj2[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">18</span>]: -<span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: obj2[<span class="string">&#x27;d&#x27;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: obj2[[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>[‘c’, ‘a’, ‘d’]是索引列表，即使它包含的是字符串而不是整数。</p><p>使用NumPy函数或类似NumPy的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: obj2[obj2 &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: obj2 * <span class="number">2</span></span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">d    <span class="number">12</span></span><br><span class="line">b    <span class="number">14</span></span><br><span class="line">a   -<span class="number">10</span></span><br><span class="line">c     <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: np.exp(obj2)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">d     <span class="number">403.428793</span></span><br><span class="line">b    <span class="number">1096.633158</span></span><br><span class="line">a       <span class="number">0.006738</span></span><br><span class="line">c      <span class="number">20.085537</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>还可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">26</span>]: sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: obj3</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。你可以传入排好序的字典的键以改变顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: states = [<span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: obj4</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于”California”所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p><p>我将使用缺失（missing）或NA表示缺失数据。pandas的isnull和notnull函数可用于检测缺失数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">California    <span class="literal">False</span></span><br><span class="line">Ohio           <span class="literal">True</span></span><br><span class="line">Oregon         <span class="literal">True</span></span><br><span class="line">Texas          <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><p>Series也有类似的实例方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: obj4.isnull()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><p>我将在第7章详细讲解如何处理缺失数据。</p><p>对于许多应用而言，Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: obj3</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: obj4</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="number">70000.0</span></span><br><span class="line">Oregon         <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>数据对齐功能将在后面详细讲解。如果你使用过数据库，你可以认为是类似join的操作。</p><p>Series对象本身及其索引都有一个name属性，该属性跟pandas其他的关键功能关系非常密切：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: obj4.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: obj4.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: obj4</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure><p>Series的索引可以通过赋值的方式就地修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">Bob      <span class="number">4</span></span><br><span class="line">Steve    <span class="number">7</span></span><br><span class="line">Jeff    -<span class="number">5</span></span><br><span class="line">Ryan     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。有关DataFrame内部的技术细节远远超出了本书所讨论的范围。</p><blockquote><p>笔记：虽然DataFrame是以二维结构保存数据的，但你仍然可以轻松地将其表示为更高维度的数据（层次化索引的表格型结构，这是pandas中许多高级数据处理功能的关键要素，我们会在第8章讨论这个问题）。</p></blockquote><p>建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><p>结果DataFrame会自动加上索引（跟Series一样），且全部列会被有序排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: frame</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br><span class="line"><span class="number">5</span>  <span class="number">3.2</span>  Nevada  <span class="number">2003</span></span><br></pre></td></tr></table></figure><p>如果你使用的是Jupyter notebook，pandas DataFrame对象会以对浏览器友好的HTML表格的方式呈现。</p><p>对于特别大的DataFrame，head方法会选取前五行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: frame.head()</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br></pre></td></tr></table></figure><p>如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">47</span>]: pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>])</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">   year   state  pop</span><br><span class="line"><span class="number">0</span>  <span class="number">2000</span>    Ohio  <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2001</span>    Ohio  <span class="number">1.7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2002</span>    Ohio  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2001</span>  Nevada  <span class="number">2.4</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2002</span>  Nevada  <span class="number">2.9</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2003</span>  Nevada  <span class="number">3.2</span></span><br></pre></td></tr></table></figure><p>如果传入的列在数据中找不到，就会在结果中产生缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">48</span>]: frame2 = pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>,</span><br><span class="line">   ....:                              <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: frame2</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">       year   state  pop debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  NaN</span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  NaN</span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  NaN</span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">50</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: frame2[<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: frame2.year</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">one      <span class="number">2000</span></span><br><span class="line">two      <span class="number">2001</span></span><br><span class="line">three    <span class="number">2002</span></span><br><span class="line">four     <span class="number">2001</span></span><br><span class="line">five     <span class="number">2002</span></span><br><span class="line">six      <span class="number">2003</span></span><br><span class="line">Name: year, dtype: int64</span><br></pre></td></tr></table></figure><blockquote><p>笔记：IPython提供了类似属性的访问（即frame2.year）和tab补全。<br>frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</p></blockquote><p>注意，返回的Series拥有原DataFrame相同的索引，且其name属性也已经被相应地设置好了。</p><p>行也可以通过位置或名称的方式进行获取，比如用loc属性（稍后将对此进行详细讲解）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">53</span>]: frame2.loc[<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">year     <span class="number">2002</span></span><br><span class="line">state    Ohio</span><br><span class="line">pop       <span class="number">3.6</span></span><br><span class="line">debt      NaN</span><br><span class="line">Name: three, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>列可以通过赋值的方式进行修改。例如，我们可以给那个空的”debt”列赋上一个标量值或一组值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: frame2</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  <span class="number">16.5</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">16.5</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  <span class="number">16.5</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">16.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">16.5</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: frame2</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   <span class="number">0.0</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>   <span class="number">1.0</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   <span class="number">2.0</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>   <span class="number">3.0</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>   <span class="number">4.0</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   <span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">58</span>]: val = pd.Series([-<span class="number">1.2</span>, -<span class="number">1.5</span>, -<span class="number">1.7</span>], index=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = val</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: frame2</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN</span><br></pre></td></tr></table></figure><p>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</p><p>作为del的例子，我先添加一个新的布尔值的列，state是否为’Ohio’：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">61</span>]: frame2[<span class="string">&#x27;eastern&#x27;</span>] = frame2.state == <span class="string">&#x27;Ohio&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: frame2</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">       year   state  pop  debt  eastern</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN     <span class="literal">True</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span>     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span>    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span>    <span class="literal">False</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN    <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：不能用frame2.eastern创建新的列。</p></blockquote><p>del方法可以用来删除这列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: <span class="keyword">del</span> frame2[<span class="string">&#x27;eastern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，对返回的Series所做的任何就地修改全都会反映到源DataFrame上。通过Series的copy方法即可指定复制列。</p></blockquote><p>另一种常见的数据形式是嵌套字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">65</span>]: pop = &#123;<span class="string">&#x27;Nevada&#x27;</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,</span><br><span class="line">....:        <span class="string">&#x27;Ohio&#x27;</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>如果嵌套字典传给DataFrame，pandas就会被解释为：外层字典的键作为列，内层键则作为行索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: frame3 = pd.DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: frame3</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure><p>你也可以使用类似NumPy数组的方法，对DataFrame进行转置（交换行和列）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: frame3.T</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">        <span class="number">2000</span>  <span class="number">2001</span>  <span class="number">2002</span></span><br><span class="line">Nevada   NaN   <span class="number">2.4</span>   <span class="number">2.9</span></span><br><span class="line">Ohio     <span class="number">1.5</span>   <span class="number">1.7</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure><p>内层字典的键会被合并、排序以形成最终的索引。如果明确指定了索引，则不会这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: pd.DataFrame(pop, index=[<span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>])</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"><span class="number">2003</span>     NaN   NaN</span><br></pre></td></tr></table></figure><p>由Series组成的字典差不多也是一样的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">70</span>]: pdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: frame3[<span class="string">&#x27;Ohio&#x27;</span>][:-<span class="number">1</span>],</span><br><span class="line">....:          <span class="string">&#x27;Nevada&#x27;</span>: frame3[<span class="string">&#x27;Nevada&#x27;</span>][:<span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: pd.DataFrame(pdata)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br></pre></td></tr></table></figure><p>表5-1列出了DataFrame构造函数所能接受的各种数据。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-106835b28c0cea5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">72</span>]: frame3.index.name = <span class="string">&#x27;year&#x27;</span>; frame3.columns.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: frame3</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year</span><br><span class="line"><span class="number">2000</span>      NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">2.9</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure><p>跟Series一样，values属性也会以二维ndarray的形式返回DataFrame中的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: frame3.values</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">array([[ nan,  <span class="number">1.5</span>],</span><br><span class="line">       [ <span class="number">2.4</span>,  <span class="number">1.7</span>],</span><br><span class="line">       [ <span class="number">2.9</span>,  <span class="number">3.6</span>]])</span><br></pre></td></tr></table></figure><p>如果DataFrame各列的数据类型不同，则值数组的dtype就会选用能兼容所有列的数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">75</span>]: frame2.values</span><br><span class="line">Out[<span class="number">75</span>]:</span><br><span class="line">array([[<span class="number">2000</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">1.5</span>, nan],</span><br><span class="line">       [<span class="number">2001</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">1.7</span>, -<span class="number">1.2</span>],</span><br><span class="line">       [<span class="number">2002</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">3.6</span>, nan],</span><br><span class="line">       [<span class="number">2001</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2.4</span>, -<span class="number">1.5</span>],</span><br><span class="line">       [<span class="number">2002</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2.9</span>, -<span class="number">1.7</span>],</span><br><span class="line">       [<span class="number">2003</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">3.2</span>, nan]], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><h2 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h2><p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">76</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: index = obj.index</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: index</span><br><span class="line">Out[<span class="number">78</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: index[<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: Index([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Index对象是不可变的，因此用户不能对其进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index[<span class="number">1</span>] = <span class="string">&#x27;d&#x27;</span>  <span class="comment"># TypeError</span></span><br></pre></td></tr></table></figure><p>不可变可以使Index对象在多个数据结构之间安全共享：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">80</span>]: labels = pd.Index(np.arange(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: labels</span><br><span class="line">Out[<span class="number">81</span>]: Int64Index([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: obj2 = pd.Series([<span class="number">1.5</span>, -<span class="number">2.5</span>, <span class="number">0</span>], index=labels)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: obj2</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">2.5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: obj2.index <span class="keyword">is</span> labels</span><br><span class="line">Out[<span class="number">84</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：虽然用户不需要经常使用Index的功能，但是因为一些操作会生成包含被索引化的数据，理解它们的工作原理是很重要的。</p></blockquote><p>除了类似于数组，Index的功能也类似一个固定大小的集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">85</span>]: frame3</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year               </span><br><span class="line"><span class="number">2000</span>      NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line">In [<span class="number">86</span>]: frame3.columns</span><br><span class="line">Out[<span class="number">86</span>]: Index([<span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>, name=<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: <span class="string">&#x27;Ohio&#x27;</span> <span class="keyword">in</span> frame3.columns</span><br><span class="line">Out[<span class="number">87</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: <span class="number">2003</span> <span class="keyword">in</span> frame3.index</span><br><span class="line">Out[<span class="number">88</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>与python的集合不同，pandas的Index可以包含重复的标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">89</span>]: dup_labels = pd.Index([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: dup_labels</span><br><span class="line">Out[<span class="number">90</span>]: Index([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p>选择重复的标签，会显示所有的结果。</p><p>每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。表5-2列出了这些函数。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-5499d14f0e2cd639.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="5-2-基本功能"><a href="#5-2-基本功能" class="headerlink" title="5.2 基本功能"></a>5.2 基本功能</h1><p>本节中，我将介绍操作Series和DataFrame中的数据的基本手段。后续章节将更加深入地挖掘pandas在数据分析和处理方面的功能。本书不是pandas库的详尽文档，主要关注的是最重要的功能，那些不大常用的内容（也就是那些更深奥的内容）就交给你自己去摸索吧。</p><h2 id="重新索引"><a href="#重新索引" class="headerlink" title="重新索引"></a>重新索引</h2><p>pandas对象的一个重要方法是reindex，其作用是创建一个新对象，它的数据符合新的索引。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">91</span>]: obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, -<span class="number">5.3</span>, <span class="number">3.6</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: obj</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>用该Series的reindex将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">93</span>]: obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: obj2</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method选项即可达到此目的，例如，使用ffill可以实现前向值填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">95</span>]: obj3 = pd.Series([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: obj3</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: obj3.reindex(<span class="built_in">range</span>(<span class="number">6</span>), method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">1</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">3</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line"><span class="number">5</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>借助DataFrame，reindex可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">98</span>]: frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: frame</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: frame2 = frame.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: frame2</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="number">0.0</span>    <span class="number">1.0</span>         <span class="number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="number">3.0</span>    <span class="number">4.0</span>         <span class="number">5.0</span></span><br><span class="line">d   <span class="number">6.0</span>    <span class="number">7.0</span>         <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p>列可以用columns关键字重新索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">102</span>]: states = [<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;California&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: frame.reindex(columns=states)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      <span class="number">1</span>   NaN           <span class="number">2</span></span><br><span class="line">c      <span class="number">4</span>   NaN           <span class="number">5</span></span><br><span class="line">d      <span class="number">7</span>   NaN           <span class="number">8</span></span><br></pre></td></tr></table></figure><p>表5-3列出了reindex函数的各参数及说明。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-efa3dbd4b83c61ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="丢弃指定轴上的项"><a href="#丢弃指定轴上的项" class="headerlink" title="丢弃指定轴上的项"></a>丢弃指定轴上的项</h2><p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以drop方法返回的是一个在指定轴上删除了指定值的新对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">105</span>]: obj = pd.Series(np.arange(<span class="number">5.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: obj</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: new_obj = obj.drop(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: new_obj</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: obj.drop([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>对于DataFrame，可以删除任意轴上的索引值。为了演示，先新建一个DataFrame例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">110</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: data</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><p>用标签序列调用drop会从行标签（axis 0）删除值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">112</span>]: data.drop([<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><p>通过传递axis&#x3D;1或axis&#x3D;’columns’可以删除列的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data.drop(<span class="string">&#x27;two&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data.drop([<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>], axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">          one  three</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure><p>许多函数，如drop，会修改Series或DataFrame的大小或形状，可以就地修改对象，不会返回新的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">115</span>]: obj.drop(<span class="string">&#x27;c&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: obj</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>小心使用inplace，它会销毁所有被删除的数据。</p><h2 id="索引、选取和过滤"><a href="#索引、选取和过滤" class="headerlink" title="索引、选取和过滤"></a>索引、选取和过滤</h2><p>Series索引（obj[…]）的工作方式类似于NumPy数组的索引，只不过Series的索引值不只是整数。下面是几个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: obj</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: obj[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">119</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">120</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: obj[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">122</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: obj[[<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: obj[obj &lt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>利用标签的切片运算与普通的Python切片运算不同，其末端是包含的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">125</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">125</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>用切片可以对Series的相应部分进行设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">126</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: obj</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">5.0</span></span><br><span class="line">c    <span class="number">5.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>用一个值或序列对DataFrame进行索引其实就是获取一个或多个列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">Ohio         <span class="number">1</span></span><br><span class="line">Colorado     <span class="number">5</span></span><br><span class="line">Utah         <span class="number">9</span></span><br><span class="line">New York    <span class="number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: data[[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>]]</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">          three  one</span><br><span class="line">Ohio          <span class="number">2</span>    <span class="number">0</span></span><br><span class="line">Colorado      <span class="number">6</span>    <span class="number">4</span></span><br><span class="line">Utah         <span class="number">10</span>    <span class="number">8</span></span><br><span class="line">New York     <span class="number">14</span>   <span class="number">12</span></span><br></pre></td></tr></table></figure><p>这种索引方式有几个特殊的情况。首先通过切片或布尔型数组选取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">132</span>]: data[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: data[data[<span class="string">&#x27;three&#x27;</span>] &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><p>选取行的语法data[:2]十分方便。向[ ]传递单一的元素或列表，就可选择列。</p><p>另一种用法是通过布尔型DataFrame（比如下面这个由标量比较运算得出的）进行索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">134</span>]: data &lt; <span class="number">5</span></span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">            one    two  three   four</span><br><span class="line">Ohio       <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span></span><br><span class="line">Colorado   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">Utah      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">New York  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: data[data &lt; <span class="number">5</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: data</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><p>这使得DataFrame的语法与NumPy二维数组的语法很像。</p><h2 id="用loc和iloc进行选取"><a href="#用loc和iloc进行选取" class="headerlink" title="用loc和iloc进行选取"></a>用loc和iloc进行选取</h2><p>对于DataFrame的行的标签索引，我引入了特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p><p>作为一个初步示例，让我们通过标签选择一行和多列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">137</span>]: data.loc[<span class="string">&#x27;Colorado&#x27;</span>, [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br></pre></td></tr></table></figure><p>然后用iloc和整数进行选取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">four    <span class="number">11</span></span><br><span class="line">one      <span class="number">8</span></span><br><span class="line">two      <span class="number">9</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: data.iloc[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">one       <span class="number">8</span></span><br><span class="line">two       <span class="number">9</span></span><br><span class="line">three    <span class="number">10</span></span><br><span class="line">four     <span class="number">11</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: data.iloc[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">          four  one  two</span><br><span class="line">Colorado     <span class="number">7</span>    <span class="number">0</span>    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">11</span>    <span class="number">8</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure><p>这两个索引函数也适用于一个标签或多个标签的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">141</span>]: data.loc[:<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">141</span>]: </span><br><span class="line">Ohio        <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">9</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">142</span>]: </span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure><p>所以，在pandas中，有多个方法可以选取和重新组合数据。对于DataFrame，表5-4进行了总结。后面会看到，还有更多的方法进行层级化索引。</p><blockquote><p>笔记：在一开始设计pandas时，我觉得用frame[:, col]选取列过于繁琐（也容易出错），因为列的选择是非常常见的操作。我做了些取舍，将花式索引的功能（标签和整数）放到了ix运算符中。在实践中，这会导致许多边缘情况，数据的轴标签是整数，所以pandas团队决定创造loc和iloc运算符分别处理严格基于标签和整数的索引。<br>ix运算符仍然可用，但并不推荐。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7178691-64354f2ab777bd8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-4 DataFrame的索引选项"></p><h2 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h2><p>处理整数索引的pandas对象常常难住新手，因为它与Python内置的列表和元组的索引语法不同。例如，你可能不认为下面的代码会出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ser = pd.Series(np.arange(<span class="number">3.</span>))</span><br><span class="line">ser</span><br><span class="line">ser[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这里，pandas可以勉强进行整数索引，但是会导致小bug。我们有包含0,1,2的索引，但是引入用户想要的东西（基于标签或位置的索引）很难：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">144</span>]: ser</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>另外，对于非整数索引，不会产生歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">145</span>]: ser2 = pd.Series(np.arange(<span class="number">3.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: ser2[-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">146</span>]: <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>为了进行统一，如果轴索引含有整数，数据选取总会使用标签。为了更准确，请使用loc（标签）或iloc（整数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">147</span>]: ser[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">147</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: ser.loc[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: ser.iloc[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">149</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h2 id="算术运算和数据对齐"><a href="#算术运算和数据对齐" class="headerlink" title="算术运算和数据对齐"></a>算术运算和数据对齐</h2><p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">150</span>]: s1 = pd.Series([<span class="number">7.3</span>, -<span class="number">2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: s2 = pd.Series([-<span class="number">2.1</span>, <span class="number">3.6</span>, -<span class="number">1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],</span><br><span class="line">   .....:                index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: s1</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">a    <span class="number">7.3</span></span><br><span class="line">c   -<span class="number">2.5</span></span><br><span class="line">d    <span class="number">3.4</span></span><br><span class="line">e    <span class="number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: s2</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">a   -<span class="number">2.1</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">e   -<span class="number">1.5</span></span><br><span class="line">f    <span class="number">4.0</span></span><br><span class="line">g    <span class="number">3.1</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>将它们相加就会产生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">154</span>]: s1 + s2</span><br><span class="line">Out[<span class="number">154</span>]: </span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播。</p><p>对于DataFrame，对齐操作会同时发生在行和列上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bcd&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: df1</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df2</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>把它们相加后将会返回一个新的DataFrame，其索引和列为原来那两个DataFrame的并集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br></pre></td></tr></table></figure><p>因为’c’和’e’列均不在两个DataFrame对象中，在结果中以缺省值呈现。行也是同样。</p><p>如果DataFrame对象相加，没有共用的列或行标签，结果都会是空：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">160</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;B&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: df1</span><br><span class="line">Out[<span class="number">162</span>]: </span><br><span class="line">   A</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: df2</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">   B</span><br><span class="line"><span class="number">0</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: df1 - df2</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">    A   B</span><br><span class="line"><span class="number">0</span> NaN NaN</span><br><span class="line"><span class="number">1</span> NaN NaN</span><br></pre></td></tr></table></figure><h2 id="在算术方法中填充值"><a href="#在算术方法中填充值" class="headerlink" title="在算术方法中填充值"></a>在算术方法中填充值</h2><p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">165</span>]: df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: df2.loc[<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: df1</span><br><span class="line">Out[<span class="number">168</span>]: </span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: df2</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5.0</span>   NaN   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">12.0</span>  <span class="number">13.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure><p>将它们相加时，没有重叠的位置就会产生NA值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">170</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   NaN  <span class="number">13.0</span>  <span class="number">15.0</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span> NaN</span><br><span class="line"><span class="number">3</span>   NaN   NaN   NaN   NaN NaN</span><br></pre></td></tr></table></figure><p>使用df1的add方法，传入df2以及一个fill_value参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">171</span>]: df1.add(df2, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   <span class="number">5.0</span>  <span class="number">13.0</span>  <span class="number">15.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure><p>表5-5列出了Series和DataFrame的算术方法。它们每个都有一个副本，以字母r开头，它会翻转参数。因此这两个语句是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">172</span>]: <span class="number">1</span> / df1</span><br><span class="line">Out[<span class="number">172</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>       inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250000</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125000</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: df1.rdiv(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>       inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250000</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125000</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-5 灵活的算术方法"></p><p>与此类似，在对Series或DataFrame重新索引时，也可以指定一个填充值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">174</span>]: df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">     a    b     c     d  e</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="DataFrame和Series之间的运算"><a href="#DataFrame和Series之间的运算" class="headerlink" title="DataFrame和Series之间的运算"></a>DataFrame和Series之间的运算</h2><p>跟不同维度的NumPy数组一样，DataFrame和Series之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: arr</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr - arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure><p>当我们从arr减去arr[0]，每一行都会执行这个操作。这就叫做广播（broadcasting），附录A将对此进行详细讲解。DataFrame和Series之间的运算差不多也是如此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">179</span>]: frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                      columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: series = frame.iloc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: frame</span><br><span class="line">Out[<span class="number">181</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">182</span>]: series</span><br><span class="line">Out[<span class="number">182</span>]: </span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br></pre></td></tr></table></figure><p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">183</span>]: frame - series</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br></pre></td></tr></table></figure><p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">184</span>]: series2 = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: frame + series2</span><br><span class="line">Out[<span class="number">185</span>]: </span><br><span class="line">          b   d     e   f</span><br><span class="line">Utah    <span class="number">0.0</span> NaN   <span class="number">3.0</span> NaN</span><br><span class="line">Ohio    <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Texas   <span class="number">6.0</span> NaN   <span class="number">9.0</span> NaN</span><br><span class="line">Oregon  <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br></pre></td></tr></table></figure><p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">186</span>]: series3 = frame[<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: frame</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: series3</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">Utah       <span class="number">1.0</span></span><br><span class="line">Ohio       <span class="number">4.0</span></span><br><span class="line">Texas      <span class="number">7.0</span></span><br><span class="line">Oregon    <span class="number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: frame.sub(series3, axis=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Ohio   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Texas  -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Oregon -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis&#x3D;’index’ or axis&#x3D;0）并进行广播。</p><h2 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h2><p>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">190</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: frame</span><br><span class="line">Out[<span class="number">191</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah   -<span class="number">0.204708</span>  <span class="number">0.478943</span> -<span class="number">0.519439</span></span><br><span class="line">Ohio   -<span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: np.<span class="built_in">abs</span>(frame)</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">0.204708</span>  <span class="number">0.478943</span>  <span class="number">0.519439</span></span><br><span class="line">Ohio    <span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span>  <span class="number">1.296221</span></span><br></pre></td></tr></table></figure><p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">193</span>]: f = <span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">194</span>]: </span><br><span class="line">b    <span class="number">1.802165</span></span><br><span class="line">d    <span class="number">1.684034</span></span><br><span class="line">e    <span class="number">2.689627</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>这里的函数f，计算了一个Series的最大值和最小值的差，在frame的每列都执行了一次。结果是一个Series，使用frame的列作为索引。</p><p>如果传递axis&#x3D;’columns’到apply，这个函数会在每行执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">195</span>]: frame.apply(f, axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">195</span>]:</span><br><span class="line">Utah      <span class="number">0.998382</span></span><br><span class="line">Ohio      <span class="number">2.521511</span></span><br><span class="line">Texas     <span class="number">0.676115</span></span><br><span class="line">Oregon    <span class="number">2.542656</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>许多最为常见的数组统计功能都被实现成DataFrame的方法（如sum和mean），因此无需使用apply方法。</p><p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">196</span>]: <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">   .....:     <span class="keyword">return</span> pd.Series([x.<span class="built_in">min</span>(), x.<span class="built_in">max</span>()], index=[<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">197</span>]: </span><br><span class="line">            b         d         e</span><br><span class="line"><span class="built_in">min</span> -<span class="number">0.555730</span>  <span class="number">0.281746</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="built_in">max</span>  <span class="number">1.246435</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br></pre></td></tr></table></figure><p>元素级的Python函数也是可以用的。假如你想得到frame中各个浮点值的格式化字符串，使用applymap即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">198</span>]: <span class="built_in">format</span> = <span class="keyword">lambda</span> x: <span class="string">&#x27;%.2f&#x27;</span> % x</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: frame.applymap(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line">            b     d      e</span><br><span class="line">Utah    -<span class="number">0.20</span>  <span class="number">0.48</span>  -<span class="number">0.52</span></span><br><span class="line">Ohio    -<span class="number">0.56</span>  <span class="number">1.97</span>   <span class="number">1.39</span></span><br><span class="line">Texas    <span class="number">0.09</span>  <span class="number">0.28</span>   <span class="number">0.77</span></span><br><span class="line">Oregon   <span class="number">1.25</span>  <span class="number">1.01</span>  -<span class="number">1.30</span></span><br></pre></td></tr></table></figure><p>之所以叫做applymap，是因为Series有一个用于应用元素级函数的map方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">200</span>]: frame[<span class="string">&#x27;e&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">Utah      -<span class="number">0.52</span></span><br><span class="line">Ohio       <span class="number">1.39</span></span><br><span class="line">Texas      <span class="number">0.77</span></span><br><span class="line">Oregon    -<span class="number">1.30</span></span><br><span class="line">Name: e, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><h2 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h2><p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用sort_index方法，它将返回一个已排序的新对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">201</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">202</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>对于DataFrame，则可以根据任意一个轴上的索引进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">203</span>]: frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="number">204</span>]: </span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">205</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">one    <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>数据默认是按升序排序的，但也可以降序排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">206</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">206</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><p>若要按值对Series进行排序，可使用其sort_values方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">207</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line"><span class="number">2</span>   -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>在排序时，任何缺失值默认都会被放到Series的末尾：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">209</span>]: obj = pd.Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line"><span class="number">4</span>   -<span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">211</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: frame</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">213</span>]: frame.sort_values(by=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">Out[<span class="number">213</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>要根据多个列进行排序，传入名称的列表即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">214</span>]: frame.sort_values(by=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">Out[<span class="number">214</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>排名会从1开始一直到数组中有效数据的数量。接下来介绍Series和DataFrame的rank方法。默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">215</span>]: obj = pd.Series([<span class="number">7</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">In [<span class="number">216</span>]: obj.rank()</span><br><span class="line">Out[<span class="number">216</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.5</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>也可以根据值在原数据中出现的顺序给出排名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">217</span>]: obj.rank(method=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">Out[<span class="number">217</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">5.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p><p>你也可以按降序进行排名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assign tie values the maximum rank in the group</span></span><br><span class="line">In [<span class="number">218</span>]: obj.rank(ascending=<span class="literal">False</span>, method=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>表5-6列出了所有用于破坏平级关系的method选项。DataFrame可以在行或列上计算排名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">219</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4.3</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">   .....:                       <span class="string">&#x27;c&#x27;</span>: [-<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">2.5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: frame</span><br><span class="line">Out[<span class="number">220</span>]: </span><br><span class="line">   a    b    c</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4.3</span> -<span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7.0</span>  <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3.0</span>  <span class="number">8.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2.0</span> -<span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">221</span>]: frame.rank(axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">221</span>]: </span><br><span class="line">     a    b    c</span><br><span class="line"><span class="number">0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">3.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.0</span>  <span class="number">1.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-6 排名时用于破坏平级关系的方法"></p><h2 id="带有重复标签的轴索引"><a href="#带有重复标签的轴索引" class="headerlink" title="带有重复标签的轴索引"></a>带有重复标签的轴索引</h2><p>直到目前为止，我所介绍的所有范例都有着唯一的轴标签（索引值）。虽然许多pandas函数（如reindex）都要求标签唯一，但这并不是强制性的。我们来看看下面这个简单的带有重复索引值的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">222</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">5</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">223</span>]: obj</span><br><span class="line">Out[<span class="number">223</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">b    <span class="number">3</span></span><br><span class="line">c    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>索引的is_unique属性可以告诉你它的值是否是唯一的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">224</span>]: obj.index.is_unique</span><br><span class="line">Out[<span class="number">224</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个Series；而对应单个值的，则返回一个标量值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">225</span>]: obj[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: obj[<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">226</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这样会使代码变复杂，因为索引的输出类型会根据标签是否有重复发生变化。</p><p>对DataFrame的行进行索引时也是如此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">227</span>]: df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">228</span>]: df</span><br><span class="line">Out[<span class="number">228</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line">a  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">a  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line">b  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line">b  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">229</span>]: df.loc[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line">b  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line">b  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br></pre></td></tr></table></figure><h1 id="5-3-汇总和计算描述统计"><a href="#5-3-汇总和计算描述统计" class="headerlink" title="5.3 汇总和计算描述统计"></a>5.3 汇总和计算描述统计</h1><p>pandas对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从Series中提取单个值（如sum或mean）或从DataFrame的行或列中提取一个Series。跟对应的NumPy数组方法相比，它们都是基于没有缺失数据的假设而构建的。看一个简单的DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">230</span>]: df = pd.DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, -<span class="number">4.5</span>],</span><br><span class="line">   .....:                    [np.nan, np.nan], [<span class="number">0.75</span>, -<span class="number">1.3</span>]],</span><br><span class="line">   .....:                   index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   .....:                   columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: df</span><br><span class="line">Out[<span class="number">231</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">7.10</span> -<span class="number">4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">0.75</span> -<span class="number">1.3</span></span><br></pre></td></tr></table></figure><p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">232</span>]: df.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">one    <span class="number">9.25</span></span><br><span class="line">two   -<span class="number">5.80</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>传入axis&#x3D;’columns’或axis&#x3D;1将会按行进行求和运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">233</span>]: df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">233</span>]:</span><br><span class="line">a    <span class="number">1.40</span></span><br><span class="line">b    <span class="number">2.60</span></span><br><span class="line">c     NaN</span><br><span class="line">d   -<span class="number">0.55</span></span><br></pre></td></tr></table></figure><p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">234</span>]: df.mean(axis=<span class="string">&#x27;columns&#x27;</span>, skipna=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">a      NaN</span><br><span class="line">b    <span class="number">1.300</span></span><br><span class="line">c      NaN</span><br><span class="line">d   -<span class="number">0.275</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>表5-7列出了这些约简方法的常用选项。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-af35e3809278410e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">235</span>]: df.idxmax()</span><br><span class="line">Out[<span class="number">235</span>]: </span><br><span class="line">one    b</span><br><span class="line">two    d</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>另一些方法则是累计型的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">236</span>]: df.cumsum()</span><br><span class="line">Out[<span class="number">236</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">8.50</span> -<span class="number">4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">9.25</span> -<span class="number">5.8</span></span><br></pre></td></tr></table></figure><p>还有一种方法，它既不是约简型也不是累计型。describe就是一个例子，它用于一次性产生多个汇总统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">237</span>]: df.describe()</span><br><span class="line">Out[<span class="number">237</span>]: </span><br><span class="line">            one       two</span><br><span class="line">count  <span class="number">3.000000</span>  <span class="number">2.000000</span></span><br><span class="line">mean   <span class="number">3.083333</span> -<span class="number">2.900000</span></span><br><span class="line">std    <span class="number">3.493685</span>  <span class="number">2.262742</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">0.750000</span> -<span class="number">4.500000</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">1.075000</span> -<span class="number">3.700000</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">1.400000</span> -<span class="number">2.900000</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">4.250000</span> -<span class="number">2.100000</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">7.100000</span> -<span class="number">1.300000</span></span><br></pre></td></tr></table></figure><p>对于非数值型数据，describe会产生另外一种汇总统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">238</span>]: obj = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: obj.describe()</span><br><span class="line">Out[<span class="number">239</span>]: </span><br><span class="line">count     <span class="number">16</span></span><br><span class="line">unique     <span class="number">3</span></span><br><span class="line">top        a</span><br><span class="line">freq       <span class="number">8</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>表5-8列出了所有与描述统计相关的方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="相关系数与协方差"><a href="#相关系数与协方差" class="headerlink" title="相关系数与协方差"></a>相关系数与协方差</h2><p>有些汇总统计（如相关系数和协方差）是通过参数对计算出来的。我们来看几个DataFrame，它们的数据来自Yahoo!Finance的股票价格和成交量，使用的是pandas-datareader包（可以用conda或pip安装）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pandas-datareader</span><br></pre></td></tr></table></figure><p>我使用pandas_datareader模块下载了一些股票数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> web</span><br><span class="line">all_data = &#123;ticker: web.get_data_yahoo(ticker)</span><br><span class="line">            <span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;GOOG&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">price = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Adj Close&#x27;</span>]</span><br><span class="line">                     <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br><span class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Volume&#x27;</span>]</span><br><span class="line">                      <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：此时Yahoo! Finance已经不存在了，因为2017年Yahoo!被Verizon收购了。参阅pandas-datareader文档，可以学习最新的功能。</p></blockquote><p>现在计算价格的百分数变化，时间序列的操作会在第11章介绍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">242</span>]: returns = price.pct_change()</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: returns.tail()</span><br><span class="line">Out[<span class="number">243</span>]: </span><br><span class="line">                AAPL      GOOG       IBM      MSFT</span><br><span class="line">Date                                              </span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">17</span> -<span class="number">0.000680</span>  <span class="number">0.001837</span>  <span class="number">0.002072</span> -<span class="number">0.003483</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">18</span> -<span class="number">0.000681</span>  <span class="number">0.019616</span> -<span class="number">0.026168</span>  <span class="number">0.007690</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">19</span> -<span class="number">0.002979</span>  <span class="number">0.007846</span>  <span class="number">0.003583</span> -<span class="number">0.002255</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span> -<span class="number">0.000512</span> -<span class="number">0.005652</span>  <span class="number">0.001719</span> -<span class="number">0.004867</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">21</span> -<span class="number">0.003930</span>  <span class="number">0.003011</span> -<span class="number">0.012474</span>  <span class="number">0.042096</span></span><br></pre></td></tr></table></figure><p>Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。与此类似，cov用于计算协方差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">244</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].corr(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">244</span>]: <span class="number">0.49976361144151144</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">245</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].cov(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">245</span>]: <span class="number">8.8706554797035462e-05</span></span><br></pre></td></tr></table></figure><p>因为MSTF是一个合理的Python属性，我们还可以用更简洁的语法选择列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">246</span>]: returns.MSFT.corr(returns.IBM)</span><br><span class="line">Out[<span class="number">246</span>]: <span class="number">0.49976361144151144</span></span><br></pre></td></tr></table></figure><p>另一方面，DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">247</span>]: returns.corr()</span><br><span class="line">Out[<span class="number">247</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">1.000000</span>  <span class="number">0.407919</span>  <span class="number">0.386817</span>  <span class="number">0.389695</span></span><br><span class="line">GOOG  <span class="number">0.407919</span>  <span class="number">1.000000</span>  <span class="number">0.405099</span>  <span class="number">0.465919</span></span><br><span class="line">IBM   <span class="number">0.386817</span>  <span class="number">0.405099</span>  <span class="number">1.000000</span>  <span class="number">0.499764</span></span><br><span class="line">MSFT  <span class="number">0.389695</span>  <span class="number">0.465919</span>  <span class="number">0.499764</span>  <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">248</span>]: returns.cov()</span><br><span class="line">Out[<span class="number">248</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">0.000277</span>  <span class="number">0.000107</span>  <span class="number">0.000078</span>  <span class="number">0.000095</span></span><br><span class="line">GOOG  <span class="number">0.000107</span>  <span class="number">0.000251</span>  <span class="number">0.000078</span>  <span class="number">0.000108</span></span><br><span class="line">IBM   <span class="number">0.000078</span>  <span class="number">0.000078</span>  <span class="number">0.000146</span>  <span class="number">0.000089</span></span><br><span class="line">MSFT  <span class="number">0.000095</span>  <span class="number">0.000108</span>  <span class="number">0.000089</span>  <span class="number">0.000215</span></span><br></pre></td></tr></table></figure><p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">249</span>]: returns.corrwith(returns.IBM)</span><br><span class="line">Out[<span class="number">249</span>]: </span><br><span class="line">AAPL    <span class="number">0.386817</span></span><br><span class="line">GOOG    <span class="number">0.405099</span></span><br><span class="line">IBM     <span class="number">1.000000</span></span><br><span class="line">MSFT    <span class="number">0.499764</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">250</span>]: returns.corrwith(volume)</span><br><span class="line">Out[<span class="number">250</span>]: </span><br><span class="line">AAPL   -<span class="number">0.075565</span></span><br><span class="line">GOOG   -<span class="number">0.007067</span></span><br><span class="line">IBM    -<span class="number">0.204849</span></span><br><span class="line">MSFT   -<span class="number">0.092950</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>传入axis&#x3D;’columns’即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p><h2 id="唯一值、值计数以及成员资格"><a href="#唯一值、值计数以及成员资格" class="headerlink" title="唯一值、值计数以及成员资格"></a>唯一值、值计数以及成员资格</h2><p>还有一类方法可以从一维Series的值中抽取信息。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">251</span>]: obj = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure><p>第一个函数是unique，它可以得到Series中的唯一值数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">252</span>]: uniques = obj.unique()</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: uniques</span><br><span class="line">Out[<span class="number">253</span>]: array([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>返回的唯一值是未排序的，如果需要的话，可以对结果再次进行排序（uniques.sort()）。相似的，value_counts用于计算一个Series中各值出现的频率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">254</span>]: obj.value_counts()</span><br><span class="line">Out[<span class="number">254</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">d    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>为了便于查看，结果Series是按值频率降序排列的。value_counts还是一个顶级pandas方法，可用于任何数组或序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">255</span>]: pd.value_counts(obj.values, sort=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">255</span>]: </span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>isin用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">256</span>]: obj</span><br><span class="line">Out[<span class="number">256</span>]: </span><br><span class="line"><span class="number">0</span>    c</span><br><span class="line"><span class="number">1</span>    a</span><br><span class="line"><span class="number">2</span>    d</span><br><span class="line"><span class="number">3</span>    a</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    b</span><br><span class="line"><span class="number">7</span>    c</span><br><span class="line"><span class="number">8</span>    c</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">257</span>]: mask = obj.isin([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">258</span>]: mask</span><br><span class="line">Out[<span class="number">258</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">7</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">8</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">259</span>]: obj[mask]</span><br><span class="line">Out[<span class="number">259</span>]: </span><br><span class="line"><span class="number">0</span>    c</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    b</span><br><span class="line"><span class="number">7</span>    c</span><br><span class="line"><span class="number">8</span>    c</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>与isin类似的是Index.get_indexer方法，它可以给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">260</span>]: to_match = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">261</span>]: unique_vals = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">262</span>]: pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line">Out[<span class="number">262</span>]: array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>表5-9给出了这几个方法的一些参考信息。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-b53c4a9d65a2db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表5-9 唯一值、值计数、成员资格方法"></p><p>有时，你可能希望得到DataFrame中多个相关列的一张柱状图。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">263</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;Qu1&#x27;</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">   .....:                      <span class="string">&#x27;Qu2&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">   .....:                      <span class="string">&#x27;Qu3&#x27;</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">264</span>]: data</span><br><span class="line">Out[<span class="number">264</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">4</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span>    <span class="number">3</span>    <span class="number">4</span></span><br></pre></td></tr></table></figure><p>将pandas.value_counts传给该DataFrame的apply函数，就会出现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">265</span>]: result = data.apply(pd.value_counts).fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">266</span>]: result</span><br><span class="line">Out[<span class="number">266</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.0</span>  <span class="number">2.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">2.0</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.0</span>  <span class="number">0.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>这里，结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数。</p><h1 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h1><p>在下一章，我们将讨论用pandas读取（或加载）和写入数据集的工具。</p><p>之后，我们将更深入地研究使用pandas进行数据清洗、规整、分析和可视化工具。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC04%E7%AB%A0%20NumPy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC04%E7%AB%A0%20NumPy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p><p>NumPy的部分功能如下：</p><ul><li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li><li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li><li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li><li>线性代数、随机数生成以及傅里叶变换功能。</li><li>用于集成由C、C++、Fortran等语言编写的代码的A C API。</li></ul><p>由于NumPy提供了一个简单易用的C API，因此很容易将数据传递给由低级语言编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。这个功能使Python成为一种包装C&#x2F;C++&#x2F;Fortran历史代码库的选择，并使被包装库拥有一个动态的、易用的接口。</p><p>NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具。因为NumPy是一个很大的题目，我会在附录A中介绍更多NumPy高级功能，比如广播。</p><p>对于大部分数据分析应用而言，我最关注的功能主要集中在：</p><ul><li>用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算。</li><li>常用的数组算法，如排序、唯一化、集合运算等。</li><li>高效的描述统计和数据聚合&#x2F;摘要运算。</li><li>用于异构数据集的合并&#x2F;连接运算的数据对齐和关系型数据运算。</li><li>将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）。</li><li>数据的分组运算（聚合、转换、函数应用等）。。</li></ul><p>虽然NumPy提供了通用的数值数据处理的计算基础，但大多数读者可能还是想将pandas作为统计和分析工作的基础，尤其是处理表格数据时。pandas还提供了一些NumPy所没有的领域特定的功能，如时间序列处理等。</p><blockquote><p>笔记：Python的面向数组计算可以追溯到1995年，Jim Hugunin创建了Numeric库。接下来的10年，许多科学编程社区纷纷开始使用Python的数组编程，但是进入21世纪，库的生态系统变得碎片化了。2005年，Travis Oliphant从Numeric和Numarray项目整合出了NumPy项目，进而所有社区都集合到了这个框架下。</p></blockquote><p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：</p><ul><li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li><li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li></ul><p>要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: my_arr = np.arange(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: my_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><p>各个序列分别乘以2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: %time <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_arr2 = my_arr * <span class="number">2</span></span><br><span class="line">CPU times: user <span class="number">20</span> ms, sys: <span class="number">50</span> ms, total: <span class="number">70</span> ms</span><br><span class="line">Wall time: <span class="number">72.4</span> ms</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: %time <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_list2 = [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list]</span><br><span class="line">CPU times: user <span class="number">760</span> ms, sys: <span class="number">290</span> ms, total: <span class="number">1.05</span> s</span><br><span class="line">Wall time: <span class="number">1.05</span> s</span><br></pre></td></tr></table></figure><p>基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。</p><h1 id="4-1-NumPy的ndarray：一种多维数组对象"><a href="#4-1-NumPy的ndarray：一种多维数组对象" class="headerlink" title="4.1 NumPy的ndarray：一种多维数组对象"></a>4.1 NumPy的ndarray：一种多维数组对象</h1><p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p><p>要明白Python是如何利用与标量值类似的语法进行批次计算，我先引入NumPy，然后生成一个包含随机数据的小数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate some random data</span></span><br><span class="line">In [<span class="number">13</span>]: data = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">array([[-<span class="number">0.2047</span>,  <span class="number">0.4789</span>, -<span class="number">0.5194</span>],</span><br><span class="line">       [-<span class="number">0.5557</span>,  <span class="number">1.9658</span>,  <span class="number">1.3934</span>]])</span><br></pre></td></tr></table></figure><p>然后进行数学运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: data * <span class="number">10</span></span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">array([[ -<span class="number">2.0471</span>,   <span class="number">4.7894</span>,  -<span class="number">5.1944</span>],</span><br><span class="line">       [ -<span class="number">5.5573</span>,  <span class="number">19.6578</span>,  <span class="number">13.9341</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: data + data</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">array([[-<span class="number">0.4094</span>,  <span class="number">0.9579</span>, -<span class="number">1.0389</span>],</span><br><span class="line">       [-<span class="number">1.1115</span>,  <span class="number">3.9316</span>,  <span class="number">2.7868</span>]])</span><br></pre></td></tr></table></figure><p>第一个例子中，所有的元素都乘以10。第二个例子中，每个元素都与自身相加。</p><blockquote><p>笔记：在本章及全书中，我会使用标准的NumPy惯用法<code>import numpy as np</code>。你当然也可以在代码中使用<code>from numpy import *</code>，但不建议这么做。<code>numpy</code>的命名空间很大，包含许多函数，其中一些的名字与Python的内置函数重名（比如min和max）。</p></blockquote><p>ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: data.shape</span><br><span class="line">Out[<span class="number">17</span>]: (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: data.dtype</span><br><span class="line">Out[<span class="number">18</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>本章将会介绍NumPy数组的基本用法，这对于本书后面各章的理解基本够用。虽然大多数数据分析工作不需要深入理解NumPy，但是精通面向数组的编程和思维方式是成为Python科学计算牛人的一大关键步骤。</p><blockquote><p>笔记：当你在本书中看到“数组”、“NumPy数组”、”ndarray”时，基本上都指的是同一样东西，即ndarray对象。</p></blockquote><h2 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h2><p>创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">19</span>]: data1 = [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: arr1 = np.array(data1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: arr1</span><br><span class="line">Out[<span class="number">21</span>]: array([ <span class="number">6.</span> ,  <span class="number">7.5</span>,  <span class="number">8.</span> ,  <span class="number">0.</span> ,  <span class="number">1.</span> ])</span><br></pre></td></tr></table></figure><p>嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">22</span>]: data2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: arr2 = np.array(data2)</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: arr2</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure><p>因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: arr2.ndim</span><br><span class="line">Out[<span class="number">25</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: arr2.shape</span><br><span class="line">Out[<span class="number">26</span>]: (<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype对象中。比如说，在上面的两个例子中，我们有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">27</span>]: arr1.dtype</span><br><span class="line">Out[<span class="number">27</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: arr2.dtype</span><br><span class="line">Out[<span class="number">28</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: np.zeros(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">29</span>]: array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">array([[[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>]],</span><br><span class="line">       [[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>]]])</span><br></pre></td></tr></table></figure><blockquote><p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p></blockquote><p>arange是Python内置函数range的数组版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: np.arange(<span class="number">15</span>)</span><br><span class="line">Out[<span class="number">32</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure><p>表4-1列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-78ab11f67e7077a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表4-1 数组创建函数"></p><h2 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h2><p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: arr2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: arr1.dtype</span><br><span class="line">Out[<span class="number">35</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: arr2.dtype</span><br><span class="line">Out[<span class="number">36</span>]: dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br></pre></td></tr></table></figure><p>dtype是NumPy灵活交互其它系统的源泉之一。多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作float64。表4-2列出了NumPy所支持的全部数据类型。</p><blockquote><p>笔记：记不住这些NumPy的dtype也没关系，新手更是如此。通常只需要知道你所处理的数据的大致类型是浮点数、复数、整数、布尔值、字符串，还是普通的Python对象即可。当你需要控制数据在内存和磁盘中的存储方式时（尤其是对大数据集），那就得了解如何控制存储类型。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7178691-2f2d7406a8bc076c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-5cc31115615737b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: arr.dtype</span><br><span class="line">Out[<span class="number">38</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: float_arr = arr.astype(np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: float_arr.dtype</span><br><span class="line">Out[<span class="number">40</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: arr = np.array([<span class="number">3.7</span>, -<span class="number">1.2</span>, -<span class="number">2.6</span>, <span class="number">0.5</span>, <span class="number">12.9</span>, <span class="number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: arr</span><br><span class="line">Out[<span class="number">42</span>]: array([  <span class="number">3.7</span>,  -<span class="number">1.2</span>,  -<span class="number">2.6</span>,   <span class="number">0.5</span>,  <span class="number">12.9</span>,  <span class="number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: arr.astype(np.int32)</span><br><span class="line">Out[<span class="number">43</span>]: array([ <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">2</span>,  <span class="number">0</span>, <span class="number">12</span>, <span class="number">10</span>], dtype=int32)</span><br></pre></td></tr></table></figure><p>如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: numeric_strings = np.array([<span class="string">&#x27;1.25&#x27;</span>, <span class="string">&#x27;-9.6&#x27;</span>, <span class="string">&#x27;42&#x27;</span>], dtype=np.string_)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: numeric_strings.astype(<span class="built_in">float</span>)</span><br><span class="line">Out[<span class="number">45</span>]: array([  <span class="number">1.25</span>,  -<span class="number">9.6</span> ,  <span class="number">42.</span>  ])</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用numpy.string_类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。pandas提供了更多非数值数据的便利的处理方法。</p></blockquote><p>如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。这里，我比较懒，写的是float而不是np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</p><p>数组的dtype还有另一个属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: int_array = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: calibers = np.array([<span class="number">.22</span>, <span class="number">.270</span>, <span class="number">.357</span>, <span class="number">.380</span>, <span class="number">.44</span>, <span class="number">.50</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: int_array.astype(calibers.dtype)</span><br><span class="line">Out[<span class="number">48</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>])</span><br></pre></td></tr></table></figure><p>你还可以用简洁的类型代码来表示dtype：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">49</span>]: empty_uint32 = np.empty(<span class="number">8</span>, dtype=<span class="string">&#x27;u4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: empty_uint32</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">array([         <span class="number">0</span>, <span class="number">1075314688</span>,          <span class="number">0</span>, <span class="number">1075707904</span>,          <span class="number">0</span>,</span><br><span class="line">       <span class="number">1075838976</span>,          <span class="number">0</span>, <span class="number">1072693248</span>], dtype=uint32)</span><br></pre></td></tr></table></figure><blockquote><p>笔记：调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p></blockquote><h2 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h2><p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: arr = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: arr</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: arr * arr</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">array([[  <span class="number">1.</span>,   <span class="number">4.</span>,   <span class="number">9.</span>],</span><br><span class="line">       [ <span class="number">16.</span>,  <span class="number">25.</span>,  <span class="number">36.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: arr - arr</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><p>数组与标量的算术运算会将标量值传播到各个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">55</span>]: <span class="number">1</span> / arr</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    ,  <span class="number">0.5</span>   ,  <span class="number">0.3333</span>],</span><br><span class="line">       [ <span class="number">0.25</span>  ,  <span class="number">0.2</span>   ,  <span class="number">0.1667</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: arr ** <span class="number">0.5</span></span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    ,  <span class="number">1.4142</span>,  <span class="number">1.7321</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.2361</span>,  <span class="number">2.4495</span>]])</span><br></pre></td></tr></table></figure><p>大小相同的数组之间的比较会生成布尔值数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">57</span>]: arr2 = np.array([[<span class="number">0.</span>, <span class="number">4.</span>, <span class="number">1.</span>], [<span class="number">7.</span>, <span class="number">2.</span>, <span class="number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: arr2</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">4.</span>,   <span class="number">1.</span>],</span><br><span class="line">       [  <span class="number">7.</span>,   <span class="number">2.</span>,  <span class="number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: arr2 &gt; arr</span><br><span class="line">Out[<span class="number">59</span>]:</span><br><span class="line">array([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure><p>不同大小的数组之间的运算叫做广播（broadcasting），将在附录A中对其进行详细讨论。本书的内容不需要对广播机制有多深的理解。</p><h2 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h2><p>NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">60</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: arr</span><br><span class="line">Out[<span class="number">61</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: arr[<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">62</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">Out[<span class="number">63</span>]: array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: arr</span><br><span class="line">Out[<span class="number">65</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]&#x3D;12），该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p><p>作为例子，先创建一个arr的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: arr_slice</span><br><span class="line">Out[<span class="number">67</span>]: array([<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br></pre></td></tr></table></figure><p>现在，当我修稿arr_slice中的值，变动也会体现在原始数组arr中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: arr_slice[<span class="number">1</span>] = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: arr</span><br><span class="line">Out[<span class="number">69</span>]: array([    <span class="number">0</span>,     <span class="number">1</span>,     <span class="number">2</span>,     <span class="number">3</span>,     <span class="number">4</span>,    <span class="number">12</span>, <span class="number">12345</span>,    <span class="number">12</span>,     <span class="number">8</span>,   </span><br><span class="line">  <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>切片[ : ]会给数组中的所有值赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">70</span>]: arr_slice[:] = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: arr</span><br><span class="line">Out[<span class="number">71</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>如果你刚开始接触NumPy，可能会对此感到惊讶（尤其是当你曾经用过其他热衷于复制数组数据的编程语言）。由于NumPy的设计目的是处理大数据，所以你可以想象一下，假如NumPy坚持要将数据复制来复制去的话会产生何等的性能和内存问题。</p><blockquote><p>注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p></blockquote><p>对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">72</span>]: arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: arr2d[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">73</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">74</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: arr2d[<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">75</span>]: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>图4-1说明了二维数组的索引方式。轴0作为行，轴1作为列。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-0a641536f73f560e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-1 NumPy数组中的元素索引"></p><p>在多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）。因此，在2×2×3数组arr3d中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">76</span>]: arr3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: arr3d</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure><p>arr3d[0]是一个2×3数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">78</span>]: arr3d[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p>标量值和数组都可以被赋值给arr3d[0]：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">79</span>]: old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: arr3d</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">array([[[<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>],</span><br><span class="line">        [<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: arr3d[<span class="number">0</span>] = old_values</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: arr3d</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure><p>相似的，arr3d[1,0]可以访问索引以(1,0)开头的那些值（以一维数组的形式返回）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">84</span>]: arr3d[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">84</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>虽然是用两步进行索引的，表达式是相同的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">85</span>]: x = arr3d[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: x</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">array([[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: x[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">87</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>注意，在上面所有这些选取数组子集的例子中，返回的数组都是视图。</p><h2 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h2><p>ndarray的切片语法跟Python列表这样的一维对象差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">88</span>]: arr</span><br><span class="line">Out[<span class="number">88</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: arr[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line">Out[<span class="number">89</span>]: array([ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>])</span><br></pre></td></tr></table></figure><p>对于之前的二维数组arr2d，其切片方式稍显不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">90</span>]: arr2d</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: arr2d[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p>可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。</p><p>你可以一次传入多个切片，就像传入多个索引那样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">92</span>]: arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p>像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p><p>例如，我可以选取第二行的前两列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">93</span>]: arr2d[<span class="number">1</span>, :<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">93</span>]: array([<span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>相似的，还可以选择第三列的前两行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">94</span>]: arr2d[:<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">94</span>]: array([<span class="number">3</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>图4-2对此进行了说明。注意，“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">95</span>]: arr2d[:, :<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>],</span><br><span class="line">       [<span class="number">7</span>]])</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-9da32d2f4629c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-2 二维数组切片"></p><p>自然，对切片表达式的赋值操作也会被扩散到整个选区：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">96</span>]: arr2d[:<span class="number">2</span>, <span class="number">1</span>:] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: arr2d</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure><h2 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h2><p>来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，我将使用numpy.random中的randn函数生成一些正态分布的随机数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">98</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: names</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br></pre></td></tr></table></figure><p>假设每个名字都对应data数组中的一行，而我们想要选出对应于名字”Bob”的所有行。跟算术运算一样，数组的比较运算（如&#x3D;&#x3D;）也是矢量化的。因此，对names和字符串”Bob”的比较运算将会产生一个布尔型数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">102</span>]: names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Out[<span class="number">102</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure><p>这个布尔型数组可用于数组索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">103</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br></pre></td></tr></table></figure><p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">103</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。</p></blockquote><p>下面的例子，我选取了<code>names == &#39;Bob&#39;</code>的行，并索引了列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">104</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>, <span class="number">2</span>:]</span><br><span class="line">Out[<span class="number">104</span>]: </span><br><span class="line">array([[ <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [-<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>, <span class="number">3</span>]</span><br><span class="line">Out[<span class="number">105</span>]: array([ <span class="number">1.2464</span>,  <span class="number">0.477</span> ])</span><br></pre></td></tr></table></figure><p>要选择除”Bob”以外的其他值，既可以使用不等于符号（!&#x3D;），也可以通过~对条件进行否定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">106</span>]: names != <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Out[<span class="number">106</span>]: array([<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: data[~(names == <span class="string">&#x27;Bob&#x27;</span>)]</span><br><span class="line">Out[<span class="number">107</span>]:</span><br><span class="line">array([[ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br></pre></td></tr></table></figure><p>~操作符用来反转条件很好用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">108</span>]: cond = names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: data[~cond]</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">array([[ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br></pre></td></tr></table></figure><p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">110</span>]: mask = (names == <span class="string">&#x27;Bob&#x27;</span>) | (names == <span class="string">&#x27;Will&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: mask</span><br><span class="line">Out[<span class="number">111</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: data[mask]</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>]])</span><br></pre></td></tr></table></figure><p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p><blockquote><p>注意：Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</p></blockquote><p>通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.0072</span>,  <span class="number">0.</span>    ,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">       [ <span class="number">1.669</span> ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br></pre></td></tr></table></figure><p>通过一维布尔数组设置整行或列的值也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">115</span>]: data[names != <span class="string">&#x27;Joe&#x27;</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: data</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">array([[ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">1.0072</span>,  <span class="number">0.</span>    ,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br></pre></td></tr></table></figure><p>后面会看到，这类二维数据的操作也可以用pandas方便的来做。</p><h2 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h2><p>花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">   .....:     arr[i] = i</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: arr</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>]])</span><br></pre></td></tr></table></figure><p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">120</span>]: arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]]</span><br><span class="line">Out[<span class="number">120</span>]: </span><br><span class="line">array([[ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure><p>这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">121</span>]: arr[[-<span class="number">3</span>, -<span class="number">5</span>, -<span class="number">7</span>]]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">array([[ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">122</span>]: arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: arr</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">124</span>]: array([ <span class="number">4</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>附录A中会详细介绍reshape方法。</p><p>最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的。</p><p>这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">125</span>]: arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">11</span>,  <span class="number">9</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure><p>记住，花式索引跟切片不一样，它总是将数据复制到新数组中。</p><h2 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h2><p>转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">126</span>]: arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: arr</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: arr.T</span><br><span class="line">Out[<span class="number">128</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">6</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">8</span>, <span class="number">13</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure><p>在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">129</span>]: arr = np.random.randn(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: arr</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">array([[-<span class="number">0.8608</span>,  <span class="number">0.5601</span>, -<span class="number">1.2659</span>],</span><br><span class="line">       [ <span class="number">0.1198</span>, -<span class="number">1.0635</span>,  <span class="number">0.3329</span>],</span><br><span class="line">       [-<span class="number">2.3594</span>, -<span class="number">0.1995</span>, -<span class="number">1.542</span> ],</span><br><span class="line">       [-<span class="number">0.9707</span>, -<span class="number">1.307</span> ,  <span class="number">0.2863</span>],</span><br><span class="line">       [ <span class="number">0.378</span> , -<span class="number">0.7539</span>,  <span class="number">0.3313</span>],</span><br><span class="line">       [ <span class="number">1.3497</span>,  <span class="number">0.0699</span>,  <span class="number">0.2467</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: np.dot(arr.T, arr)</span><br><span class="line">Out[<span class="number">131</span>]:</span><br><span class="line">array([[ <span class="number">9.2291</span>,  <span class="number">0.9394</span>,  <span class="number">4.948</span> ],</span><br><span class="line">       [ <span class="number">0.9394</span>,  <span class="number">3.7662</span>, -<span class="number">1.3622</span>],</span><br><span class="line">       [ <span class="number">4.948</span> , -<span class="number">1.3622</span>,  <span class="number">4.3437</span>]])</span><br></pre></td></tr></table></figure><p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">132</span>]: arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: arr</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure><p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。</p><p>简单的转置可以使用.T，它其实就是进行轴对换而已。ndarray还有一个swapaxes方法，它需要接受一对轴编号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">135</span>]: arr</span><br><span class="line">Out[<span class="number">135</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure><p>swapaxes也是返回源数据的视图（不会进行任何复制操作）。</p><h1 id="4-2-通用函数：快速的元素级数组函数"><a href="#4-2-通用函数：快速的元素级数组函数" class="headerlink" title="4.2 通用函数：快速的元素级数组函数"></a>4.2 通用函数：快速的元素级数组函数</h1><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</p><p>许多ufunc都是简单的元素级变体，如sqrt和exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">137</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: arr</span><br><span class="line">Out[<span class="number">138</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">array([ <span class="number">0.</span>    ,  <span class="number">1.</span>    ,  <span class="number">1.4142</span>,  <span class="number">1.7321</span>,  <span class="number">2.</span>    ,  <span class="number">2.2361</span>,  <span class="number">2.4495</span>,</span><br><span class="line">        <span class="number">2.6458</span>,  <span class="number">2.8284</span>,  <span class="number">3.</span>    ])</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: np.exp(arr)</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">array([    <span class="number">1.</span>    ,     <span class="number">2.7183</span>,     <span class="number">7.3891</span>,    <span class="number">20.0855</span>,    <span class="number">54.5982</span>,</span><br><span class="line">         <span class="number">148.4132</span>,   <span class="number">403.4288</span>,  <span class="number">1096.6332</span>,  <span class="number">2980.958</span> ,  <span class="number">8103.0839</span>])</span><br></pre></td></tr></table></figure><p>这些都是一元（unary）ufunc。另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">141</span>]: x = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: y = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: x</span><br><span class="line">Out[<span class="number">143</span>]: </span><br><span class="line">array([-<span class="number">0.0119</span>,  <span class="number">1.0048</span>,  <span class="number">1.3272</span>, -<span class="number">0.9193</span>, -<span class="number">1.5491</span>,  <span class="number">0.0222</span>,  <span class="number">0.7584</span>,</span><br><span class="line">       -<span class="number">0.6605</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: y</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line">array([ <span class="number">0.8626</span>, -<span class="number">0.01</span>  ,  <span class="number">0.05</span>  ,  <span class="number">0.6702</span>,  <span class="number">0.853</span> , -<span class="number">0.9559</span>, -<span class="number">0.0235</span>,</span><br><span class="line">       -<span class="number">2.3042</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: np.maximum(x, y)</span><br><span class="line">Out[<span class="number">145</span>]: </span><br><span class="line">array([ <span class="number">0.8626</span>,  <span class="number">1.0048</span>,  <span class="number">1.3272</span>,  <span class="number">0.6702</span>,  <span class="number">0.853</span> ,  <span class="number">0.0222</span>,  <span class="number">0.7584</span>,   </span><br><span class="line">       -<span class="number">0.6605</span>])</span><br></pre></td></tr></table></figure><p>这里，numpy.maximum计算了x和y中元素级别最大的元素。</p><p>虽然并不常见，但有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">146</span>]: arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: arr</span><br><span class="line">Out[<span class="number">147</span>]: array([-<span class="number">3.2623</span>, -<span class="number">6.0915</span>, -<span class="number">6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: remainder, whole_part = np.modf(arr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: remainder</span><br><span class="line">Out[<span class="number">149</span>]: array([-<span class="number">0.2623</span>, -<span class="number">0.0915</span>, -<span class="number">0.663</span> ,  <span class="number">0.3731</span>,</span><br><span class="line"><span class="number">0.6182</span>,  <span class="number">0.45</span>  ,  <span class="number">0.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: whole_part</span><br><span class="line">Out[<span class="number">150</span>]: array([-<span class="number">3.</span>, -<span class="number">6.</span>, -<span class="number">6.</span>,  <span class="number">5.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">5.</span>])</span><br></pre></td></tr></table></figure><p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">151</span>]: arr</span><br><span class="line">Out[<span class="number">151</span>]: array([-<span class="number">3.2623</span>, -<span class="number">6.0915</span>, -<span class="number">6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="number">152</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: np.sqrt(arr, arr)</span><br><span class="line">Out[<span class="number">153</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: arr</span><br><span class="line">Out[<span class="number">154</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br></pre></td></tr></table></figure><p>表4-3和表4-4分别列出了一些一元和二元ufunc。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-1d494e73b61c7ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-2be79faf68ab6ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-4e38d02a66481530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-eff1e61e5464159f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-236dba83b6a420cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="4-3-利用数组进行数据处理"><a href="#4-3-利用数组进行数据处理" class="headerlink" title="4.3 利用数组进行数据处理"></a>4.3 利用数组进行数据处理</h1><p>NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，通常被称为矢量化。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多），尤其是各种数值计算。在后面内容中（见附录A）我将介绍广播，这是一种针对矢量化计算的强大手段。</p><p>作为简单的例子，假设我们想要在一组值（网格型）上计算函数<code>sqrt(x^2+y^2)</code>。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">155</span>]: points = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.01</span>) <span class="comment"># 1000 equally spaced points</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: xs, ys = np.meshgrid(points, points)</span><br><span class="line">In [<span class="number">157</span>]: ys</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">array([[-<span class="number">5.</span>  , -<span class="number">5.</span>  , -<span class="number">5.</span>  , ..., -<span class="number">5.</span>  , -<span class="number">5.</span>  , -<span class="number">5.</span>  ],</span><br><span class="line">       [-<span class="number">4.99</span>, -<span class="number">4.99</span>, -<span class="number">4.99</span>, ..., -<span class="number">4.99</span>, -<span class="number">4.99</span>, -<span class="number">4.99</span>],</span><br><span class="line">       [-<span class="number">4.98</span>, -<span class="number">4.98</span>, -<span class="number">4.98</span>, ..., -<span class="number">4.98</span>, -<span class="number">4.98</span>, -<span class="number">4.98</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>, ...,  <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>],</span><br><span class="line">       [ <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>, ...,  <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>],</span><br><span class="line">       [ <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>, ...,  <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>]])</span><br></pre></td></tr></table></figure><p>现在，对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">158</span>]: z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: z</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">array([[ <span class="number">7.0711</span>,  <span class="number">7.064</span> ,  <span class="number">7.0569</span>, ...,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>,  <span class="number">7.064</span> ],</span><br><span class="line">       [ <span class="number">7.064</span> ,  <span class="number">7.0569</span>,  <span class="number">7.0499</span>, ...,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>],</span><br><span class="line">       [ <span class="number">7.0569</span>,  <span class="number">7.0499</span>,  <span class="number">7.0428</span>, ...,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>, <span class="number">7.0499</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="number">7.0499</span>,  <span class="number">7.0428</span>,  <span class="number">7.0357</span>, ...,  <span class="number">7.0286</span>,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>],</span><br><span class="line">       [ <span class="number">7.0569</span>,  <span class="number">7.0499</span>,  <span class="number">7.0428</span>, ...,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>],</span><br><span class="line">       [ <span class="number">7.064</span> ,  <span class="number">7.0569</span>,  <span class="number">7.0499</span>, ...,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>]])</span><br></pre></td></tr></table></figure><p>作为第9章的先导，我用matplotlib创建了这个二维数组的可视化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">160</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line">Out[<span class="number">161</span>]: &lt;matplotlib.colorbar.Colorbar at <span class="number">0x7f715e3fa630</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: plt.title(<span class="string">&quot;Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values&quot;</span>)</span><br><span class="line">Out[<span class="number">162</span>]: &lt;matplotlib.text.Text at <span class="number">0x7f715d2de748</span>&gt;</span><br></pre></td></tr></table></figure><p>见图4-3。这张图是用matplotlib的imshow函数创建的。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-3b22000d4cd38650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-3 根据网格对函数求值的结果"></p><h2 id="将条件逻辑表述为数组运算"><a href="#将条件逻辑表述为数组运算" class="headerlink" title="将条件逻辑表述为数组运算"></a>将条件逻辑表述为数组运算</h2><p>numpy.where函数是三元表达式x if condition else y的矢量化版本。假设我们有一个布尔数组和两个值数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">165</span>]: xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure><p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">168</span>]: result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y)</span><br><span class="line">   .....:           <span class="keyword">for</span> x, y, c <span class="keyword">in</span> <span class="built_in">zip</span>(xarr, yarr, cond)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: result</span><br><span class="line">Out[<span class="number">169</span>]: [<span class="number">1.1000000000000001</span>, <span class="number">2.2000000000000002</span>, <span class="number">1.3</span>, <span class="number">1.3999999999999999</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure><p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">170</span>]: result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: result</span><br><span class="line">Out[<span class="number">171</span>]: array([ <span class="number">1.1</span>,  <span class="number">2.2</span>,  <span class="number">1.3</span>,  <span class="number">1.4</span>,  <span class="number">2.5</span>])</span><br></pre></td></tr></table></figure><p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">172</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: arr</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">0.2229</span>,  <span class="number">0.0513</span>, -<span class="number">1.1577</span>,  <span class="number">0.8167</span>],</span><br><span class="line">       [ <span class="number">0.4336</span>,  <span class="number">1.0107</span>,  <span class="number">1.8249</span>, -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">0.8506</span>, -<span class="number">0.1316</span>,  <span class="number">0.9124</span>,  <span class="number">0.1882</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">174</span>]: arr &gt; <span class="number">0</span></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, -<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">array([[-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p>使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">176</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr) <span class="comment"># set only positive values to 2</span></span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">1.1577</span>,  <span class="number">2.</span>    ],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">2.</span>    , -<span class="number">0.1316</span>,  <span class="number">2.</span>    ,  <span class="number">2.</span>    ]])</span><br></pre></td></tr></table></figure><p>传递给where的数组大小可以不相等，甚至可以是标量值。</p><h2 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h2><p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p><p>这里，我生成了一些正态分布随机数据，然后做了聚类统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">177</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">2.1695</span>, -<span class="number">0.1149</span>,  <span class="number">2.0037</span>,  <span class="number">0.0296</span>],</span><br><span class="line">       [ <span class="number">0.7953</span>,  <span class="number">0.1181</span>, -<span class="number">0.7485</span>,  <span class="number">0.585</span> ],</span><br><span class="line">       [ <span class="number">0.1527</span>, -<span class="number">1.5657</span>, -<span class="number">0.5625</span>, -<span class="number">0.0327</span>],</span><br><span class="line">       [-<span class="number">0.929</span> , -<span class="number">0.4826</span>, -<span class="number">0.0363</span>,  <span class="number">1.0954</span>],</span><br><span class="line">       [ <span class="number">0.9809</span>, -<span class="number">0.5895</span>,  <span class="number">1.5817</span>, -<span class="number">0.5287</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">179</span>]: arr.mean()</span><br><span class="line">Out[<span class="number">179</span>]: <span class="number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: np.mean(arr)</span><br><span class="line">Out[<span class="number">180</span>]: <span class="number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: arr.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">181</span>]: <span class="number">3.9214102239996507</span></span><br></pre></td></tr></table></figure><p>mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">182</span>]: arr.mean(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">182</span>]: array([ <span class="number">1.022</span> ,  <span class="number">0.1875</span>, -<span class="number">0.502</span> , -<span class="number">0.0881</span>,  <span class="number">0.3611</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">183</span>]: array([ <span class="number">3.1693</span>, -<span class="number">2.6345</span>,  <span class="number">2.2381</span>,  <span class="number">1.1486</span>])</span><br></pre></td></tr></table></figure><p>这里，arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</p><p>其他如cumsum和cumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">184</span>]: arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: arr.cumsum()</span><br><span class="line">Out[<span class="number">185</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure><p>在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">186</span>]: arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: arr</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: arr.cumprod(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">array([[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">       [  <span class="number">3</span>,  <span class="number">12</span>,  <span class="number">60</span>],</span><br><span class="line">       [  <span class="number">6</span>,  <span class="number">42</span>, <span class="number">336</span>]])</span><br></pre></td></tr></table></figure><p>表4-5列出了全部的基本数组统计方法。后续章节中有很多例子都会用到这些方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h2><p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被用来对布尔型数组中的True值计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">190</span>]: arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: (arr &gt; <span class="number">0</span>).<span class="built_in">sum</span>() <span class="comment"># Number of positive values</span></span><br><span class="line">Out[<span class="number">191</span>]: <span class="number">42</span></span><br></pre></td></tr></table></figure><p>另外还有两个方法any和all，它们对布尔型数组非常有用。any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">192</span>]: bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">193</span>]: bools.<span class="built_in">any</span>()</span><br><span class="line">Out[<span class="number">193</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: bools.<span class="built_in">all</span>()</span><br><span class="line">Out[<span class="number">194</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>跟Python内置的列表类型一样，NumPy数组也可以通过sort方法就地排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">195</span>]: arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: arr</span><br><span class="line">Out[<span class="number">196</span>]: array([ <span class="number">0.6095</span>, -<span class="number">0.4938</span>,  <span class="number">1.24</span>  , -<span class="number">0.1357</span>,  <span class="number">1.43</span>  , -<span class="number">0.8469</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: arr</span><br><span class="line">Out[<span class="number">198</span>]: array([-<span class="number">0.8469</span>, -<span class="number">0.4938</span>, -<span class="number">0.1357</span>,  <span class="number">0.6095</span>,  <span class="number">1.24</span>  ,  <span class="number">1.43</span>  ])</span><br></pre></td></tr></table></figure><p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">199</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">200</span>]: arr</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">array([[ <span class="number">0.6033</span>,  <span class="number">1.2636</span>, -<span class="number">0.2555</span>],</span><br><span class="line">       [-<span class="number">0.4457</span>,  <span class="number">0.4684</span>, -<span class="number">0.9616</span>],</span><br><span class="line">       [-<span class="number">1.8245</span>,  <span class="number">0.6254</span>,  <span class="number">1.0229</span>],</span><br><span class="line">       [ <span class="number">1.1074</span>,  <span class="number">0.0909</span>, -<span class="number">0.3501</span>],</span><br><span class="line">       [ <span class="number">0.218</span> , -<span class="number">0.8948</span>, -<span class="number">1.7415</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: arr.sort(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: arr</span><br><span class="line">Out[<span class="number">202</span>]: </span><br><span class="line">array([[-<span class="number">0.2555</span>,  <span class="number">0.6033</span>,  <span class="number">1.2636</span>],</span><br><span class="line">       [-<span class="number">0.9616</span>, -<span class="number">0.4457</span>,  <span class="number">0.4684</span>],</span><br><span class="line">       [-<span class="number">1.8245</span>,  <span class="number">0.6254</span>,  <span class="number">1.0229</span>],</span><br><span class="line">       [-<span class="number">0.3501</span>,  <span class="number">0.0909</span>,  <span class="number">1.1074</span>],</span><br><span class="line">       [-<span class="number">1.7415</span>, -<span class="number">0.8948</span>,  <span class="number">0.218</span> ]])</span><br></pre></td></tr></table></figure><p>顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">203</span>]: large_arr = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: large_arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: large_arr[<span class="built_in">int</span>(<span class="number">0.05</span> * <span class="built_in">len</span>(large_arr))] <span class="comment"># 5% quantile</span></span><br><span class="line">Out[<span class="number">205</span>]: -<span class="number">1.5311513550102103</span></span><br></pre></td></tr></table></figure><p>更多关于NumPy排序方法以及诸如间接排序之类的高级技术，请参阅附录A。在pandas中还可以找到一些其他跟排序有关的数据操作（比如根据一列或多列对表格型数据进行排序）。</p><h2 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h2><p>NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">206</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: np.unique(names)</span><br><span class="line">Out[<span class="number">207</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: np.unique(ints)</span><br><span class="line">Out[<span class="number">209</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>拿跟np.unique等价的纯Python代码来对比一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">210</span>]: <span class="built_in">sorted</span>(<span class="built_in">set</span>(names))</span><br><span class="line">Out[<span class="number">210</span>]: [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>]</span><br></pre></td></tr></table></figure><p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">211</span>]: values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">Out[<span class="number">212</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure><p>NumPy中的集合函数请参见表4-6。<br><img src="http://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="4-4-用于数组的文件输入输出"><a href="#4-4-用于数组的文件输入输出" class="headerlink" title="4.4 用于数组的文件输入输出"></a>4.4 用于数组的文件输入输出</h1><p>NumPy能够读写磁盘上的文本数据或二进制数据。这一小节只讨论NumPy的内置二进制格式，因为更多的用户会使用pandas或其它工具加载文本或表格数据（见第6章）。</p><p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">213</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: np.save(<span class="string">&#x27;some_array&#x27;</span>, arr)</span><br></pre></td></tr></table></figure><p>如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">215</span>]: np.load(<span class="string">&#x27;some_array.npy&#x27;</span>)</span><br><span class="line">Out[<span class="number">215</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">216</span>]: np.savez(<span class="string">&#x27;array_archive.npz&#x27;</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure><p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">217</span>]: arch = np.load(<span class="string">&#x27;array_archive.npz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: arch[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">218</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>如果要将数据压缩，可以使用numpy.savez_compressed：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">219</span>]: np.savez_compressed(<span class="string">&#x27;arrays_compressed.npz&#x27;</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure><h1 id="4-5-线性代数"><a href="#4-5-线性代数" class="headerlink" title="4.5 线性代数"></a>4.5 线性代数</h1><p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如MATLAB），通过*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">223</span>]: x = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [-<span class="number">1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">225</span>]: x</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: y</span><br><span class="line">Out[<span class="number">226</span>]: </span><br><span class="line">array([[  <span class="number">6.</span>,  <span class="number">23.</span>],</span><br><span class="line">       [ -<span class="number">1.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: x.dot(y)</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">array([[  <span class="number">28.</span>,   <span class="number">64.</span>],</span><br><span class="line">       [  <span class="number">67.</span>,  <span class="number">181.</span>]])</span><br></pre></td></tr></table></figure><p>x.dot(y)等价于np.dot(x, y)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">228</span>]: np.dot(x, y)</span><br><span class="line">Out[<span class="number">228</span>]: </span><br><span class="line">array([[  <span class="number">28.</span>,   <span class="number">64.</span>],</span><br><span class="line">       [  <span class="number">67.</span>,  <span class="number">181.</span>]])</span><br></pre></td></tr></table></figure><p>一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">229</span>]: np.dot(x, np.ones(<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">229</span>]: array([  <span class="number">6.</span>,  <span class="number">15.</span>])</span><br></pre></td></tr></table></figure><p>@符（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">230</span>]: x @ np.ones(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">230</span>]: array([  <span class="number">6.</span>,  <span class="number">15.</span>])</span><br></pre></td></tr></table></figure><p>numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于你的NumPy版本）等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">231</span>]: <span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line"></span><br><span class="line">In [<span class="number">232</span>]: X = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: mat = X.T.dot(X)</span><br><span class="line"></span><br><span class="line">In [<span class="number">234</span>]: inv(mat)</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">array([[  <span class="number">933.1189</span>,   <span class="number">871.8258</span>, -<span class="number">1417.6902</span>, -<span class="number">1460.4005</span>,  <span class="number">1782.1391</span>],</span><br><span class="line">       [  <span class="number">871.8258</span>,   <span class="number">815.3929</span>, -<span class="number">1325.9965</span>, -<span class="number">1365.9242</span>,  <span class="number">1666.9347</span>],</span><br><span class="line">       [-<span class="number">1417.6902</span>, -<span class="number">1325.9965</span>,  <span class="number">2158.4424</span>,  <span class="number">2222.0191</span>, -<span class="number">2711.6822</span>],</span><br><span class="line">       [-<span class="number">1460.4005</span>, -<span class="number">1365.9242</span>,  <span class="number">2222.0191</span>,  <span class="number">2289.0575</span>, -<span class="number">2793.422</span> ],</span><br><span class="line">       [ <span class="number">1782.1391</span>,  <span class="number">1666.9347</span>, -<span class="number">2711.6822</span>, -<span class="number">2793.422</span> ,  <span class="number">3409.5128</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">235</span>]: mat.dot(inv(mat))</span><br><span class="line">Out[<span class="number">235</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">236</span>]: q, r = qr(mat)</span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: r</span><br><span class="line">Out[<span class="number">237</span>]: </span><br><span class="line">array([[-<span class="number">1.6914</span>,  <span class="number">4.38</span>  ,  <span class="number">0.1757</span>,  <span class="number">0.4075</span>, -<span class="number">0.7838</span>],</span><br><span class="line">       [ <span class="number">0.</span>    , -<span class="number">2.6436</span>,  <span class="number">0.1939</span>, -<span class="number">3.072</span> , -<span class="number">1.0702</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    , -<span class="number">0.8138</span>,  <span class="number">1.5414</span>,  <span class="number">0.6155</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , -<span class="number">2.6445</span>, -<span class="number">2.1669</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.0002</span>]])</span><br></pre></td></tr></table></figure><p>表达式X.T.dot(X)计算X和它的转置X.T的点积。</p><p>表4-7中列出了一些最常用的线性代数函数。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-dcdb66e49e5f70ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="4-6-伪随机数生成"><a href="#4-6-伪随机数生成" class="headerlink" title="4.6 伪随机数生成"></a>4.6 伪随机数生成</h1><p>numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">238</span>]: samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: samples</span><br><span class="line">Out[<span class="number">239</span>]: </span><br><span class="line">array([[ <span class="number">0.5732</span>,  <span class="number">0.1933</span>,  <span class="number">0.4429</span>,  <span class="number">1.2796</span>],</span><br><span class="line">       [ <span class="number">0.575</span> ,  <span class="number">0.4339</span>, -<span class="number">0.7658</span>, -<span class="number">1.237</span> ],</span><br><span class="line">       [-<span class="number">0.5367</span>,  <span class="number">1.8545</span>, -<span class="number">0.92</span>  , -<span class="number">0.1082</span>],</span><br><span class="line">       [ <span class="number">0.1525</span>,  <span class="number">0.9435</span>, -<span class="number">1.0953</span>, -<span class="number">0.144</span> ]])</span><br></pre></td></tr></table></figure><p>而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">240</span>]: <span class="keyword">from</span> random <span class="keyword">import</span> normalvariate</span><br><span class="line"></span><br><span class="line">In [<span class="number">241</span>]: N = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: %timeit samples = [normalvariate(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="number">1.77</span> s +- <span class="number">126</span> ms per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: %timeit np.random.normal(size=N)</span><br><span class="line"><span class="number">61.7</span> ms +- <span class="number">1.32</span> ms per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br></pre></td></tr></table></figure><p>我们说这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">244</span>]: np.random.seed(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure><p>numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">245</span>]: rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">246</span>]: rng.randn(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">246</span>]: </span><br><span class="line">array([ <span class="number">0.4714</span>, -<span class="number">1.191</span> ,  <span class="number">1.4327</span>, -<span class="number">0.3127</span>, -<span class="number">0.7206</span>,  <span class="number">0.8872</span>,  <span class="number">0.8596</span>,</span><br><span class="line">       -<span class="number">0.6365</span>,  <span class="number">0.0157</span>, -<span class="number">2.2427</span>])</span><br></pre></td></tr></table></figure><p>表4-8列出了numpy.random中的部分函数。在下一节中，我将给出一些利用这些函数一次性生成大量样本值的范例。</p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-97ba09c96dab93a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/7178691-6ed04fae3d1178e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="4-7-示例：随机漫步"><a href="#4-7-示例：随机漫步" class="headerlink" title="4.7 示例：随机漫步"></a>4.7 示例：随机漫步</h1><p>我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p><p>下面是一个通过内置的random模块以纯Python的方式实现1000步的随机漫步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">247</span>]: <span class="keyword">import</span> random</span><br><span class="line">   .....: position = <span class="number">0</span></span><br><span class="line">   .....: walk = [position]</span><br><span class="line">   .....: steps = <span class="number">1000</span></span><br><span class="line">   .....: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">   .....:     step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">   .....:     position += step</span><br><span class="line">   .....:     walk.append(position)</span><br><span class="line">   .....:</span><br></pre></td></tr></table></figure><p>图4-4是根据前100个随机漫步值生成的折线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">249</span>]: plt.plot(walk[:<span class="number">100</span>])</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/7178691-0833621694f6dda0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-4 简单的随机漫步"></p><p>不难看出，这其实就是随机漫步中各步的累计和，可以用一个数组运算来实现。因此，我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">251</span>]: nsteps = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">252</span>]: draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">254</span>]: walk = steps.cumsum()</span><br></pre></td></tr></table></figure><p>有了这些数据之后，我们就可以沿着漫步路径做一些统计工作了，比如求取最大值和最小值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">255</span>]: walk.<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">255</span>]: -<span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">256</span>]: walk.<span class="built_in">max</span>()</span><br><span class="line">Out[<span class="number">256</span>]: <span class="number">31</span></span><br></pre></td></tr></table></figure><p>现在来看一个复杂点的统计任务——首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;&#x3D;10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">257</span>]: (np.<span class="built_in">abs</span>(walk) &gt;= <span class="number">10</span>).argmax()</span><br><span class="line">Out[<span class="number">257</span>]: <span class="number">37</span></span><br></pre></td></tr></table></figure><p>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</p><h2 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h2><p>如果你希望模拟多个随机漫步过程（比如5000个），只需对上面的代码做一点点修改即可生成所有的随机漫步过程。只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">258</span>]: nwalks = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">259</span>]: nsteps = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">260</span>]: draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(nwalks, nsteps)) <span class="comment"># 0 or 1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">261</span>]: steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">262</span>]: walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">263</span>]: walks</span><br><span class="line">Out[<span class="number">263</span>]: </span><br><span class="line">array([[  <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>, ...,   <span class="number">8</span>,   <span class="number">7</span>,   <span class="number">8</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,  -<span class="number">1</span>, ...,  <span class="number">34</span>,  <span class="number">33</span>,  <span class="number">32</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,  -<span class="number">1</span>, ...,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">4</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">1</span>, ...,  <span class="number">24</span>,  <span class="number">25</span>,  <span class="number">26</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>, ...,  <span class="number">14</span>,  <span class="number">13</span>,  <span class="number">14</span>],</span><br><span class="line">       [ -<span class="number">1</span>,  -<span class="number">2</span>,  -<span class="number">3</span>, ..., -<span class="number">24</span>, -<span class="number">23</span>, -<span class="number">22</span>]])</span><br></pre></td></tr></table></figure><p>现在，我们来计算所有随机漫步过程的最大值和最小值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">264</span>]: walks.<span class="built_in">max</span>()</span><br><span class="line">Out[<span class="number">264</span>]: <span class="number">138</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">265</span>]: walks.<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">265</span>]: -<span class="number">133</span></span><br></pre></td></tr></table></figure><p>得到这些数据之后，我们来计算30或－30的最小穿越时间。这里稍微复杂些，因为不是5000个过程都到达了30。我们可以用any方法来对此进行检查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">266</span>]: hits30 = (np.<span class="built_in">abs</span>(walks) &gt;= <span class="number">30</span>).<span class="built_in">any</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">267</span>]: hits30</span><br><span class="line">Out[<span class="number">267</span>]: array([<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, ..., <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">268</span>]: hits30.<span class="built_in">sum</span>() <span class="comment"># Number that hit 30 or -30</span></span><br><span class="line">Out[<span class="number">268</span>]: <span class="number">3410</span></span><br></pre></td></tr></table></figure><p>然后我们利用这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">269</span>]: crossing_times = (np.<span class="built_in">abs</span>(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">270</span>]: crossing_times.mean()</span><br><span class="line">Out[<span class="number">270</span>]: <span class="number">498.88973607038122</span></span><br></pre></td></tr></table></figure><p>请尝试用其他分布方式得到漫步数据。只需使用不同的随机数生成函数即可，如normal用于生成指定均值和标准差的正态分布数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">271</span>]: steps = np.random.normal(loc=<span class="number">0</span>, scale=<span class="number">0.25</span>,</span><br><span class="line">   .....:                          size=(nwalks, nsteps))</span><br></pre></td></tr></table></figure><h1 id="4-8-结论"><a href="#4-8-结论" class="headerlink" title="4.8 结论"></a>4.8 结论</h1><p>虽然本书剩下的章节大部分是用pandas规整数据，我们还是会用到相似的基于数组的计算。在附录A中，我们会深入挖掘NumPy的特点，进一步学习数组的技巧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC01%E7%AB%A0%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E7%AC%AC01%E7%AB%A0%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-准备工作"><a href="#第1章-准备工作" class="headerlink" title="第1章 准备工作"></a>第1章 准备工作</h1><h2 id="1-1-本书的内容"><a href="#1-1-本书的内容" class="headerlink" title="1.1 本书的内容"></a>1.1 本书的内容</h2><p>本书讲的是利用Python进行数据控制、处理、整理、分析等方面的具体细节和基本要点。我的目标是介绍Python编程和用于数据处理的库和工具环境，掌握这些，可以让你成为一个数据分析专家。虽然本书的标题是“数据分析”，重点却是Python编程、库，以及用于数据分析的工具。这就是数据分析要用到的Python编程。</p><h3 id="什么样的数据？"><a href="#什么样的数据？" class="headerlink" title="什么样的数据？"></a>什么样的数据？</h3><p>当书中出现“数据”时，究竟指的是什么呢？主要指的是结构化数据（structured data），这个故意含糊其辞的术语代指了所有通用格式的数据，例如：</p><ul><li>表格型数据，其中各列可能是不同的类型（字符串、数值、日期等）。比如保存在关系型数据库中或以制表符&#x2F;逗号为分隔符的文本文件中的那些数据。</li><li>多维数组（矩阵）。</li><li>通过关键列（对于SQL用户而言，就是主键和外键）相互联系的多个表。</li><li>间隔平均或不平均的时间序列。</li></ul><p>这绝不是一个完整的列表。大部分数据集都能被转化为更加适合分析和建模的结构化形式，虽然有时这并不是很明显。如果不行的话，也可以将数据集的特征提取为某种结构化形式。例如，一组新闻文章可以被处理为一张词频表，而这张词频表就可以用于情感分析。</p><p>大部分电子表格软件（比如Microsoft Excel，它可能是世界上使用最广泛的数据分析工具了）的用户不会对此类数据感到陌生。</p><h2 id="1-2-为什么要使用Python进行数据分析"><a href="#1-2-为什么要使用Python进行数据分析" class="headerlink" title="1.2 为什么要使用Python进行数据分析"></a>1.2 为什么要使用Python进行数据分析</h2><p>许许多多的人（包括我自己）都很容易爱上Python这门语言。自从1991年诞生以来，Python现在已经成为最受欢迎的动态编程语言之一，其他还有Perl、Ruby等。由于拥有大量的Web框架（比如Rails（Ruby）和Django（Python）），自从2005年，使用Python和Ruby进行网站建设工作非常流行。这些语言常被称作脚本（scripting）语言，因为它们可以用于编写简短而粗糙的小程序（也就是脚本）。我个人并不喜欢“脚本语言”这个术语，因为它好像在说这些语言无法用于构建严谨的软件。在众多解释型语言中，由于各种历史和文化的原因，Python发展出了一个巨大而活跃的科学计算（scientific computing）社区。在过去的10年，Python从一个边缘或“自担风险”的科学计算语言，成为了数据科学、机器学习、学界和工业界软件开发最重要的语言之一。</p><p>在数据分析、交互式计算以及数据可视化方面，Python将不可避免地与其他开源和商业的领域特定编程语言&#x2F;工具进行对比，如R、MATLAB、SAS、Stata等。近年来，由于Python的库（例如pandas和scikit-learn）不断改良，使其成为数据分析任务的一个优选方案。结合其在通用编程方面的强大实力，我们完全可以只使用Python这一种语言构建以数据为中心的应用。</p><h3 id="Python作为胶水语言"><a href="#Python作为胶水语言" class="headerlink" title="Python作为胶水语言"></a>Python作为胶水语言</h3><p>Python成为成功的科学计算工具的部分原因是，它能够轻松地集成C、C++以及Fortran代码。大部分现代计算环境都利用了一些Fortran和C库来实现线性代数、优选、积分、快速傅里叶变换以及其他诸如此类的算法。许多企业和国家实验室也利用Python来“粘合”那些已经用了多年的遗留软件系统。</p><p>大多数软件都是由两部分代码组成的：少量需要占用大部分执行时间的代码，以及大量不经常执行的“胶水代码”。大部分情况下，胶水代码的执行时间是微不足道的。开发人员的精力几乎都是花在优化计算瓶颈上面，有时更是直接转用更低级的语言（比如C）。</p><h3 id="解决“两种语言”问题"><a href="#解决“两种语言”问题" class="headerlink" title="解决“两种语言”问题"></a>解决“两种语言”问题</h3><p>很多组织通常都会用一种类似于领域特定的计算语言（如SAS和R）对新想法做研究、原型构建和测试，然后再将这些想法移植到某个更大的生产系统中去（可能是用Java、C#或C++编写的）。人们逐渐意识到，Python不仅适用于研究和原型构建，同时也适用于构建生产系统。为什么一种语言就够了，却要使用两个语言的开发环境呢？我相信越来越多的企业也会这样看，因为研究人员和工程技术人员使用同一种编程工具将会给企业带来非常显著的组织效益。</p><h3 id="为什么不选Python"><a href="#为什么不选Python" class="headerlink" title="为什么不选Python"></a>为什么不选Python</h3><p>虽然Python非常适合构建分析应用以及通用系统，但它对不少应用场景适用性较差。</p><p>由于Python是一种解释型编程语言，因此大部分Python代码都要比用编译型语言（比如Java和C++）编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱，因此许多人也愿意对此做一些取舍。但是，在那些延迟要求非常小或高资源利用率的应用中（例如高频交易系统），耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。</p><p>对于高并发、多线程的应用程序而言（尤其是拥有许多计算密集型线程的应用程序），Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁（Global Interpreter Lock，GIL）的组件，这是一种防止解释器同时执行多条Python字节码指令的机制。有关“为什么会存在GIL”的技术性原因超出了本书的范围。虽然很多大数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上，但是仍然有一些情况需要用单进程多线程系统来解决。</p><p>这并不是说Python不能执行真正的多线程并行代码。例如，Python的C插件使用原生的C或C++的多线程，可以并行运行而不被GIL影响，只要它们不频繁地与Python对象交互。</p><h2 id="1-3-重要的Python库"><a href="#1-3-重要的Python库" class="headerlink" title="1.3 重要的Python库"></a>1.3 重要的Python库</h2><p>考虑到那些还不太了解Python科学计算生态系统和库的读者，下面我先对各个库做一个简单的介绍。</p><h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><p>NumPy（Numerical Python的简称）是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能（不限于此）：</p><ul><li><p>快速高效的多维数组对象ndarray。</p></li><li><p>用于对数组执行元素级计算以及直接对数组执行数学运算的函数。</p></li><li><p>用于读写硬盘上基于数组的数据集的工具。</p></li><li><p>线性代数运算、傅里叶变换，以及随机数生成。 </p><p>-成熟的C API， 用于Python插件和原生C、C++、Fortran代码访问NumPy的数据结构和计算工具。</p></li></ul><p>除了为Python提供快速的数组处理能力，NumPy在数据分析方面还有另外一个主要作用，即作为在算法和库之间传递数据的容器。对于数值型数据，NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外，由低级语言（比如C和Fortran）编写的库可以直接操作NumPy数组中的数据，无需进行任何数据复制工作。因此，许多Python的数值计算工具要么使用NumPy数组作为主要的数据结构，要么可以与NumPy进行无缝交互操作。</p><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>pandas提供了快速便捷处理结构化数据的大量数据结构和函数。自从2010年出现以来，它助使Python成为强大而高效的数据分析环境。本书用得最多的pandas对象是DataFrame，它是一个面向列（column-oriented）的二维表结构，另一个是Series，一个一维的标签化数组对象。</p><p>pandas兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库（如SQL）灵活的数据处理功能。它提供了复杂精细的索引功能，能更加便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。因为数据操作、准备、清洗是数据分析最重要的技能，pandas是本书的重点。</p><p>作为背景，我是在2008年初开始开发pandas的，那时我任职于AQR Capital Management，一家量化投资管理公司，我有许多工作需求都不能用任何单一的工具解决：</p><ul><li>有标签轴的数据结构，支持自动或清晰的数据对齐。这可以防止由于数据不对齐，或处理来源不同的索引不同的数据，所造成的错误。</li><li>集成时间序列功能。</li><li>相同的数据结构用于处理时间序列数据和非时间序列数据。</li><li>保存元数据的算术运算和压缩。</li><li>灵活处理缺失数据。</li><li>合并和其它流行数据库（例如基于SQL的数据库）的关系操作。</li></ul><p>我想只用一种工具就实现所有功能，并使用通用软件开发语言。Python是一个不错的候选语言，但是此时没有集成的数据结构和工具来实现。我一开始就是想把pandas设计为一款适用于金融和商业分析的工具，pandas专注于深度时间序列功能和工具，适用于时间索引化的数据。</p><p>对于使用R语言进行统计计算的用户，肯定不会对DataFrame这个名字感到陌生，因为它源自于R的data.frame对象。但与Python不同，data frames是构建于R和它的标准库。因此，pandas的许多功能不属于R或它的扩展包。</p><p>pandas这个名字源于panel data（面板数据，这是多维结构化数据集在计量经济学中的术语）以及Python data analysis（Python数据分析）。</p><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><p>matplotlib是最流行的用于绘制图表和其它二维数据可视化的Python库。它最初由John D.Hunter（JDH）创建，目前由一个庞大的开发团队维护。它非常适合创建出版物上用的图表。虽然还有其它的Python可视化库，matplotlib却是使用最广泛的，并且它和其它生态工具配合也非常完美。我认为，可以使用它作为默认的可视化工具。</p><h3 id="IPython和Jupyter"><a href="#IPython和Jupyter" class="headerlink" title="IPython和Jupyter"></a>IPython和Jupyter</h3><p>IPython项目起初是Fernando Pérez在2001年的一个用以加强和Python交互的子项目。在随后的16年中，它成为了Python数据栈最重要的工具之一。虽然IPython本身没有提供计算和数据分析的工具，它却可以大大提高交互式计算和软件开发的生产率。IPython鼓励“执行-探索”的工作流，区别于其它编程软件的“编辑-编译-运行”的工作流。它还可以方便地访问系统的shell和文件系统。因为大部分的数据分析代码包括探索、试错和重复，IPython可以使工作更快。</p><p>2014年，Fernando和IPython团队宣布了Jupyter项目，一个更宽泛的多语言交互计算工具的计划。IPython web notebook变成了Jupyter notebook，现在支持40种编程语言。IPython现在可以作为Jupyter使用Python的内核（一种编程语言模式）。</p><p>IPython变成了Jupyter庞大开源项目（一个交互和探索式计算的高效环境）中的一个组件。它最老也是最简单的模式，现在是一个用于编写、测试、调试Python代码的强化shell。你还可以使用通过Jupyter Notebook，一个支持多种语言的交互式网络代码“笔记本”，来使用IPython。IPython shell 和Jupyter notebooks特别适合进行数据探索和可视化。</p><p>Jupyter notebooks还可以编写Markdown和HTML内容，它提供了一种创建代码和文本的富文本方法。其它编程语言也在Jupyter中植入了内核，好让在Jupyter中可以使用Python以外的语言。</p><p>对我个人而言，我的大部分Python工作都要用到IPython，包括运行、调试和测试代码。</p><p>在本书的GitHub页面，你可以找到包含各章节所有代码实例的Jupyter notebooks。</p><h3 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h3><p>SciPy是一组专门解决科学计算中各种标准问题域的包的集合，主要包括下面这些包：</p><ul><li>scipy.integrate：数值积分例程和微分方程求解器。</li><li>scipy.linalg：扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。</li><li>scipy.optimize：函数优化器（最小化器）以及根查找算法。</li><li>scipy.signal：信号处理工具。</li><li>scipy.sparse：稀疏矩阵和稀疏线性系统求解器。</li><li>scipy.special：SPECFUN（这是一个实现了许多常用数学函数（如伽玛函数）的Fortran库）的包装器。</li><li>scipy.stats：标准连续和离散概率分布（如密度函数、采样器、连续分布函数等）、各种统计检验方法，以及更好的描述统计法。</li></ul><p>NumPy和SciPy结合使用，便形成了一个相当完备和成熟的计算平台，可以处理多种传统的科学计算问题。</p><h3 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h3><p>2010年诞生以来，scikit-learn成为了Python的通用机器学习工具包。仅仅七年，就汇聚了全世界超过1500名贡献者。它的子模块包括：</p><ul><li>分类：SVM、近邻、随机森林、逻辑回归等等。</li><li>回归：Lasso、岭回归等等。</li><li>聚类：k-均值、谱聚类等等。</li><li>降维：PCA、特征选择、矩阵分解等等。</li><li>选型：网格搜索、交叉验证、度量。</li><li>预处理：特征提取、标准化。</li></ul><p>与pandas、statsmodels和IPython一起，scikit-learn对于Python成为高效数据科学编程语言起到了关键作用。虽然本书不会详细讲解scikit-learn，我会简要介绍它的一些模型，以及用其它工具如何使用这些模型。</p><h3 id="statsmodels"><a href="#statsmodels" class="headerlink" title="statsmodels"></a>statsmodels</h3><p>statsmodels是一个统计分析包，起源于斯坦福大学统计学教授Jonathan Taylor，他设计了多种流行于R语言的回归分析模型。Skipper Seabold和Josef Perktold在2010年正式创建了statsmodels项目，随后汇聚了大量的使用者和贡献者。受到R的公式系统的启发，Nathaniel Smith发展出了Patsy项目，它提供了statsmodels的公式或模型的规范框架。</p><p>与scikit-learn比较，statsmodels包含经典统计学和经济计量学的算法。包括如下子模块：</p><ul><li>回归模型：线性回归，广义线性模型，健壮线性模型，线性混合效应模型等等。</li><li>方差分析（ANOVA）。</li><li>时间序列分析：AR，ARMA，ARIMA，VAR和其它模型。</li><li>非参数方法： 核密度估计，核回归。</li><li>统计模型结果可视化。</li></ul><p>statsmodels更关注与统计推断，提供不确定估计和参数p-值。相反的，scikit-learn注重预测。</p><p>同scikit-learn一样，我也只是简要介绍statsmodels，以及如何用NumPy和pandas使用它。</p><h2 id="1-4-安装和设置"><a href="#1-4-安装和设置" class="headerlink" title="1.4 安装和设置"></a>1.4 安装和设置</h2><p>由于人们用Python所做的事情不同，所以没有一个普适的Python及其插件包的安装方案。由于许多读者的Python科学计算环境都不能完全满足本书的需要，所以接下来我将详细介绍各个操作系统上的安装方法。我推荐免费的Anaconda安装包。写作本书时，Anaconda提供Python 2.7和3.6两个版本，以后可能发生变化。本书使用的是Python 3.6，因此推荐选择Python 3.6或更高版本。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>要在Windows上运行，先下载<a href="https://www.anaconda.com/download/">Anaconda安装包</a>。推荐跟随Anaconda下载页面的Windows安装指导，安装指导在写作本书和读者看到此文的的这段时间内可能发生变化。</p><p>现在，来确认设置是否正确。打开命令行窗口（<code>cmd.exe</code>），输入<code>python</code>以打开Python解释器。可以看到类似下面的Anaconda版本的输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\wesm&gt;python</span><br><span class="line">Python 3.5.2 |Anaconda 4.1.1 (64-bit)| (default, Jul  5 2016, 11:41:13)</span><br><span class="line">[MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>要退出shell，按Ctrl-D（Linux或macOS上），Ctrl-Z（Windows上），或输入命令<code>exit()</code>，再按Enter。</p><h3 id="Apple-OS-X-macOS"><a href="#Apple-OS-X-macOS" class="headerlink" title="Apple (OS X, macOS)"></a>Apple (OS X, macOS)</h3><p>下载OS X Anaconda安装包，它的名字类似Anaconda3-4.1.0-MacOSX-x86_64.pkg。双击.pkg文件，运行安装包。安装包运行时，会自动将Anaconda执行路径添加到<code>.bash_profile</code>文件，它位于<code>/Users/$USER/.bash_profile</code>。</p><p>为了确认成功，在系统shell打开IPython：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipython</span><br></pre></td></tr></table></figure><p>要退出shell，按Ctrl-D，或输入命令<code>exit()</code>，再按Enter。</p><h3 id="GNU-x2F-Linux"><a href="#GNU-x2F-Linux" class="headerlink" title="GNU&#x2F;Linux"></a>GNU&#x2F;Linux</h3><p>Linux版本很多，这里给出Debian、Ubantu、CentOS和Fedora的安装方法。安装包是一个脚本文件，必须在shell中运行。取决于系统是32位还是64位，要么选择x86 (32位)或x86_64 (64位)安装包。随后你会得到一个文件，名字类似于<code>Anaconda3-4.1.0-Linux-x86_64.sh</code>。用bash进行安装：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash Anaconda3-4.1.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><blockquote><p>笔记：某些Linux版本在包管理器中有满足需求的Python包，只需用类似apt的工具安装就行。这里讲的用Anaconda安装，适用于不同的Linux安装包，也很容易将包升级到最新版本。</p></blockquote><p>接受许可之后，会向你询问在哪里放置Anaconda的文件。我推荐将文件安装到默认的home目录，例如<code>/home/$USER/anaconda</code>。</p><p>Anaconda安装包可能会询问你是否将<code>bin/</code>目录添加到<code>$PATH</code>变量。如果在安装之后有任何问题，你可以修改文件<code>.bashrc</code>（或<code>.zshrc</code>，如果使用的是zsh shell）为类似以下的内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/home/$USER/anaconda/bin:$PATH</span><br></pre></td></tr></table></figure><p>做完之后，你可以开启一个新窗口，或再次用<code>~/.bashrc</code>执行<code>.bashrc</code>。</p><h3 id="安装或升级Python包"><a href="#安装或升级Python包" class="headerlink" title="安装或升级Python包"></a>安装或升级Python包</h3><p>在你阅读本书的时候，你可能想安装另外的不在Anaconda中的Python包。通常，可以用以下命令安装：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure><p>如果这个命令不行，也可以用pip包管理工具：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure><p>你可以用<code>conda update</code>命令升级包：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure><p>pip可以用<code>--upgrade</code>升级：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure><p>本书中，你有许多机会尝试这些命令。</p><blockquote><p>注意：当你使用conda和pip二者安装包时，千万不要用pip升级conda的包，这样会导致环境发生问题。当使用Anaconda或Miniconda时，最好首先使用conda进行升级。</p></blockquote><p>Python 2 和 Python 3</p><p>第一版的Python 3.x出现于2008年。它有一系列的变化，与之前的Python 2.x代码有不兼容的地方。因为从1991年Python出现算起，已经过了17年，Python 3 的出现被视为吸取一些列教训的更优结果。</p><p>2012年，因为许多包还没有完全支持Python 3，许多科学和数据分析社区还是在使用Python 2.x。因此，本书第一版使用的是Python 2.7。现在，用户可以在Python 2.x和Python 3.x间自由选择，二者都有良好的支持。</p><p>但是，Python 2.x在2020年就会到期（包括重要的安全补丁），因此再用Python 2.7就不是好的选择了。因此，本书使用了Python 3.6，这一广泛使用、支持良好的稳定版本。我们已经称Python 2.x为“遗留版本”，简称Python 3.x为“Python”。我建议你也是如此。</p><p>本书基于Python 3.6。你的Python版本也许高于3.6，但是示例代码应该是向前兼容的。一些示例代码可能在Python 2.7上有所不同，或完全不兼容。</p><h3 id="集成开发环境（IDEs）和文本编辑器"><a href="#集成开发环境（IDEs）和文本编辑器" class="headerlink" title="集成开发环境（IDEs）和文本编辑器"></a>集成开发环境（IDEs）和文本编辑器</h3><p>当被问到我的标准开发环境，我几乎总是回答“IPython加文本编辑器”。我通常在编程时，反复在IPython或Jupyter notebooks中测试和调试每条代码。也可以交互式操作数据，和可视化验证数据操作中某一特殊集合。在shell中使用pandas和NumPy也很容易。</p><p>但是，当创建软件时，一些用户可能更想使用特点更为丰富的IDE，而不仅仅是原始的Emacs或Vim的文本编辑器。以下是一些IDE：</p><ul><li>PyDev（免费），基于Eclipse平台的IDE；</li><li>JetBrains的PyCharm（商业用户需要订阅，开源开发者免费）；</li><li>Visual Studio（Windows用户）的Python Tools；</li><li>Spyder（免费），Anaconda附带的IDE；</li><li>Komodo IDE（商业）。</li></ul><p>因为Python的流行，大多数文本编辑器，比如Atom和Sublime Text 3，对Python的支持也非常好。</p><h2 id="1-5-社区和会议"><a href="#1-5-社区和会议" class="headerlink" title="1.5 社区和会议"></a>1.5 社区和会议</h2><p>除了在网上搜索，各式各样的科学和数据相关的Python邮件列表是非常有帮助的，很容易获得回答。包括：</p><ul><li>pydata：一个Google群组列表，用以回答Python数据分析和pandas的问题；</li><li>pystatsmodels： statsmodels或pandas相关的问题；</li><li>scikit-learn和Python机器学习邮件列表，<a href="mailto:&#115;&#99;&#x69;&#x6b;&#x69;&#x74;&#x2d;&#108;&#101;&#x61;&#x72;&#x6e;&#64;&#112;&#121;&#116;&#x68;&#x6f;&#110;&#x2e;&#111;&#114;&#x67;">&#115;&#99;&#x69;&#x6b;&#x69;&#x74;&#x2d;&#108;&#101;&#x61;&#x72;&#x6e;&#64;&#112;&#121;&#116;&#x68;&#x6f;&#110;&#x2e;&#111;&#114;&#x67;</a>；</li><li>numpy-discussion：和NumPy相关的问题；</li><li>scipy-user：SciPy和科学计算的问题；</li></ul><p>因为这些邮件列表的URLs可以很容易搜索到，但因为可能发生变化，所以没有给出。</p><p>每年，世界各地会举办许多Python开发者大会。如果你想结识其他有相同兴趣的人，如果可能的话，我建议你去参加一个。许多会议会对无力支付入场费和差旅费的人提供财力帮助。下面是一些会议：</p><ul><li>PyCon和EuroPython：北美和欧洲的两大Python会议；</li><li>SciPy和EuroSciPy：北美和欧洲两大面向科学计算的会议；</li><li>PyData：世界范围内，一些列的地区性会议，专注数据科学和数据分析；</li><li>国际和地区的PyCon会议（<a href="http://pycon.org有完整列表)/">http://pycon.org有完整列表）</a> 。</li></ul><h2 id="1-6-本书导航"><a href="#1-6-本书导航" class="headerlink" title="1.6 本书导航"></a>1.6 本书导航</h2><p>如果之前从未使用过Python，那你可能需要先看看本书的第2章和第3章，我简要介绍了Python的特点，IPython和Jupyter notebooks。这些知识是为本书后面的内容做铺垫。如果你已经掌握Python，可以选择跳过。</p><p>接下来，简单地介绍了NumPy的关键特性，附录A中是更高级的NumPy功能。然后，我介绍了pandas，本书剩余的内容全部是使用pandas、NumPy和matplotlib处理数据分析的问题。我已经尽量让全书的结构循序渐进，但偶尔会有章节之间的交叉，有时用到的概念还没有介绍过。</p><p>尽管读者各自的工作任务不同，大体可以分为几类：</p><ul><li><p>与外部世界交互</p><p>阅读编写多种文件格式和数据存储；</p></li><li><p>数据准备</p><p>清洗、修改、结合、标准化、重塑、切片、切割、转换数据，以进行分析；</p></li><li><p>转换数据</p><p>对旧的数据集进行数学和统计操作，生成新的数据集（例如，通过各组变量聚类成大的表）；</p></li><li><p>建模和计算</p><p>将数据绑定统计模型、机器学习算法、或其他计算工具；</p></li><li><p>展示</p><p>创建交互式和静态的图表可视化和文本总结。</p></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>本书大部分代码示例的输入形式和输出结果都会按照其在IPython shell或Jupyter notebooks中执行时的样子进行排版：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [5]: CODE EXAMPLE</span><br><span class="line">Out[5]: OUTPUT</span><br></pre></td></tr></table></figure><p>但你看到类似的示例代码，就是让你在<code>in</code>的部分输入代码，按Enter键执行（Jupyter中是按Shift-Enter）。然后就可以在<code>out</code>看到输出。</p><h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h3><p>各章的示例数据都存放在GitHub上：<a href="http://github.com/pydata/pydata-book%E3%80%82">http://github.com/pydata/pydata-book。</a> 下载这些数据的方法有二：使用git版本控制命令行程序；直接从网站上下载该GitHub库的zip文件。如果遇到了问题，可以到我的个人主页，<a href="http://wesmckinney.com/%EF%BC%8C">http://wesmckinney.com/，</a> 获取最新的指导。</p><p>为了让所有示例都能重现，我已经尽我所能使其包含所有必需的东西，但仍然可能会有一些错误或遗漏。如果出现这种情况的话，请给我发邮件：<a href="mailto:&#x77;&#x65;&#115;&#x6d;&#99;&#107;&#x69;&#x6e;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;">&#x77;&#x65;&#115;&#x6d;&#99;&#107;&#x69;&#x6e;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;</a>。报告本书错误的最好方法是O’Reilly的errata页面，<a href="http://www.bit.ly/pyDataAnalysis_errata%E3%80%82">http://www.bit.ly/pyDataAnalysis_errata。</a></p><h3 id="引入惯例"><a href="#引入惯例" class="headerlink" title="引入惯例"></a>引入惯例</h3><p>Python社区已经广泛采取了一些常用模块的命名惯例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> statsmodels <span class="keyword">as</span> sm</span><br></pre></td></tr></table></figure><p>也就是说，当你看到np.arange时，就应该想到它引用的是NumPy中的arange函数。这样做的原因是：在Python软件开发过程中，不建议直接引入类似NumPy这种大型库的全部内容（from numpy import *）。</p><h3 id="行话"><a href="#行话" class="headerlink" title="行话"></a>行话</h3><p>由于你可能不太熟悉书中使用的一些有关编程和数据科学方面的常用术语，所以我在这里先给出其简单定义：</p><p>数据规整（Munge&#x2F;Munging&#x2F;Wrangling） 指的是将非结构化和（或）散乱数据处理为结构化或整洁形式的整个过程。这几个词已经悄悄成为当今数据黑客们的行话了。Munge这个词跟Lunge押韵。</p><p>伪码（Pseudocode） 算法或过程的“代码式”描述，而这些代码本身并不是实际有效的源代码。</p><p>语法糖（Syntactic sugar） 这是一种编程语法，它并不会带来新的特性，但却能使代码更易读、更易写。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/README/"/>
      <url>/2022/02/26/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/README/</url>
      
        <content type="html"><![CDATA[<h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><p><img src="http://upload-images.jianshu.io/upload_images/7178691-0d965cf51eb5af9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在简书上阅读： <a href="https://www.jianshu.com/p/04d180d90a3f">https://www.jianshu.com/p/04d180d90a3f</a></p><p>下载本书：<a href="http://www.jianshu.com/p/fad9e41c1a42">http://www.jianshu.com/p/fad9e41c1a42</a> （更新为GitHub链接）</p><p>下载本书代码（本书GitHub地址）：<a href="https://github.com/wesm/pydata-book">https://github.com/wesm/pydata-book</a> （建议把代码下载下来之后，安装好Anaconda 3.6，在目录文件夹中用Jupyter notebook打开）</p><p>本书是2017年10月20号正式出版的，和第1版的不同之处有：</p><ul><li>包括Python教程内的所有代码升级为Python 3.6（第1版使用的是Python 2.7）</li><li>更新了Anaconda和其它包的Python安装方法</li><li>更新了Pandas为2017最新版</li><li>新增了一章，关于更高级的Pandas工具，外加一些tips</li><li>简要介绍了使用StatsModels和scikit-learn</li></ul><p>对有些内容进行了重新排版。（译者注1：最大的改变是把第1版附录中的Python教程，单列成了现在的第2章和第3章，并且进行了扩充。可以说，本书第2版对新手更为友好了！）</p><p>（译者注2：毫无疑问，本书是学习Python数据分析最好的参考书。本来想把书名直接译为《Python数据分析》，这样更简短。但是为了尊重第1版的翻译，考虑到继承性，还是用老书名。这样读过第一版的老读者可以方便的用之前的书名检索到第二版。作者在写第二版的时候，有些文字是照搬第一版的。所以第二版的翻译也借鉴copy了第一版翻译：即，如果第二版中有和第一版相同的文字，则copy第一版的中文译本，觉得不妥的地方会稍加修改，剩下的不同的内容就自己翻译。这样做也是为读过第一版的老读者考虑——相同的内容可以直接跳过。）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/08/hello-world/"/>
      <url>/2022/02/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
